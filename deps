
    I[] *
        <-- am.englet.MethodsStorage$Training$Invocation.clone()
    I[][] *
        <-- t.main(java.lang.String[])
    t
        --> java.lang.Object *
        main(java.lang.String[])
            --> I[][] *
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(int) *
            --> java.lang.String *
            --> java.lang.System.out *
        t()
            --> java.lang.Object.Object() *
    t1
        --> java.lang.Object *
        main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(int) *
            --> java.lang.String *
            --> java.lang.System.out *
            --> t1.s()
        s
            <-- t1.s()
            <-- t1.static {}
        s()
            <-- t1.main(java.lang.String[])
            --> t1.s
        static {}
            --> t1.s
        t1()
            --> java.lang.Object.Object() *
am.beans.reflect
    ClassInfo
        --> java.lang.Object *
        ClassInfo()
            --> java.lang.Object.Object() *
    ClassMap
        --> java.util.HashMap *
        ClassMap()
            --> am.beans.reflect.ClassMap.put(java.lang.Object, java.lang.Object) *
            --> java.lang.Boolean.TYPE *
            --> java.lang.Byte.TYPE *
            --> java.lang.Character.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.toString() *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Void.TYPE *
            --> java.util.HashMap.HashMap() *
        class$0
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            --> java.lang.Class *
        forName(java.lang.String)
            --> am.beans.reflect.ClassMap.class$0
            --> am.beans.reflect.ClassMap.get(java.lang.String)
            --> am.beans.reflect.ClassMap.put(java.lang.Object, java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        get(java.lang.String)
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.HashMap.get(java.lang.Object) *
        importClassName(java.lang.String)
            --> am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
            --> java.lang.String *
            --> java.lang.String.lastIndexOf(int) *
            --> java.lang.String.substring(int) *
        importClassName(java.lang.String, java.lang.String)
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String)
            --> am.beans.reflect.ClassMap.put(java.lang.Object, java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
        put(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
    ClassMap$v
        --> java.lang.Object *
        ClassMap$v()
            --> java.lang.Object.Object() *
    ConstructorCaller
        --> am.beans.reflect.MemberCaller
        ConstructorCaller(java.lang.reflect.Constructor)
            --> am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        call()
            --> am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
        call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.ConstructorCaller.call()
            <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object[])
            --> am.beans.reflect.ConstructorCaller.con()
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
        call(java.lang.Object[])
            --> am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
        con()
            <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.ConstructorCaller.m *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        m *
            <-- am.beans.reflect.ConstructorCaller.con()
    Destringer
        <-- am.beans.reflect.Destringer$1
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer
        --> java.lang.Object *
        Destringer()
            <-- am.beans.reflect.Destringer$1.Destringer$1()
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.Destringer$SimpleConstructorDestringer(java.lang.reflect.Constructor)
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.Destringer$SimpleMethodDestringer(java.lang.reflect.Method)
            --> java.lang.Object.Object() *
        FOUND
            <-- am.beans.reflect.Destringer.dump()
            <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
            --> java.util.HashMap *
        NOTHING
            <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
        class$0
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$1
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$2
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$3
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$4
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$5
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$6
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$7
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
        class$8
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            --> java.lang.Class *
        description()
            <-- am.beans.reflect.Destringer.toString()
            --> java.lang.String *
        dump()
            --> am.beans.reflect.Destringer.FOUND
            --> java.lang.String *
            --> java.util.HashMap *
            --> java.util.HashMap.toString() *
        forClass(java.lang.Class)
            --> am.beans.reflect.Destringer.FOUND
            --> am.beans.reflect.Destringer.NOTHING
            --> am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
        forClass0(java.lang.Class)
            --> am.beans.reflect.Destringer$SimpleConstructorDestringer.Destringer$SimpleConstructorDestringer(java.lang.reflect.Constructor)
            --> am.beans.reflect.Destringer$SimpleMethodDestringer.Destringer$SimpleMethodDestringer(java.lang.reflect.Method)
            --> am.beans.reflect.Destringer.NOTHING
            --> am.beans.reflect.Destringer.class$8
            <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.Class.getMethods() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        forString(java.lang.String)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
        processTYPE(java.lang.Class)
            --> am.beans.reflect.Destringer.FOUND
            --> am.beans.reflect.Destringer.forClass(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
            --> java.lang.Class *
            --> java.lang.Class.getField(java.lang.String) *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
            --> java.util.HashMap *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
        static {}
            --> am.beans.reflect.Destringer$1.Destringer$1()
            --> am.beans.reflect.Destringer.FOUND
            --> am.beans.reflect.Destringer.NOTHING
            --> am.beans.reflect.Destringer.class$0
            --> am.beans.reflect.Destringer.class$1
            --> am.beans.reflect.Destringer.class$2
            --> am.beans.reflect.Destringer.class$3
            --> am.beans.reflect.Destringer.class$4
            --> am.beans.reflect.Destringer.class$5
            --> am.beans.reflect.Destringer.class$6
            --> am.beans.reflect.Destringer.class$7
            --> am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
        toString()
            --> am.beans.reflect.Destringer.description()
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    Destringer$1
        --> am.beans.reflect.Destringer
        Destringer$1()
            --> am.beans.reflect.Destringer.Destringer()
            <-- am.beans.reflect.Destringer.static {}
        forString(java.lang.String)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
    Destringer$SimpleConstructorDestringer
        --> am.beans.reflect.Destringer
        Destringer$SimpleConstructorDestringer(java.lang.reflect.Constructor)
            --> am.beans.reflect.Destringer$SimpleConstructorDestringer.constructor
            --> am.beans.reflect.Destringer.Destringer()
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            --> java.lang.reflect.Constructor *
        constructor
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.Destringer$SimpleConstructorDestringer(java.lang.reflect.Constructor)
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
            --> java.lang.reflect.Constructor *
        description()
            --> am.beans.reflect.Destringer$SimpleConstructorDestringer.constructor
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Constructor *
        forString(java.lang.String)
            --> am.beans.reflect.Destringer$SimpleConstructorDestringer.constructor
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
    Destringer$SimpleMethodDestringer
        --> am.beans.reflect.Destringer
        Destringer$SimpleMethodDestringer(java.lang.reflect.Method)
            --> am.beans.reflect.Destringer$SimpleMethodDestringer.method
            --> am.beans.reflect.Destringer.Destringer()
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            --> java.lang.reflect.Method *
        description()
            --> am.beans.reflect.Destringer$SimpleMethodDestringer.method
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Method *
        forString(java.lang.String)
            --> am.beans.reflect.Destringer$SimpleMethodDestringer.method
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        method
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.Destringer$SimpleMethodDestringer(java.lang.reflect.Method)
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
            --> java.lang.reflect.Method *
    FieldGetter
        --> am.beans.reflect.Getter
        --> am.beans.reflect.MemberCaller
        FieldGetter(java.lang.reflect.Field)
            --> am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.FieldGetter.f()
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
        f()
            <-- am.beans.reflect.FieldGetter.call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.FieldGetter.get(java.lang.Object)
            --> am.beans.reflect.FieldGetter.m *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        get(java.lang.Object)
            --> am.beans.reflect.FieldGetter.f()
            <-- am.beans.reflect.FieldGetter.get(java.lang.Object, int)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
        get(java.lang.Object, int)
            --> am.beans.reflect.FieldGetter.get(java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Array.get(java.lang.Object, int) *
        m *
            <-- am.beans.reflect.FieldGetter.f()
    FieldSetter
        --> am.beans.reflect.MemberCaller
        --> am.beans.reflect.Setter
        FieldSetter(java.lang.reflect.Field)
            --> am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.FieldSetter.f()
            --> am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
            <-- am.beans.reflect.FieldSetter.set(java.lang.Object, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.set(java.lang.Object, java.lang.Object) *
        f()
            <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.FieldSetter.m *
            <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        get(java.lang.Object, java.lang.reflect.Field)
            <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
            --> java.lang.IllegalAccessException *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
        m *
            <-- am.beans.reflect.FieldSetter.f()
        set(java.lang.Object, int, java.lang.Object)
            --> am.beans.reflect.FieldSetter.f()
            --> am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Array.get(java.lang.Object, int) *
            --> java.lang.reflect.Array.set(java.lang.Object, int, java.lang.Object) *
            --> java.lang.reflect.Field *
        set(java.lang.Object, java.lang.Object)
            --> am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
    Getter
        <-- am.beans.reflect.FieldGetter
        <-- am.beans.reflect.MethodCallerBasedGetter
        <-- am.beans.reflect.Property
        <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
        <-- am.beans.reflect.Property.get(java.lang.Object)
        <-- am.beans.reflect.Property.get(java.lang.Object, int)
        <-- am.beans.reflect.Property.getter
        --> java.lang.Object *
        get(java.lang.Object)
            <-- am.beans.reflect.Property.get(java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
        get(java.lang.Object, int)
            <-- am.beans.reflect.Property.get(java.lang.Object, int)
            --> java.lang.Exception *
            --> java.lang.Object *
    MemberCaller
        <-- am.beans.reflect.ConstructorCaller
        <-- am.beans.reflect.FieldGetter
        <-- am.beans.reflect.FieldSetter
        <-- am.beans.reflect.MethodCaller
        --> java.lang.Object *
        MemberCaller(java.lang.reflect.Member)
            <-- am.beans.reflect.ConstructorCaller.ConstructorCaller(java.lang.reflect.Constructor)
            <-- am.beans.reflect.FieldGetter.FieldGetter(java.lang.reflect.Field)
            <-- am.beans.reflect.FieldSetter.FieldSetter(java.lang.reflect.Field)
            --> am.beans.reflect.MemberCaller.m
            <-- am.beans.reflect.MethodCaller.MethodCaller(java.lang.reflect.Method)
            --> java.lang.Object.Object() *
            --> java.lang.reflect.Member *
        call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
        m
            <-- am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            --> java.lang.reflect.Member *
    MethodCaller
        --> am.beans.reflect.MemberCaller
        <-- am.beans.reflect.MethodCallerBasedGetter.MethodCallerBasedGetter(am.beans.reflect.MethodCaller)
        <-- am.beans.reflect.MethodCallerBasedGetter.caller
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
        <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
        <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller, int)
        <-- am.beans.reflect.MethodCallerBasedSetter.caller
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
        MethodCaller(java.lang.reflect.Method)
            --> am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        call()
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
        call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.MethodCaller.call()
            <-- am.beans.reflect.MethodCaller.call(java.lang.Object[])
            --> am.beans.reflect.MethodCaller.m()
            <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object)
            <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        call(java.lang.Object[])
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> java.lang.Exception *
            --> java.lang.Object *
        m *
            <-- am.beans.reflect.MethodCaller.m()
        m()
            <-- am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.MethodCaller.m *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
    MethodCallerBasedGetter
        --> am.beans.reflect.Getter
        --> java.lang.Object *
        MethodCallerBasedGetter(am.beans.reflect.MethodCaller)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCallerBasedGetter.caller
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            --> java.lang.Object.Object() *
        caller
            --> am.beans.reflect.MethodCaller
            <-- am.beans.reflect.MethodCallerBasedGetter.MethodCallerBasedGetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object)
            <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
        get(java.lang.Object)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.MethodCallerBasedGetter.caller
            --> java.lang.Exception *
            --> java.lang.Object *
        get(java.lang.Object, int)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.MethodCallerBasedGetter.caller
            --> java.lang.Exception *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
    MethodCallerBasedSetter
        --> am.beans.reflect.Setter
        --> java.lang.Object *
        MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCallerBasedSetter.caller
            --> am.beans.reflect.MethodCallerBasedSetter.indexPosition
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            --> java.lang.Object.Object() *
        MethodCallerBasedSetter(am.beans.reflect.MethodCaller, int)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCallerBasedSetter.caller
            --> am.beans.reflect.MethodCallerBasedSetter.indexPosition
            --> java.lang.Object.Object() *
        caller
            --> am.beans.reflect.MethodCaller
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller, int)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, java.lang.Object)
        indexPosition
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller, int)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
        set(java.lang.Object, int, java.lang.Object)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.MethodCallerBasedSetter.caller
            --> am.beans.reflect.MethodCallerBasedSetter.indexPosition
            --> java.lang.Exception *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
        set(java.lang.Object, java.lang.Object)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            --> am.beans.reflect.MethodCallerBasedSetter.caller
            --> java.lang.Exception *
            --> java.lang.Object *
    Property
        --> am.beans.reflect.Getter
        --> am.beans.reflect.Setter
        --> java.lang.Object *
        Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            --> am.beans.reflect.Getter
            --> am.beans.reflect.Property.dataType
            --> am.beans.reflect.Property.getter
            --> am.beans.reflect.Property.name
            --> am.beans.reflect.Property.of_class
            --> am.beans.reflect.Property.setter
            --> am.beans.reflect.Setter
            --> java.lang.Class *
            --> java.lang.Object.Object() *
            --> java.lang.String *
        dataType
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            --> java.lang.Class *
        get(java.lang.Object)
            --> am.beans.reflect.Getter
            --> am.beans.reflect.Getter.get(java.lang.Object)
            --> am.beans.reflect.Property.getter
            --> java.lang.Exception *
            --> java.lang.Object *
        get(java.lang.Object, int)
            --> am.beans.reflect.Getter
            --> am.beans.reflect.Getter.get(java.lang.Object, int)
            --> am.beans.reflect.Property.getter
            --> java.lang.Exception *
            --> java.lang.Object *
        getter
            --> am.beans.reflect.Getter
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            <-- am.beans.reflect.Property.get(java.lang.Object)
            <-- am.beans.reflect.Property.get(java.lang.Object, int)
        name
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            --> java.lang.String *
        of_class
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            --> java.lang.Class *
        set(java.lang.Object, int, java.lang.Object)
            --> am.beans.reflect.Property.setter
            --> am.beans.reflect.Setter
            --> am.beans.reflect.Setter.set(java.lang.Object, int, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
        set(java.lang.Object, java.lang.Object)
            --> am.beans.reflect.Property.setter
            --> am.beans.reflect.Setter
            --> am.beans.reflect.Setter.set(java.lang.Object, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
        setter
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            <-- am.beans.reflect.Property.set(java.lang.Object, int, java.lang.Object)
            <-- am.beans.reflect.Property.set(java.lang.Object, java.lang.Object)
            --> am.beans.reflect.Setter
    Setter
        <-- am.beans.reflect.FieldSetter
        <-- am.beans.reflect.MethodCallerBasedSetter
        <-- am.beans.reflect.Property
        <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
        <-- am.beans.reflect.Property.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Property.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Property.setter
        --> java.lang.Object *
        set(java.lang.Object, int, java.lang.Object)
            <-- am.beans.reflect.Property.set(java.lang.Object, int, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
        set(java.lang.Object, java.lang.Object)
            <-- am.beans.reflect.Property.set(java.lang.Object, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
    Utils
        --> java.lang.Object *
        Utils()
            --> java.lang.Object.Object() *
        addKeyed(java.util.Map, java.lang.Object, java.util.List)
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            --> java.lang.Object *
            --> java.util.Collection *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.addAll(java.util.Collection) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        classFieldGetters(java.lang.Class)
            --> am.beans.reflect.FieldGetter.FieldGetter(java.lang.reflect.Field)
            --> am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Class.getFields() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.util.Collections.singletonMap(java.lang.Object, java.lang.Object) *
            --> java.util.Map *
            --> java.util.TreeMap.TreeMap() *
        classMethodGettersRaw(java.lang.Class)
            --> am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.reflect.Method *
            --> java.util.Map *
            --> java.util.TreeMap.TreeMap() *
        getGetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.MethodCaller(java.lang.reflect.Method)
            --> am.beans.reflect.MethodCallerBasedGetter.MethodCallerBasedGetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
            --> am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
            --> am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.util.Collections.EMPTY_MAP *
            --> java.util.Map *
        getSetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.MethodCaller
            --> am.beans.reflect.MethodCaller.MethodCaller(java.lang.reflect.Method)
            --> am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
            --> am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
            --> am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.util.Collections.EMPTY_MAP *
            --> java.util.Map *
        getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.TreeMap *
            --> java.util.TreeMap.TreeMap() *
            --> java.util.TreeMap.put(java.lang.Object, java.lang.Object) *
        isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Integer.TYPE *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Integer.TYPE *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Void.TYPE *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        isInstanceVoid(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Void.TYPE *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        isSimpleGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        isSimpleSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            --> am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        merge(java.util.Map, java.util.Map)
            --> am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
            <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
            --> java.lang.Object *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.Map *
            --> java.util.Map.keySet() *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
            --> java.lang.Character.isUpperCase(char) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.length() *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toLowerCase() *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.TreeMap *
            --> java.util.TreeMap.put(java.lang.Object, java.lang.Object) *
am.englet
    $
        <-- am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$1.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$6
        <-- am.englet.$$Declared.$$Declared(am.englet.$)
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Declared.this$0
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$MethodPerformer.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$Performer.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$Performer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$Performer.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        --> am.englet.$Base
        <-- am.englet.Lookup$10
        <-- am.englet.Lookup$11
        <-- am.englet.Lookup$6
        <-- am.englet.LoopTest$1
        <-- am.englet.LoopTest$2
        <-- am.englet.LoopTest$3
        <-- am.englet.Management$1
        <-- am.englet.Management$2
        <-- am.englet.Management$4
        <-- am.englet.Management$5
        <-- am.englet.Management$6
        <-- am.englet.Management$7
        <-- am.englet.Utils$2
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2
        <-- am.englet.reflect.Utils$2
        <-- am.englet.reflect.Utils$3
        <-- am.englet.reflect.Utils$4
        <-- am.englet.reflect.Utils$5
        <-- am.englet.wiring.BuilderImpl$1
        <-- am.englet.wiring.PoolsBuilder$3
        $(int, int) *
            <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        $(java.lang.Class)
            --> am.englet.$$$Performer
            <-- am.englet.$$6.$$6(java.lang.Class)
            --> am.englet.$$Declared
            --> am.englet.$$Declared.$$Declared(am.englet.$)
            --> am.englet.$$Performer
            --> am.englet.$.$performer
            --> am.englet.$.PERFORMERS
            --> am.englet.$.cls
            --> am.englet.$.declared
            --> am.englet.$.performer
            --> am.englet.$Base.$Base()
            <-- am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup$11.Lookup$11(java.lang.Class, java.lang.Class)
            <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
            <-- am.englet.LoopTest$2.LoopTest$2(am.englet.LoopTest, java.lang.Class)
            <-- am.englet.LoopTest$3.LoopTest$3(am.englet.LoopTest, java.lang.Class)
            <-- am.englet.Management$1.Management$1(java.lang.Class, java.lang.String)
            <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            <-- am.englet.Management$4.Management$4(java.lang.Class, java.lang.String)
            <-- am.englet.Management$5.Management$5(java.lang.Class, java.lang.String)
            <-- am.englet.Management$6.Management$6(java.lang.Class, java.lang.String)
            <-- am.englet.Management$7.Management$7(java.lang.Class, java.lang.String)
            <-- am.englet.Utils$2.Utils$2(java.lang.Class, java.lang.String)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
            <-- am.englet.reflect.Utils$2.Utils$2(java.lang.Class)
            <-- am.englet.reflect.Utils$3.Utils$3(java.lang.Class)
            <-- am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils$5.Utils$5(java.lang.Class)
            <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.getDeclaredMethods() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        $(java.lang.Class, java.lang.Class)
            --> am.englet.$$$Performer
            --> am.englet.$$Declared
            --> am.englet.$$Declared.$$Declared(am.englet.$)
            --> am.englet.$$Performer
            --> am.englet.$.$performer
            --> am.englet.$.PERFORMERS
            --> am.englet.$.cls
            --> am.englet.$.declared
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> am.englet.$.performer
            --> am.englet.$Base.$Base()
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Boolean.TYPE *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        $(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$$Performer
            --> am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.$performer
            --> am.englet.$.members()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
        $performer
            --> am.englet.$$$Performer
            <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        CONSTRUCTOR_PERFORMER
            --> am.englet.$$Performer
            <-- am.englet.$.access$1()
            <-- am.englet.$.static {}
        DEPRIMITIIVISATORS
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.$.static {}
            <-- am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.util.Map *
        FIELD_PERFORMER
            --> am.englet.$$Performer
            <-- am.englet.$.access$0()
            <-- am.englet.$.static {}
        FIRST_$PERFORMER
            --> am.englet.$$$Performer
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.static {}
        LOOP_$PERFORMER
            --> am.englet.$$$Performer
            <-- am.englet.$.access$2()
            <-- am.englet.$.static {}
        METHOD_PERFORMER
            <-- am.englet.$$5.$$5()
            --> am.englet.$$Performer
            <-- am.englet.$.static {}
        PERFORMERS
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            --> java.util.Map *
        SUMMARY_$PERFORMER
            --> am.englet.$$$Performer
            <-- am.englet.$.access$3()
            <-- am.englet.$.static {}
        WRAPPERS
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            --> java.util.Set *
        access$0()
            <-- am.englet.$$5.$$5()
            --> am.englet.$$Performer
            --> am.englet.$.FIELD_PERFORMER
        access$1()
            <-- am.englet.$$5.$$5()
            --> am.englet.$$Performer
            --> am.englet.$.CONSTRUCTOR_PERFORMER
        access$2()
            --> am.englet.$$$Performer
            <-- am.englet.$$5.$$5()
            --> am.englet.$.LOOP_$PERFORMER
        access$3()
            --> am.englet.$$$Performer
            <-- am.englet.$$5.$$5()
            --> am.englet.$.SUMMARY_$PERFORMER
        access$4(am.englet.$)
            <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.declaredMembers()
            --> java.lang.reflect.Member *
        check(java.lang.reflect.Constructor)
            <-- am.englet.$$2.doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$.class$14
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
        check(java.lang.reflect.Field)
            <-- am.englet.$$1.doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$.class$14
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Field *
        check(java.lang.reflect.Method)
            <-- am.englet.$$MethodPerformer.doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$.class$14
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
        class$0
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$10
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> java.lang.Class *
        class$11
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> java.lang.Class *
        class$12
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        class$13
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
        class$14
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            --> java.lang.Class *
        class$2
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$3
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$4
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$5
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$6
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$7
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$8
            <-- am.englet.$.static {}
            --> java.lang.Class *
        class$9
            <-- am.englet.$$5.$$5()
            --> java.lang.Class *
        classComparator()
            --> am.englet.$$7.$$7()
            --> java.util.Comparator *
        cls
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.declaredMembers()
            <-- am.englet.$.members()
            --> java.lang.Class *
        constructor(java.lang.Class[]) *
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        declared
            --> am.englet.$$Declared
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        declaredMembers()
            --> am.englet.$$Performer
            --> am.englet.$$Performer.declaredMembers(java.lang.Class)
            <-- am.englet.$.access$4(am.englet.$)
            --> am.englet.$.cls
            --> am.englet.$.performer
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        each(java.lang.reflect.Constructor)
            <-- am.englet.$$2.doEach(am.englet.$, java.lang.reflect.Member)
            --> java.lang.reflect.Constructor *
        each(java.lang.reflect.Constructor, java.lang.Object)
            <-- am.englet.$$2.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        each(java.lang.reflect.Field)
            <-- am.englet.$$1.doEach(am.englet.$, java.lang.reflect.Member)
            --> java.lang.reflect.Field *
        each(java.lang.reflect.Field, java.lang.Object)
            <-- am.englet.$$1.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> java.lang.Object *
            --> java.lang.reflect.Field *
        each(java.lang.reflect.Method)
            <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.reflect.Member)
            --> java.lang.reflect.Method *
        each(java.lang.reflect.Method, java.lang.Object)
            <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        field(int, int, java.lang.Class) *
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        field(int, int, java.lang.String[]) *
            <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        instantiator(java.lang.Class, java.lang.Class[])
            --> am.englet.$$6.$$6(java.lang.Class)
            --> am.englet.$$6.method(int, int, java.lang.Class[]) *
            --> am.englet.$.$(java.lang.Class, java.lang.Class)
            --> am.englet.$.DEPRIMITIIVISATORS
            --> am.englet.$.class$10
            --> am.englet.$.class$11
            --> am.englet.$.constructor(java.lang.Class[]) *
            --> am.englet.$.field(int, int, java.lang.Class) *
            --> am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.Invokable.NO_CLASSES
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.reflect.MemberInvokable
            <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Method *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$$7.compare(java.lang.Object, java.lang.Object)
            --> am.englet.$.WRAPPERS
            --> am.englet.$.class$12
            <-- am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
            --> am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Set *
            --> java.util.Set.contains(java.lang.Object) *
        members()
            --> am.englet.$$Performer
            --> am.englet.$$Performer.members(java.lang.Class)
            <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.cls
            --> am.englet.$.performer
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        method() *
            <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        method(int, int, java.lang.Class[], java.lang.String[]) *
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        paramTypesCompare(java.lang.Class[], java.lang.Class[])
            --> am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.MethodsStorage$1.compare(java.lang.Object, java.lang.Object)
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        paramTypesEqual(java.lang.Class[], java.lang.Class[])
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        paramTypesFit(java.lang.Class[], java.lang.Class[])
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        performer
            <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Performer
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.declaredMembers()
            <-- am.englet.$.members()
        static {}
            --> am.englet.$$$Performer
            --> am.englet.$$1.$$1()
            --> am.englet.$$2.$$2()
            --> am.englet.$$3.$$3()
            --> am.englet.$$4.$$4()
            --> am.englet.$$5.$$5()
            --> am.englet.$$First$Performer.$$First$Performer()
            --> am.englet.$$MethodPerformer.$$MethodPerformer()
            --> am.englet.$$Performer
            --> am.englet.$.CONSTRUCTOR_PERFORMER
            --> am.englet.$.DEPRIMITIIVISATORS
            --> am.englet.$.FIELD_PERFORMER
            --> am.englet.$.FIRST_$PERFORMER
            --> am.englet.$.LOOP_$PERFORMER
            --> am.englet.$.METHOD_PERFORMER
            --> am.englet.$.PERFORMERS
            --> am.englet.$.SUMMARY_$PERFORMER
            --> am.englet.$.WRAPPERS
            --> am.englet.$.class$0
            --> am.englet.$.class$1
            --> am.englet.$.class$2
            --> am.englet.$.class$3
            --> am.englet.$.class$4
            --> am.englet.$.class$5
            --> am.englet.$.class$6
            --> am.englet.$.class$7
            --> am.englet.$.class$8
            --> java.lang.Boolean.TYPE *
            --> java.lang.Byte.TYPE *
            --> java.lang.Character.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Short.TYPE *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.Void.TYPE *
            --> java.util.Collection *
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.Collections.unmodifiableSet(java.util.Set) *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.HashSet.HashSet(java.util.Collection) *
            --> java.util.Map *
            --> java.util.Map.values() *
            --> java.util.Set *
    $$$Performer
        <-- am.englet.$$3
        <-- am.englet.$$4
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$First$Performer
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.$performer
        <-- am.englet.$.FIRST_$PERFORMER
        <-- am.englet.$.LOOP_$PERFORMER
        <-- am.englet.$.SUMMARY_$PERFORMER
        <-- am.englet.$.access$2()
        <-- am.englet.$.access$3()
        <-- am.englet.$.static {}
        --> java.lang.Object *
        $(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    $$1
        --> am.englet.$$Performer
        $$1()
            --> am.englet.$$Performer.$$Performer()
            <-- am.englet.$.static {}
        declaredMembers(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getDeclaredFields() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.check(java.lang.reflect.Field)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Field, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Field)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        members(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getFields() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        paramTypes(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getType() *
            --> java.lang.reflect.Member *
    $$2
        --> am.englet.$$Performer
        $$2()
            --> am.englet.$$Performer.$$Performer()
            <-- am.englet.$.static {}
        declaredMembers(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getDeclaredConstructors() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.check(java.lang.reflect.Constructor)
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Constructor, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Constructor)
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        members(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getConstructors() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        paramTypes(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
            --> java.lang.reflect.Member *
    $$3
        --> am.englet.$$$Performer
        --> java.lang.Object *
        $$3()
            <-- am.englet.$.static {}
            --> java.lang.Object.Object() *
        $(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            --> am.englet.$$Performer
            --> am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.performer
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    $$4
        --> am.englet.$$$Performer
        --> java.lang.Object *
        $$4()
            <-- am.englet.$.static {}
            --> java.lang.Object.Object() *
        $(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            --> am.englet.$$Performer
            --> am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.performer
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    $$5
        --> java.util.HashMap *
        $$5()
            --> am.englet.$$$Performer
            --> am.englet.$$5.put(java.lang.Object, java.lang.Object) *
            --> am.englet.$$Performer
            --> am.englet.$.FIRST_$PERFORMER
            --> am.englet.$.METHOD_PERFORMER
            --> am.englet.$.access$0()
            --> am.englet.$.access$1()
            --> am.englet.$.access$2()
            --> am.englet.$.access$3()
            --> am.englet.$.class$10
            --> am.englet.$.class$11
            --> am.englet.$.class$12
            --> am.englet.$.class$9
            <-- am.englet.$.static {}
            --> java.lang.Boolean.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.Void.TYPE *
            --> java.util.HashMap.HashMap() *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.$$5.$$5()
        serialVersionUID
    $$6
        --> am.englet.$
        $$6(java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> am.englet.$$6.cls *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
        cls *
            <-- am.englet.$$6.check(java.lang.reflect.Method)
        method(int, int, java.lang.Class[]) *
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
    $$7
        --> java.lang.Object *
        --> java.util.Comparator *
        $$7()
            <-- am.englet.$.classComparator()
            --> java.lang.Object.Object() *
        compare(java.lang.Object, java.lang.Object)
            --> am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
    $$Declared
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.declared
        --> am.englet.$Base
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        $$Declared(am.englet.$)
            --> am.englet.$
            --> am.englet.$$Declared.this$0
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            --> am.englet.$Base.$Base()
        $() *
            <-- am.englet.LoopTest.test1()
        $(int, int) *
            <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        $(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            --> am.englet.$$$Performer
            --> am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Declared.this$0
            --> am.englet.$.$performer
            --> am.englet.$.access$4(am.englet.$)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
        field(int, int, java.lang.String[]) *
            <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        method() *
            <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        this$0
            --> am.englet.$
            <-- am.englet.$$Declared.$$Declared(am.englet.$)
            <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
    $$First$Performer
        --> am.englet.$$$Performer
        --> java.lang.Object *
        $$First$Performer()
            <-- am.englet.$.static {}
            --> java.lang.Object.Object() *
        $(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            --> am.englet.$$Performer
            --> am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.performer
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    $$MethodPerformer
        --> am.englet.$$Performer
        $$MethodPerformer()
            --> am.englet.$$Performer.$$Performer()
            <-- am.englet.$.static {}
        declaredMembers(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getDeclaredMethods() *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.check(java.lang.reflect.Method)
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Method, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        doEach(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            --> am.englet.$.each(java.lang.reflect.Method)
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        members(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        paramTypes(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
    $$Performer
        <-- am.englet.$$1
        <-- am.englet.$$2
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$MethodPerformer
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.CONSTRUCTOR_PERFORMER
        <-- am.englet.$.FIELD_PERFORMER
        <-- am.englet.$.METHOD_PERFORMER
        <-- am.englet.$.access$0()
        <-- am.englet.$.access$1()
        <-- am.englet.$.declaredMembers()
        <-- am.englet.$.members()
        <-- am.englet.$.performer
        <-- am.englet.$.static {}
        --> java.lang.Object *
        $$Performer()
            <-- am.englet.$$1.$$1()
            <-- am.englet.$$2.$$2()
            <-- am.englet.$$MethodPerformer.$$MethodPerformer()
            --> java.lang.Object.Object() *
        declaredMembers(java.lang.Class)
            <-- am.englet.$.declaredMembers()
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> am.englet.$
            <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Object *
            --> java.lang.reflect.Member *
        doEach(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$
            <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.reflect.Member *
        first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Performer.doCheck(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Member *
        loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Performer.doEach(am.englet.$, java.lang.reflect.Member)
            --> am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Member *
        members(java.lang.Class)
            <-- am.englet.$.members()
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        nameFits(java.lang.String[], java.lang.String)
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
        paramTypes(java.lang.reflect.Member)
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> am.englet.$
            <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Performer.nameFits(java.lang.String[], java.lang.String)
            --> am.englet.$$Performer.paramTypes(java.lang.reflect.Member)
            <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$.class$13
            --> am.englet.$.cls
            --> am.englet.$.paramTypesEqual(java.lang.Class[], java.lang.Class[])
            --> am.englet.$.paramTypesFit(java.lang.Class[], java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getModifiers() *
            --> java.lang.reflect.Member.getName() *
        summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$
            <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$$Performer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
            --> am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    $Base
        <-- am.englet.$
        <-- am.englet.$$Declared
        --> java.lang.Object *
        $()
            --> am.englet.$Base.$(java.lang.Object, java.lang.Class[])
            <-- am.englet.$Base.constructor()
            <-- am.englet.$Base.field()
            <-- am.englet.$Base.method()
            --> java.lang.Class *
            --> java.lang.Object *
        $(int, int)
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.constructor(int, int)
            <-- am.englet.$Base.field(int, int)
            <-- am.englet.$Base.method(int, int)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(int, int, java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.constructor(int, int, java.lang.Class[])
            <-- am.englet.$Base.field(int, int, java.lang.Class)
            <-- am.englet.$Base.method(int, int, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.field(int, int, java.lang.Class, java.lang.String[])
            <-- am.englet.$Base.method(int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(int, int, java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.field(int, int, java.lang.String[])
            <-- am.englet.$Base.method(int, int, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Object, java.lang.Class[])
            <-- am.englet.$Base.constructor(java.lang.Class[])
            <-- am.englet.$Base.field(java.lang.Class)
            <-- am.englet.$Base.method(java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
        $(java.lang.Class[], java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.field(java.lang.Class, java.lang.String[])
            <-- am.englet.$Base.method(java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object)
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, int, int)
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, int, int, java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.$(int, int)
            <-- am.englet.$Base.$(int, int, java.lang.Class[])
            <-- am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.$(int, int, java.lang.String[])
            <-- am.englet.$Base.$(java.lang.Object)
            <-- am.englet.$Base.$(java.lang.Object, int, int)
            <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[])
            <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.String[])
            <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[])
            <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.$(java.lang.Object, java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, int, int, java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, java.lang.Class[])
            <-- am.englet.$Base.$()
            <-- am.englet.$Base.$(java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.$(java.lang.Class[], java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.$(java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.Object, java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $(java.lang.String[])
            --> am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
            <-- am.englet.$Base.field(java.lang.String[])
            <-- am.englet.$Base.method(java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        $Base()
            <-- am.englet.$$Declared.$$Declared(am.englet.$)
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            --> java.lang.Object.Object() *
        constructor()
            --> am.englet.$Base.$()
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        constructor(int, int)
            --> am.englet.$Base.$(int, int)
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        constructor(int, int, java.lang.Class[])
            --> am.englet.$Base.$(int, int, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        constructor(java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        field()
            --> am.englet.$Base.$()
            --> java.lang.Object *
            --> java.lang.reflect.Field *
        field(int, int)
            --> am.englet.$Base.$(int, int)
            --> java.lang.Object *
            --> java.lang.reflect.Field *
        field(int, int, java.lang.Class)
            --> am.englet.$Base.$(int, int, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
        field(int, int, java.lang.Class, java.lang.String[])
            --> am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
        field(int, int, java.lang.String[])
            --> am.englet.$Base.$(int, int, java.lang.String[])
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
        field(java.lang.Class)
            --> am.englet.$Base.$(java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
        field(java.lang.Class, java.lang.String[])
            --> am.englet.$Base.$(java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
        field(java.lang.String[])
            --> am.englet.$Base.$(java.lang.String[])
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
        method()
            --> am.englet.$Base.$()
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        method(int, int)
            --> am.englet.$Base.$(int, int)
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        method(int, int, java.lang.Class[])
            --> am.englet.$Base.$(int, int, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        method(int, int, java.lang.Class[], java.lang.String[])
            --> am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        method(int, int, java.lang.String[])
            --> am.englet.$Base.$(int, int, java.lang.String[])
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        method(java.lang.Class[])
            --> am.englet.$Base.$(java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        method(java.lang.Class[], java.lang.String[])
            --> am.englet.$Base.$(java.lang.Class[], java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        method(java.lang.String[])
            --> am.englet.$Base.$(java.lang.String[])
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
    ArgumentProvider
        <-- am.englet.Englet
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
        --> am.englet.ServiceObject
        --> java.lang.Object *
        getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> java.lang.Class *
        getCastingContext()
            --> am.englet.CastingContext
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            --> java.lang.Class *
        setCastingContext(am.englet.CastingContext)
            --> am.englet.CastingContext
    ArgumentProvider$ArgumentsAndTarget
        <-- am.englet.ArgumentProvider.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.Englet$1
        <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        --> java.lang.Object *
        arguments()
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> java.lang.Object *
        clean()
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        target()
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> java.lang.Object *
    CallStackSliderImpl
        <-- am.englet.CommandSource
        <-- am.englet.MultiplySliderImpl
        --> am.englet.link.backadapters.slider.AppendableCallStackSlider
        --> java.lang.Object *
        CallStackSliderImpl()
            --> am.englet.CallStackSliderImpl.stack
            <-- am.englet.CommandSource.CommandSource()
            <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            --> java.lang.Object.Object() *
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
        append(am.englet.link.Link, int)
            --> am.englet.CallStackSliderImpl.at(int)
            --> am.englet.CallStackSliderImpl.ensureStarted()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableSlider
            --> am.englet.link.backadapters.slider.AppendableSlider.append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
        append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.CallStackSliderImpl.ensureStarted()
            --> am.englet.CallStackSliderImpl.stack
            --> am.englet.link.backadapters.slider.AppendableSlider
            --> am.englet.link.backadapters.slider.AppendableSlider.append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
        at(int)
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
            <-- am.englet.CallStackSliderImpl.current(int)
            <-- am.englet.CallStackSliderImpl.go(am.englet.link.Link, int)
            --> am.englet.CallStackSliderImpl.realIndex(int)
            --> am.englet.CallStackSliderImpl.stack
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
        content()
            --> am.englet.CallStackSliderImpl.peek()
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider.content() *
            --> java.lang.Object *
        current(int)
            --> am.englet.CallStackSliderImpl.at(int)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider.back()
        drop(int)
            --> am.englet.CallStackSliderImpl.realIndex(int)
            --> am.englet.CallStackSliderImpl.stack
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
        ensureStarted()
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.CallStackSliderImpl.stack
            --> am.englet.CallStackSliderImpl.start(am.englet.link.Link)
            --> am.englet.link.Link
            --> java.util.Stack *
            --> java.util.Stack.size() *
        getStack()
            --> am.englet.CallStackSliderImpl.stack
            --> java.util.Stack *
        go(am.englet.link.Link, int)
            --> am.englet.CallStackSliderImpl.at(int)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider.go(am.englet.link.Link)
        peek()
            <-- am.englet.CallStackSliderImpl.content()
            --> am.englet.CallStackSliderImpl.stack
            <-- am.englet.CallStackSliderImpl.tryNext()
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.peek() *
        realIndex(int)
            <-- am.englet.CallStackSliderImpl.at(int)
            <-- am.englet.CallStackSliderImpl.drop(int)
            --> am.englet.CallStackSliderImpl.stack
            --> java.util.Stack *
            --> java.util.Stack.size() *
        stack
            <-- am.englet.CallStackSliderImpl.CallStackSliderImpl()
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.CallStackSliderImpl.at(int)
            <-- am.englet.CallStackSliderImpl.drop(int)
            <-- am.englet.CallStackSliderImpl.ensureStarted()
            <-- am.englet.CallStackSliderImpl.getStack()
            <-- am.englet.CallStackSliderImpl.peek()
            <-- am.englet.CallStackSliderImpl.realIndex(int)
            <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
            <-- am.englet.CallStackSliderImpl.tryNext()
            --> java.util.Stack *
        start(am.englet.link.Link)
            <-- am.englet.CallStackSliderImpl.ensureStarted()
            --> am.englet.CallStackSliderImpl.stack
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
        tryNext()
            --> am.englet.CallStackSliderImpl.peek()
            --> am.englet.CallStackSliderImpl.stack
            <-- am.englet.MultiplySliderImpl.tryNext()
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider
            --> am.englet.link.backadapters.slider.CallStacklLevelSlider.tryNext() *
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.pop() *
            --> java.util.Stack.size() *
    CastingContext
        <-- am.englet.ArgumentProvider.getCastingContext()
        <-- am.englet.ArgumentProvider.setCastingContext(am.englet.CastingContext)
        <-- am.englet.CastingContextImpl1
        <-- am.englet.CompoundInvokable$1
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.cctx
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.Englet.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.Englet.getCastingContext()
        <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        --> am.englet.ServiceObject
        <-- am.englet.SimpleCastingContext
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        --> java.lang.Object *
        canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        cast(java.lang.Class, java.lang.Object)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.Englet.cast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
    CastingContextImpl1
        --> am.englet.CastingContext
        --> am.englet.cast.CasterBankCasterProvider
        --> java.lang.Object *
        CastingContextImpl1()
            --> am.englet.CastingContextImpl1.bank
            --> am.englet.CastingContextImpl1.class$0
            --> am.englet.CastingContextImpl1.class$1
            --> am.englet.CastingContextImpl1.class$2
            --> am.englet.CastingContextImpl1.finder
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.CastingContextImpl1.sameProv
            --> am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterBankCasterProvider
            --> am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.add(am.englet.cast.CasterProvider)
            --> am.englet.cast.CasterProvidersPool.CasterProvidersPool()
            --> am.englet.cast.ClassCastChainFinder
            --> am.englet.cast.ConstructorBasedCasterProvider.ConstructorBasedCasterProvider()
            --> am.englet.cast.SameObjectCasterProvider
            --> am.englet.cast.SameObjectCasterProvider.SameObjectCasterProvider()
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.StaticFactoryMethodBasedCasterProvider()
            --> am.englet.cast.TargetToSourseClassCastChainFinder.TargetToSourseClassCastChainFinder()
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        add(am.englet.cast.Caster)
            <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
            --> am.englet.CastingContextImpl1.bank
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterBankCasterProvider
            --> am.englet.cast.CasterBankCasterProvider.add(am.englet.cast.Caster) *
        addTypeSubst(java.lang.Class, java.lang.Class)
            --> am.englet.CastingContextImpl1.add(am.englet.cast.Caster)
            --> am.englet.CastingContextImpl1.sameProv
            --> am.englet.cast.Caster
            --> am.englet.cast.SameObjectCasterProvider
            --> am.englet.cast.SameObjectCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        bank
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.CastingContextImpl1.add(am.englet.cast.Caster)
            --> am.englet.cast.CasterBankCasterProvider
        canCast(java.lang.Class, java.lang.Class)
            --> am.englet.CastingContextImpl1.finder
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.ClassCastChainFinder
            --> am.englet.cast.ClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> java.lang.Class *
        cast(java.lang.Class, java.lang.Object)
            --> am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.cast(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
        class$0
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> java.lang.Class *
        class$1
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> java.lang.Class *
        class$2
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> java.lang.Class *
        findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
            --> am.englet.CastingContextImpl1.finder
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.CastException.CastException(java.lang.String)
            --> am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.ClassCastChainFinder
            --> am.englet.cast.ClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        finder
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            --> am.englet.cast.ClassCastChainFinder
        getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.getImplementor(java.lang.Class, java.lang.Class) *
            --> java.lang.Class *
        lookUpBySource(java.lang.Class)
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.lookUpBySource(java.lang.Class) *
            --> java.lang.Class *
        lookUpByTarget(java.lang.Class)
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.lookUpByTarget(java.lang.Class) *
            --> java.lang.Class *
        provPool
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.lookUpBySource(java.lang.Class)
            <-- am.englet.CastingContextImpl1.lookUpByTarget(java.lang.Class)
            <-- am.englet.CastingContextImpl1.wrapToImplementor(java.lang.Object)
            --> am.englet.cast.CasterProvidersBank
        sameProv
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
            --> am.englet.cast.SameObjectCasterProvider
        wrapToImplementor(java.lang.Object)
            --> am.englet.CastingContextImpl1.provPool
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.wrapToImplementor(java.lang.Object) *
            --> java.lang.Object *
    CodeBlock
        <-- am.englet.CompoundInvokable$2
        <-- am.englet.Lookup$1
        <-- am.englet.Lookup$7
        <-- am.englet.Lookup$9
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Utils$1
        <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.dispatch.Utils$1
        <-- am.englet.dispatch.Utils$2
        <-- am.englet.dispatch.Utils$3
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        --> java.lang.Object *
        CodeBlock()
            <-- am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
            <-- am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
            <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            <-- am.englet.dispatch.Utils$1.Utils$1(java.lang.Class[])
            <-- am.englet.dispatch.Utils$2.Utils$2(int, java.lang.Class[])
            <-- am.englet.dispatch.Utils$3.Utils$3(java.lang.Class[])
            --> java.lang.Object.Object() *
        result()
            <-- am.englet.CodeBlock.toString()
            <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            --> java.lang.Object *
        toString()
            --> am.englet.CodeBlock.result()
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
    CommandSource
        --> am.englet.CallStackSliderImpl
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.getRstack()
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
        <-- am.englet.Management$8.content()
        <-- am.englet.Management$8.val$cs
        <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.append(am.englet.link.Link, int, am.englet.CommandSource)
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.direct(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
        <-- am.englet.Management.go(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.goFakeLing(am.englet.CommandSource, am.englet.link.Link)
        <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link)
        <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link, int)
        <-- am.englet.Management.ngo(am.englet.link.Link, int, am.englet.CommandSource)
        <-- am.englet.Management.ntrec(int, am.englet.CommandSource)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.start(am.englet.Englet)
        <-- am.englet.Management.start(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startDirect(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
        <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        --> am.englet.ServiceObject
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0.timesd(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        CommandSource()
            --> am.englet.CallStackSliderImpl.CallStackSliderImpl()
        append(am.englet.link.Link, int) *
            <-- am.englet.Management.append(am.englet.link.Link, int, am.englet.CommandSource)
        content() *
            <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        current(int) *
            <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
            <-- am.englet.Management.ntrec(int, am.englet.CommandSource)
        getStack() *
            <-- am.englet.CommandSource.toString()
        go(am.englet.link.Link, int) *
            <-- am.englet.Management$8.content()
            <-- am.englet.Management.go(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link, int)
            <-- am.englet.Management.ngo(am.englet.link.Link, int, am.englet.CommandSource)
            <-- am.englet.Management.ntrec(int, am.englet.CommandSource)
        start(am.englet.link.Link) *
            <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
            <-- am.englet.Management.start(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startDirect(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        toString()
            --> am.englet.CommandSource.getStack() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Stack *
        tryNext() *
            <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
    CompoundInvokable
        --> am.englet.Invokable
        <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        --> java.io.Serializable *
        --> java.lang.Object *
        CompoundInvokable()
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> java.lang.Object.Object() *
        create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable$CreationContext
            --> am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            --> am.englet.CompoundInvokable$CreationContext.argClasses
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable.CompoundInvokable()
            --> am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.CompoundInvokable.main
            --> am.englet.CompoundInvokable.parameterTypes
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription.prepare()
            <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.toArray(java.lang.Object[]) *
        create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription.getInvokable()
            --> am.englet.InvokableDescription.getMultiKey()
            --> am.englet.InvokableDescription.getSources()
            --> am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.lang.Class *
            --> java.lang.Integer *
            --> java.lang.Object *
        createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext
            --> am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
            --> am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapperArgSource.CompoundInvokable$InvokableWrapperArgSource(am.englet.CompoundInvokable$InvokableWrapper)
            --> am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
            --> am.englet.InvokableDescription
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.CompoundInvokable$InvocationData
            --> am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable.main
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        main
            --> am.englet.CompoundInvokable$InvokableWrapper
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.CompoundInvokable.returnType()
            <-- am.englet.CompoundInvokable.toString()
        parameterTypes
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.parameterTypes()
            <-- am.englet.CompoundInvokable.toString()
            --> java.lang.Class *
        parameterTypes()
            --> am.englet.CompoundInvokable.parameterTypes
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
        prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext
            --> am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
            --> am.englet.CompoundInvokable$DirectArgSource.CompoundInvokable$DirectArgSource(am.englet.MethodsStorage$Direct)
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.InvokableDescription
            --> am.englet.MethodsStorage$Direct
            --> java.lang.Class *
            --> java.lang.Object *
        returnType()
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapper.invokable
            --> am.englet.CompoundInvokable.main
            --> am.englet.Invokable
            --> am.englet.Invokable.returnType()
            --> java.lang.Class *
        serialVersionUID
        targetType()
            --> java.lang.Class *
        toString()
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable.main
            --> am.englet.CompoundInvokable.parameterTypes
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.insert(int, char) *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    CompoundInvokable$1
        --> am.englet.CastingContext
        --> java.lang.Object *
        CompoundInvokable$1(am.englet.CompoundInvokable$InvokableWrapper)
            --> am.englet.CompoundInvokable$1.this$1
            --> am.englet.CompoundInvokable$InvokableWrapper
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            --> java.lang.Object.Object() *
        canCast(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        cast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
        this$1
            <-- am.englet.CompoundInvokable$1.CompoundInvokable$1(am.englet.CompoundInvokable$InvokableWrapper)
            --> am.englet.CompoundInvokable$InvokableWrapper
    CompoundInvokable$2
        --> am.englet.CodeBlock
        CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.CompoundInvokable$2.this$1
            --> am.englet.CompoundInvokable$2.val$args
            --> am.englet.CompoundInvokable$InvokableWrapper
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> java.lang.Object *
        result()
            --> am.englet.CompoundInvokable$2.val$args
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        this$1
            <-- am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
            --> am.englet.CompoundInvokable$InvokableWrapper
        val$args
            <-- am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
            <-- am.englet.CompoundInvokable$2.result()
            --> java.lang.Object *
    CompoundInvokable$ArgArrayArgSource
        --> am.englet.CompoundInvokable$ArgumentSource
        --> java.lang.Object *
        CompoundInvokable$ArgArrayArgSource(int)
            --> am.englet.CompoundInvokable$ArgArrayArgSource.l
            <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
            --> java.lang.Object.Object() *
        getData(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$ArgArrayArgSource.l
            --> am.englet.CompoundInvokable$InvocationData
            --> am.englet.CompoundInvokable$InvocationData.args
            --> java.lang.Object *
        l
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.CompoundInvokable$ArgArrayArgSource(int)
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
        serialVersionUID
        toString()
            --> am.englet.CompoundInvokable$ArgArrayArgSource.l
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    CompoundInvokable$ArgumentSource
        <-- am.englet.CompoundInvokable$ArgArrayArgSource
        <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
        <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
        <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
        <-- am.englet.CompoundInvokable$DirectArgSource
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.sources
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        --> java.io.Serializable *
        --> java.lang.Object *
        getData(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$InvocationData
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
    CompoundInvokable$CreationContext
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        --> java.lang.Object *
        CompoundInvokable$CreationContext()
            --> am.englet.CompoundInvokable$CreationContext.argClasses
            --> am.englet.CompoundInvokable$CreationContext.visited
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> java.lang.Object.Object() *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.HashMap.HashMap() *
            --> java.util.List *
            --> java.util.Map *
        argClasses
            <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> java.util.List *
        forClass(java.lang.Class)
            --> am.englet.CompoundInvokable$ArgArrayArgSource.CompoundInvokable$ArgArrayArgSource(int)
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext.argClasses
            <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.size() *
        visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext.visited
            <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.InvokableDescription
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        visited
            <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
            <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
            --> java.util.Map *
        visited(am.englet.InvokableDescription)
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$CreationContext.visited
            <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.InvokableDescription
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
    CompoundInvokable$DirectArgSource
        --> am.englet.CompoundInvokable$ArgumentSource
        --> java.lang.Object *
        CompoundInvokable$DirectArgSource(am.englet.MethodsStorage$Direct)
            --> am.englet.CompoundInvokable$DirectArgSource.d
            <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
            --> am.englet.MethodsStorage$Direct
            --> java.lang.Object.Object() *
        d
            <-- am.englet.CompoundInvokable$DirectArgSource.CompoundInvokable$DirectArgSource(am.englet.MethodsStorage$Direct)
            <-- am.englet.CompoundInvokable$DirectArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$DirectArgSource.toString()
            --> am.englet.MethodsStorage$Direct
        getData(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$DirectArgSource.d
            --> am.englet.CompoundInvokable$InvocationData
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.getContent()
            --> java.lang.Object *
        serialVersionUID
        toString()
            --> am.englet.CompoundInvokable$DirectArgSource.d
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.toString()
            --> java.lang.String *
    CompoundInvokable$InvocationData
        <-- am.englet.CompoundInvokable$ArgArrayArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$DirectArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        --> java.lang.Object *
        CompoundInvokable$InvocationData(java.lang.Object[])
            --> am.englet.CompoundInvokable$InvocationData.args
            --> am.englet.CompoundInvokable$InvocationData.worked
            <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        args
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            --> java.lang.Object *
        worked
            <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> java.util.Map *
    CompoundInvokable$InvokableWrapper
        <-- am.englet.CompoundInvokable$1.CompoundInvokable$1(am.englet.CompoundInvokable$InvokableWrapper)
        <-- am.englet.CompoundInvokable$1.this$1
        <-- am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
        <-- am.englet.CompoundInvokable$2.this$1
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.CompoundInvokable$InvokableWrapperArgSource(am.englet.CompoundInvokable$InvokableWrapper)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.w
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.CompoundInvokable.main
        <-- am.englet.CompoundInvokable.returnType()
        <-- am.englet.CompoundInvokable.toString()
        --> java.io.Serializable *
        --> java.lang.Object *
        CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable$1.CompoundInvokable$1(am.englet.CompoundInvokable$InvokableWrapper)
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$InvokableWrapper.argCount
            --> am.englet.CompoundInvokable$InvokableWrapper.argTypes
            --> am.englet.CompoundInvokable$InvokableWrapper.cctx
            --> am.englet.CompoundInvokable$InvokableWrapper.invokable
            --> am.englet.CompoundInvokable$InvokableWrapper.multiKey
            --> am.englet.CompoundInvokable$InvokableWrapper.sources
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Utils.copy(java.lang.Object[])
            --> am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Integer *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        argCount
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        argTypes
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> java.lang.Class *
        cctx
            --> am.englet.CastingContext
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        invokable
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.returnType()
            --> am.englet.Invokable
        invoke(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CastingContext
            --> am.englet.CastingContext.cast(java.lang.Class, java.lang.Object)
            --> am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$InvocationData
            --> am.englet.CompoundInvokable$InvocationData.worked
            --> am.englet.CompoundInvokable$InvokableWrapper.argCount
            --> am.englet.CompoundInvokable$InvokableWrapper.argTypes
            --> am.englet.CompoundInvokable$InvokableWrapper.cctx
            --> am.englet.CompoundInvokable$InvokableWrapper.invokable
            --> am.englet.CompoundInvokable$InvokableWrapper.multiKey
            --> am.englet.CompoundInvokable$InvokableWrapper.sources
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Integer *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.System.out *
            --> java.lang.reflect.InvocationTargetException *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        multiKey
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            --> java.lang.Integer *
        serialVersionUID
        sources
            --> am.englet.CompoundInvokable$ArgumentSource
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        toString()
            --> am.englet.CompoundInvokable$ArgumentSource
            --> am.englet.CompoundInvokable$InvokableWrapper.invokable
            --> am.englet.CompoundInvokable$InvokableWrapper.multiKey
            --> am.englet.CompoundInvokable$InvokableWrapper.sources
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.toString()
            --> am.englet.Invokable
            --> java.lang.Integer *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    CompoundInvokable$InvokableWrapperArgSource
        --> am.englet.CompoundInvokable$ArgumentSource
        --> java.lang.Object *
        CompoundInvokable$InvokableWrapperArgSource(am.englet.CompoundInvokable$InvokableWrapper)
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapperArgSource.w
            <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> java.lang.Object.Object() *
        getData(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$InvocationData
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.CompoundInvokable$InvokableWrapperArgSource.w
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        serialVersionUID
        toString()
            --> am.englet.CompoundInvokable$InvokableWrapper
            --> am.englet.CompoundInvokable$InvokableWrapper.toString()
            --> am.englet.CompoundInvokable$InvokableWrapperArgSource.w
            --> java.lang.String *
        w
            --> am.englet.CompoundInvokable$InvokableWrapper
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.CompoundInvokable$InvokableWrapperArgSource(am.englet.CompoundInvokable$InvokableWrapper)
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.toString()
    ConditionalValueConverter
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            --> am.englet.ConditionalValueConverter.condStatic
            --> am.englet.ConditionalValueConverter.condition
            --> am.englet.ConditionalValueConverter.convStatic
            --> am.englet.ConditionalValueConverter.converter
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        condStatic
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        condition
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
            --> am.englet.Invokable
        convStatic
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        convert(java.lang.Object)
            --> am.englet.ConditionalValueConverter.condStatic
            --> am.englet.ConditionalValueConverter.condition
            --> am.englet.ConditionalValueConverter.convStatic
            --> am.englet.ConditionalValueConverter.converter
            --> am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
            --> am.englet.Invokable
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.Throwable *
        converter
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
            --> am.englet.Invokable
        invoke(java.lang.Object, am.englet.Invokable, boolean)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        serialVersionUID
    Const
        --> java.lang.Object *
        Const()
            --> java.lang.Object.Object() *
        NO_RESULT
            <-- am.englet.Const.static {}
            <-- am.englet.Management$8.content()
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> java.lang.Object *
        static {}
            --> am.englet.Const$1.Const$1()
            --> am.englet.Const.NO_RESULT
            --> java.lang.Object *
    Const$1
        --> java.lang.Object *
        Const$1()
            <-- am.englet.Const.static {}
            --> java.lang.Object.Object() *
    ConstructorInvokable
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        --> am.englet.reflect.MemberInvokable
        ConstructorInvokable(java.lang.reflect.Constructor)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        deprimitivise(java.lang.Class[]) *
            <-- am.englet.ConstructorInvokable.parameterTypes(java.lang.reflect.Member)
        invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
        name(java.lang.reflect.Member)
            --> java.lang.String *
            --> java.lang.reflect.Member *
        parameterTypes(java.lang.reflect.Member)
            --> am.englet.ConstructorInvokable.deprimitivise(java.lang.Class[]) *
            --> java.lang.Class *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
            --> java.lang.reflect.Member *
        returnType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getDeclaringClass() *
            --> java.lang.reflect.Member *
        serialVersionUID
        targetType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        type()
            --> java.lang.String *
    DataStack
        <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
        <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack, am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack$StackFrame.basedInstance()
        <-- am.englet.DataStack$StackFrame.this$0
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.getArgument()
        <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.Englet.getNNextArgumentTypes(int)
        <-- am.englet.Englet.getStack()
        <-- am.englet.Englet.handleResult(java.lang.Object)
        <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.chain(am.englet.DataStack)
        <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.popContent(am.englet.DataStack)
        <-- am.englet.Immediate.popContentObject(am.englet.DataStack)
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.array(am.englet.DataStack)
        <-- am.englet.Management.atX(am.englet.DataStack, int)
        <-- am.englet.Management.atXX(am.englet.DataStack, int, int)
        <-- am.englet.Management.chain(int, am.englet.DataStack)
        <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        <-- am.englet.Management.debug(am.englet.DataStack, boolean)
        <-- am.englet.Management.debug(am.englet.DataStack, int)
        <-- am.englet.Management.debug2(am.englet.DataStack, boolean)
        <-- am.englet.Management.debug2(am.englet.DataStack, int)
        <-- am.englet.Management.deframe(am.englet.DataStack)
        <-- am.englet.Management.drop(am.englet.DataStack)
        <-- am.englet.Management.dropAll(am.englet.DataStack)
        <-- am.englet.Management.dup(am.englet.DataStack)
        <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
        <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.excl(java.util.Map, am.englet.DataStack)
        <-- am.englet.Management.fake(am.englet.DataStack, boolean)
        <-- am.englet.Management.fake(am.englet.DataStack, int)
        <-- am.englet.Management.filter(am.englet.DataStack, am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Management.frame(am.englet.DataStack)
        <-- am.englet.Management.frame(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.Management.lastT(am.englet.DataStack)
        <-- am.englet.Management.lastU(am.englet.DataStack)
        <-- am.englet.Management.lastV(am.englet.DataStack)
        <-- am.englet.Management.lastW(am.englet.DataStack)
        <-- am.englet.Management.lastX(am.englet.DataStack)
        <-- am.englet.Management.lastY(am.englet.DataStack)
        <-- am.englet.Management.lastZ(am.englet.DataStack)
        <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
        <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
        <-- am.englet.Management.param(am.englet.DataStack)
        <-- am.englet.Management.param1(am.englet.DataStack)
        <-- am.englet.Management.param1(am.englet.DataStack, int)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.printstack(am.englet.DataStack)
        <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
        <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.res(am.englet.DataStack, int)
        <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
        <-- am.englet.Management.start(am.englet.Englet)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
        <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        <-- am.englet.Management.sub(am.englet.DataStack, int)
        <-- am.englet.Management.top(am.englet.DataStack)
        <-- am.englet.Management.trace(am.englet.DataStack, boolean)
        <-- am.englet.Management.trace(am.englet.DataStack, int)
        <-- am.englet.Management.yOut(java.lang.Object, java.lang.Object, am.englet.DataStack)
        <-- am.englet.Processing.gotted(am.englet.link.Link, am.englet.DataStack)
        --> am.englet.ServiceObject
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.Utils$7.Utils$7(am.englet.DataStack)
        <-- am.englet.Utils$7.convert(java.lang.Object)
        <-- am.englet.Utils$7.val$ds
        <-- am.englet.Utils$8.Utils$8(am.englet.DataStack)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils$8.val$ds
        <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        --> am.englet.VariablesStorage
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        --> java.lang.Object *
        DEBUG
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.static {}
            <-- am.englet.Management.debug2(am.englet.DataStack, boolean)
            <-- am.englet.Management.debug2(am.englet.DataStack, int)
        DataStack()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.fp
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.last
            --> am.englet.DataStack.main
            --> am.englet.DataStack.popResetMark
            <-- am.englet.Englet.Englet()
            --> java.lang.Object.Object() *
            --> java.util.ArrayList *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
        DataStack(am.englet.DataStack$StackFrame)
            --> am.englet.DataStack$StackFrame
            <-- am.englet.DataStack.derive()
            --> am.englet.DataStack.fp
            --> am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
            --> am.englet.DataStack.last
            --> am.englet.DataStack.main
            --> am.englet.DataStack.popResetMark
            --> java.lang.Object.Object() *
            --> java.util.ArrayList *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
        at(int)
            --> am.englet.DataStack.stack()
            <-- am.englet.Management.atX(am.englet.DataStack, int)
            --> am.englet.Utils.atStack(java.util.List, int)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.Stack *
        at(int, int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.main
            <-- am.englet.Management.atXX(am.englet.DataStack, int, int)
            <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
            --> am.englet.Utils.atStack(java.util.List, int)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.Stack *
        class$0
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            --> java.lang.Class *
        class$1
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            --> java.lang.Class *
        class$2
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            --> java.lang.Class *
        class$3
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            --> java.lang.Class *
        class$4
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            --> java.lang.Class *
        clear()
            --> am.englet.DataStack.main
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            --> java.util.Stack *
            --> java.util.Stack.clear() *
        deframe()
            <-- am.englet.DataStack.deframeAll()
            --> am.englet.DataStack.doDeframe(int)
            --> am.englet.DataStack.main
            <-- am.englet.DataStack.peekResultList()
            <-- am.englet.Immediate.chain(am.englet.DataStack)
            <-- am.englet.Management.array(am.englet.DataStack)
            <-- am.englet.Management.deframe(am.englet.DataStack)
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            --> java.util.Stack *
            --> java.util.Stack.size() *
        deframeAll()
            --> am.englet.DataStack.deframe()
            --> am.englet.DataStack.size()
            <-- am.englet.Main.main(java.lang.String[])
        deframeTo(int)
            --> am.englet.DataStack.doDeframe(int)
            --> am.englet.DataStack.main
            --> java.util.Stack *
            --> java.util.Stack.size() *
        derive()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            --> am.englet.DataStack.top()
            <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        doDeframe(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.resCount
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack$StackFrame.shadow
            --> am.englet.DataStack$StackFrame.st
            <-- am.englet.DataStack.deframe()
            <-- am.englet.DataStack.deframeTo(int)
            --> am.englet.DataStack.main
            --> am.englet.DataStack.stack()
            --> am.englet.DataStack.top()
            --> java.lang.Math.max(int, int) *
            --> java.util.Collection *
            --> java.util.LinkedList *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.addAll(java.util.Collection) *
            --> java.util.Stack.setSize(int) *
            --> java.util.Stack.size() *
            --> java.util.Stack.subList(int, int) *
        enlist()
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.DataStack.stack()
            <-- am.englet.Immediate.chain(am.englet.DataStack)
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            --> java.lang.Object *
            --> java.util.ArrayList.ArrayList(java.util.Collection) *
            --> java.util.Collection *
            --> java.util.Collections.unmodifiableList(java.util.List) *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
        faking
            <-- am.englet.DataStack.isFaking()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.setFaking(boolean)
        fp
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.pSt()
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.popResetSelf()
        frame()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack, am.englet.DataStack$StackFrame)
            --> am.englet.DataStack$StackFrame.basedInstance()
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.frame(java.util.Map)
            --> am.englet.DataStack.main
            --> am.englet.DataStack.map()
            <-- am.englet.Immediate.frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.Management.frame(am.englet.DataStack)
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
            --> java.util.Stack.size() *
        frame(am.englet.DataStack$StackFrame)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.basedInstance()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            --> am.englet.DataStack.main
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
        frame(java.util.List)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.basedInstance()
            --> am.englet.DataStack$StackFrame.put(java.lang.Object, java.lang.Object) *
            --> am.englet.DataStack.main
            --> am.englet.DataStack.map()
            --> am.englet.DataStack.pop()
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.listIterator(int) *
            --> java.util.List.size() *
            --> java.util.ListIterator *
            --> java.util.ListIterator.hasPrevious() *
            --> java.util.ListIterator.previous() *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
        frame(java.util.Map)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.putAll(java.util.Map) *
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.top()
            <-- am.englet.Management.frame(am.englet.DataStack, java.util.Map)
            --> java.util.Map *
        get(java.lang.Object)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.getBased(java.lang.Object)
            --> am.englet.DataStack.top()
            <-- am.englet.Utils$7.convert(java.lang.Object)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            --> java.lang.Object *
        has(java.lang.Object)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.has(java.lang.Object)
            --> am.englet.DataStack.mustNotHave(java.lang.Object)
            --> am.englet.DataStack.top()
            --> java.lang.Object *
        isFaking()
            --> am.englet.DataStack.faking
            <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        last
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.last(int)
            <-- am.englet.DataStack.popReg(java.lang.Object)
            <-- am.englet.DataStack.popResetSelf()
            --> java.util.ArrayList *
        last(int)
            --> am.englet.DataStack.last
            <-- am.englet.Management.lastT(am.englet.DataStack)
            <-- am.englet.Management.lastU(am.englet.DataStack)
            <-- am.englet.Management.lastV(am.englet.DataStack)
            <-- am.englet.Management.lastW(am.englet.DataStack)
            <-- am.englet.Management.lastX(am.englet.DataStack)
            <-- am.englet.Management.lastY(am.englet.DataStack)
            <-- am.englet.Management.lastZ(am.englet.DataStack)
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.get(int) *
        main
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.at(int, int)
            <-- am.englet.DataStack.clear()
            <-- am.englet.DataStack.deframe()
            <-- am.englet.DataStack.deframeTo(int)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.frame(java.util.List)
            <-- am.englet.DataStack.map(int)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.popResetSelf()
            <-- am.englet.DataStack.size()
            <-- am.englet.DataStack.st2()
            <-- am.englet.DataStack.stack()
            <-- am.englet.DataStack.toString()
            <-- am.englet.DataStack.top()
            --> java.util.Stack *
        map()
            --> am.englet.DataStack$StackFrame
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.frame(java.util.List)
            <-- am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.DataStack.top()
        map(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.main
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.pSt()
            <-- am.englet.DataStack.pop()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
        mustNotHave(java.lang.Object)
            --> am.englet.DataStack.class$0
            --> am.englet.DataStack.class$1
            --> am.englet.DataStack.class$2
            --> am.englet.DataStack.class$3
            --> am.englet.DataStack.class$4
            <-- am.englet.DataStack.has(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        nTopArgumentTypes(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.DEBUG
            --> am.englet.DataStack.main
            --> am.englet.DataStack.map(int)
            --> am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
            <-- am.englet.Englet.getNNextArgumentTypes(int)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.size() *
        pSt()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.fp
            --> am.englet.DataStack.map(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.popResetSelf()
            --> java.util.Stack *
        param()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.put(java.lang.Object, java.lang.Object) *
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack$StackFrame.shadow(java.lang.Object)
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.st2()
            --> am.englet.DataStack.top()
            <-- am.englet.Management.param(am.englet.DataStack)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.pop() *
            --> java.util.Stack.size() *
        param(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
            --> am.englet.DataStack$StackFrame.shadow1reset()
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.main
            --> am.englet.DataStack.st2()
            --> am.englet.DataStack.top()
            <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
            <-- am.englet.Management.param(am.englet.DataStack)
            <-- am.englet.Management.param1(am.englet.DataStack, int)
            <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.push(java.lang.Object) *
            --> java.util.Stack.setSize(int) *
            --> java.util.Stack.size() *
        peek()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.peek()
            --> am.englet.DataStack.top()
            <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            --> java.lang.Object *
        peekResultList()
            --> am.englet.DataStack.deframe()
            --> am.englet.DataStack.stack()
            <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.util.List)
            --> java.util.List *
            --> java.util.Stack *
        peekResultList(int)
            --> am.englet.DataStack.stack()
            <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.util.List, int)
            --> java.util.List *
            --> java.util.Stack *
        pop()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.pop()
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.DEBUG
            --> am.englet.DataStack.fp
            <-- am.englet.DataStack.frame(java.util.List)
            --> am.englet.DataStack.map(int)
            --> am.englet.DataStack.pSt()
            --> am.englet.DataStack.popReg(java.lang.Object)
            --> am.englet.DataStack.popResetMark
            --> am.englet.DataStack.popResetSelf()
            --> am.englet.DataStack.sp
            --> am.englet.DataStack.top()
            <-- am.englet.Englet.getArgument()
            <-- am.englet.Immediate.chain(am.englet.DataStack)
            <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.Immediate.popContentObject(am.englet.DataStack)
            <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.Management.chain(int, am.englet.DataStack)
            <-- am.englet.Management.drop(am.englet.DataStack)
            <-- am.englet.Management.dup(am.englet.DataStack)
            <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            <-- am.englet.Management.start(am.englet.Englet)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.TestUtils0$10.tryNextContent()
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.util.EmptyStackException.EmptyStackException() *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.size() *
        popReg(java.lang.Object)
            --> am.englet.DataStack.last
            <-- am.englet.DataStack.pop()
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.add(java.lang.Object) *
        popReset()
            --> am.englet.DataStack.popResetMark
            <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        popResetMark
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.popReset()
            <-- am.englet.DataStack.popResetSelf()
        popResetSelf()
            --> am.englet.DataStack.fp
            --> am.englet.DataStack.last
            --> am.englet.DataStack.main
            --> am.englet.DataStack.pSt()
            <-- am.englet.DataStack.pop()
            --> am.englet.DataStack.popResetMark
            --> am.englet.DataStack.sp
            --> java.util.ArrayList *
            --> java.util.ArrayList.clear() *
            --> java.util.Stack *
            --> java.util.Stack.size() *
        push(java.lang.Object)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.push(java.lang.Object)
            <-- am.englet.DataStack.enlist()
            --> am.englet.DataStack.top()
            <-- am.englet.Englet.handleResult(java.lang.Object)
            <-- am.englet.Management.dup(am.englet.DataStack)
            <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
            <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
            <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
            <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            <-- am.englet.Management.yOut(java.lang.Object, java.lang.Object, am.englet.DataStack)
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> java.lang.Object *
        put(java.lang.Object, java.lang.Object)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.put(java.lang.Object, java.lang.Object) *
            --> am.englet.DataStack.map()
            <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
            --> java.lang.Object *
        putRes(java.lang.Class[], int, java.lang.Object)
            --> am.englet.DataStack.DEBUG
            --> am.englet.DataStack.class$2
            --> am.englet.DataStack.faking
            <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
            --> am.englet.Invokable
            --> am.englet.Invokable.returnType()
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription.getInvokable()
            --> am.englet.MethodsStorage$Cast
            --> am.englet.MethodsStorage$Cast.castClass
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.Throwable.getMessage() *
        putRes(java.util.Stack, java.lang.Class[], int)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            --> am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.size() *
        res(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.resCount
            --> am.englet.DataStack.top()
            <-- am.englet.Management.res(am.englet.DataStack, int)
        set(java.lang.Object, java.lang.Object)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.set(java.lang.Object, java.lang.Object)
            --> am.englet.DataStack.top()
            --> java.lang.Object *
        setFaking(boolean)
            --> am.englet.DataStack.faking
            <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
            <-- am.englet.Management.fake(am.englet.DataStack, boolean)
            <-- am.englet.Management.fake(am.englet.DataStack, int)
        size()
            <-- am.englet.DataStack.deframeAll()
            --> am.englet.DataStack.main
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> java.util.Stack *
            --> java.util.Stack.size() *
        sp
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.popResetSelf()
        st2()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.main
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.size() *
        stack()
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            <-- am.englet.DataStack.at(int)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.enlist()
            --> am.englet.DataStack.main
            <-- am.englet.DataStack.peekResultList()
            <-- am.englet.DataStack.peekResultList(int)
            <-- am.englet.Management.dropAll(am.englet.DataStack)
            <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
            <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.peek() *
        static {}
            --> am.englet.DataStack.DEBUG
        sub(int)
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.sub0(int)
            --> am.englet.DataStack.top()
            <-- am.englet.Management.sub(am.englet.DataStack, int)
            <-- am.englet.Processing.gotted(am.englet.link.Link, am.englet.DataStack)
            --> java.util.Map *
        toString()
            --> am.englet.DataStack.main
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Stack *
        top()
            --> am.englet.DataStack$StackFrame
            <-- am.englet.DataStack.derive()
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.frame(java.util.Map)
            <-- am.englet.DataStack.get(java.lang.Object)
            <-- am.englet.DataStack.has(java.lang.Object)
            --> am.englet.DataStack.main
            <-- am.englet.DataStack.map()
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.peek()
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.push(java.lang.Object)
            <-- am.englet.DataStack.res(int)
            <-- am.englet.DataStack.set(java.lang.Object, java.lang.Object)
            <-- am.englet.DataStack.sub(int)
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.array(am.englet.DataStack)
            <-- am.englet.Management.param(am.englet.DataStack)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
            <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.top(am.englet.DataStack)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.peek() *
    DataStack$StackFrame
        <-- am.englet.DataStack.DataStack()
        <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.at(int, int)
        <-- am.englet.DataStack.derive()
        <-- am.englet.DataStack.doDeframe(int)
        <-- am.englet.DataStack.frame()
        <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.frame(java.util.List)
        <-- am.englet.DataStack.frame(java.util.Map)
        <-- am.englet.DataStack.get(java.lang.Object)
        <-- am.englet.DataStack.has(java.lang.Object)
        <-- am.englet.DataStack.map()
        <-- am.englet.DataStack.map(int)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.pSt()
        <-- am.englet.DataStack.param()
        <-- am.englet.DataStack.param(int)
        <-- am.englet.DataStack.peek()
        <-- am.englet.DataStack.pop()
        <-- am.englet.DataStack.push(java.lang.Object)
        <-- am.englet.DataStack.put(java.lang.Object, java.lang.Object)
        <-- am.englet.DataStack.res(int)
        <-- am.englet.DataStack.set(java.lang.Object, java.lang.Object)
        <-- am.englet.DataStack.st2()
        <-- am.englet.DataStack.stack()
        <-- am.englet.DataStack.sub(int)
        <-- am.englet.DataStack.top()
        <-- am.englet.Immediate.frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.array(am.englet.DataStack)
        <-- am.englet.Management.frame(am.englet.DataStack)
        <-- am.englet.Management.param(am.englet.DataStack)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
        <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        <-- am.englet.Management.top(am.englet.DataStack)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        --> java.util.HashMap *
        DataStack$StackFrame(am.englet.DataStack)
            --> am.englet.DataStack
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack, am.englet.DataStack$StackFrame)
            --> am.englet.DataStack$StackFrame.base
            <-- am.englet.DataStack$StackFrame.basedInstance()
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack$StackFrame.resCount
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack$StackFrame.shadow
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack$StackFrame.this$0
            --> java.util.HashMap.HashMap() *
            --> java.util.LinkedList *
            --> java.util.LinkedList.LinkedList() *
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
        DataStack$StackFrame(am.englet.DataStack, am.englet.DataStack$StackFrame)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack.frame()
        base
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.basedInstance()
            <-- am.englet.DataStack$StackFrame.getBased(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.has(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.set(java.lang.Object, java.lang.Object)
            <-- am.englet.DataStack$StackFrame.sub0(int)
            <-- am.englet.DataStack$StackFrame.toString()
        basedInstance()
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            --> am.englet.DataStack$StackFrame.base
            --> am.englet.DataStack$StackFrame.size() *
            --> am.englet.DataStack$StackFrame.this$0
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.frame(java.util.List)
        containsKey(java.lang.Object) *
            <-- am.englet.DataStack$StackFrame.getBased(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.has(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.set(java.lang.Object, java.lang.Object)
        entrySet() *
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        get(java.lang.Object) *
            <-- am.englet.DataStack$StackFrame.getBased(java.lang.Object)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        getBased(java.lang.Object)
            --> am.englet.DataStack$StackFrame.base
            --> am.englet.DataStack$StackFrame.containsKey(java.lang.Object) *
            --> am.englet.DataStack$StackFrame.get(java.lang.Object) *
            <-- am.englet.DataStack.get(java.lang.Object)
            --> java.lang.Object *
        has(java.lang.Object)
            --> am.englet.DataStack$StackFrame.base
            --> am.englet.DataStack$StackFrame.containsKey(java.lang.Object) *
            <-- am.englet.DataStack.has(java.lang.Object)
            --> java.lang.Object *
        peek()
            --> am.englet.DataStack$StackFrame.st
            <-- am.englet.DataStack.peek()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.peek() *
        pop()
            --> am.englet.DataStack$StackFrame.st
            <-- am.englet.DataStack.pop()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.pop() *
        push(java.lang.Object)
            --> am.englet.DataStack$StackFrame.st
            <-- am.englet.DataStack.push(java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.ResultList.appendTo(java.util.List)
            --> am.englet.Utils.correctValue(java.lang.Object)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.DataStack$StackFrame.set(java.lang.Object, java.lang.Object)
            <-- am.englet.DataStack.frame(java.util.List)
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        putAll(java.util.Map) *
            <-- am.englet.DataStack.frame(java.util.Map)
        quiet
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
        remove(java.lang.Object) *
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        resCount
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.res(int)
        serialVersionUID
        set(java.lang.Object, java.lang.Object)
            --> am.englet.DataStack$StackFrame.base
            --> am.englet.DataStack$StackFrame.containsKey(java.lang.Object) *
            --> am.englet.DataStack$StackFrame.put(java.lang.Object, java.lang.Object) *
            <-- am.englet.DataStack.set(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
        shading
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.shadow(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        shadow
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.shadow(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.shadow1reset()
            <-- am.englet.DataStack.doDeframe(int)
            --> java.util.LinkedList *
        shadow(java.lang.Object)
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack$StackFrame.shadow
            <-- am.englet.DataStack.param()
            --> java.lang.Object *
            --> java.util.LinkedList *
            --> java.util.LinkedList.add(int, java.lang.Object) *
        shadow1(java.lang.Object)
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack$StackFrame.shitr
            <-- am.englet.DataStack.param(int)
            --> java.lang.Object *
            --> java.util.ListIterator *
            --> java.util.ListIterator.add(java.lang.Object) *
        shadow1reset()
            --> am.englet.DataStack$StackFrame.shadow
            --> am.englet.DataStack$StackFrame.shitr
            <-- am.englet.DataStack.param(int)
            --> java.util.LinkedList *
            --> java.util.LinkedList.listIterator() *
            --> java.util.ListIterator *
        shitr
            <-- am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.shadow1reset()
            --> java.util.ListIterator *
        size() *
            <-- am.englet.DataStack$StackFrame.basedInstance()
        st
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.peek()
            <-- am.englet.DataStack$StackFrame.pop()
            <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.DataStack.at(int, int)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.pSt()
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.st2()
            <-- am.englet.DataStack.stack()
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.array(am.englet.DataStack)
            <-- am.englet.Management.param(am.englet.DataStack)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.Management.top(am.englet.DataStack)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            --> java.util.Stack *
        sub0(int)
            --> am.englet.DataStack$StackFrame.base
            <-- am.englet.DataStack.sub(int)
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
            --> java.util.Map.putAll(java.util.Map) *
        this$0
            --> am.englet.DataStack
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.basedInstance()
        toString()
            --> am.englet.DataStack$StackFrame.base
            --> am.englet.DataStack$StackFrame.st
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.HashMap.toString() *
            --> java.util.Stack *
    Englet
        --> am.englet.ArgumentProvider
        <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
        <-- am.englet.Englet$1.this$0
        <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
        <-- am.englet.EngletBasedChecker.check(java.lang.Object)
        <-- am.englet.EngletBasedChecker.englet
        <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
        <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.EngletBasedValueConverter.englet
        <-- am.englet.EngletSettings.apply(am.englet.Englet)
        <-- am.englet.Main.englet
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Management.start(am.englet.Englet)
        --> am.englet.ResultHandler
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        --> am.englet.SingletonPool
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$10.englet
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$Performer.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$1(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        --> java.lang.Object *
        CLASSES
            <-- am.englet.Englet.getNNextArgumentTypes(int)
            <-- am.englet.Englet.static {}
            --> java.lang.Class *
        Englet()
            --> am.englet.DataStack
            --> am.englet.DataStack.DataStack()
            --> am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Englet.class$3
            --> am.englet.Englet.class$4
            --> am.englet.Englet.class$5
            --> am.englet.Englet.getMethods()
            --> am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.Main.main(java.lang.String[])
            --> am.englet.Management.adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Management.adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.MethodsStorage()
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.ClassPool()
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getName() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.DataStack
            <-- am.englet.Englet.Englet()
            --> am.englet.Englet.args
            --> am.englet.Englet.class$6
            --> am.englet.Englet.putSingleton(java.lang.Object)
            --> am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            --> am.englet.Englet.singletons
            <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Object[] *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
        args
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.cleanArgs(int)
            --> java.lang.Object *
        cast(java.lang.Class, java.lang.Object)
            --> am.englet.CastingContext
            --> am.englet.CastingContext.cast(java.lang.Class, java.lang.Object)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            --> am.englet.Englet.getCastingContext()
            --> java.lang.Class *
            --> java.lang.Object *
        class$0
            <-- am.englet.Englet.getStack()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.Englet.getRstack()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.static {}
            --> java.lang.Class *
        class$10
            <-- am.englet.Englet.getCastingContext()
            <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
            --> java.lang.Class *
        class$11
            <-- am.englet.Englet.getParserFactory()
            <-- am.englet.Englet.parse(java.lang.String)
            --> java.lang.Class *
        class$12
            <-- am.englet.Englet.parse(java.lang.String)
            --> java.lang.Class *
        class$13
            <-- am.englet.Englet.parse(java.lang.String)
            --> java.lang.Class *
        class$2
            <-- am.englet.Englet.getMethods()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.parse(java.lang.String)
            <-- am.englet.Englet.run()
            <-- am.englet.Englet.static {}
            --> java.lang.Class *
        class$3
            <-- am.englet.Englet.Englet()
            --> java.lang.Class *
        class$4
            <-- am.englet.Englet.Englet()
            <-- am.englet.Englet.run()
            --> java.lang.Class *
        class$5
            <-- am.englet.Englet.Englet()
            --> java.lang.Class *
        class$6
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> java.lang.Class *
        class$7
            <-- am.englet.Englet.run()
            --> java.lang.Class *
        class$8
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            --> java.lang.Class *
        class$9
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            --> java.lang.Class *
        cleanArgs(int)
            --> am.englet.Englet.args
            --> java.lang.Object *
        debug
            <-- am.englet.Englet.static {}
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Management.debug(am.englet.DataStack, boolean)
            <-- am.englet.Management.debug(am.englet.DataStack, int)
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.TestUtils0$10.tryNextContent()
            <-- am.englet.TestUtils0$9.tryNextContent()
            <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        dump(am.englet.CommandSource, am.englet.VariablesStorage)
            --> am.englet.CommandSource
            <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.VariablesStorage
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.err *
        findImplementation(java.lang.Class)
            --> am.englet.Englet.class$8
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-> am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            --> am.englet.Englet.singletons
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.HashMap.entrySet() *
            --> java.util.HashMap.get(java.lang.Object) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        getArgument()
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            <-- am.englet.Englet.getArgument(java.lang.Class)
            --> am.englet.Englet.getStack()
            --> am.englet.MethodsStorage$Cast
            --> am.englet.MethodsStorage$Cast.getContent() *
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.System.out *
        getArgument(java.lang.Class)
            --> am.englet.Englet.cast(java.lang.Class, java.lang.Object)
            --> am.englet.Englet.class$8
            --> am.englet.Englet.class$9
            --> am.englet.Englet.getArgument()
            <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.Englet.getServiceObject(java.lang.Class)
            --> am.englet.Englet.singletons
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.RuntimeException *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.err *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
        getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.DataStack
            --> am.englet.DataStack.popReset()
            --> am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
            --> am.englet.Englet.getArgument(java.lang.Class)
            --> am.englet.Englet.getStack()
            --> java.lang.Class *
            --> java.lang.Object *
        getCastingContext()
            --> am.englet.CastingContext
            <-- am.englet.Englet.cast(java.lang.Class, java.lang.Object)
            --> am.englet.Englet.class$10
            --> am.englet.Englet.getSingleton(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        getMethods()
            <-- am.englet.Englet.Englet()
            --> am.englet.Englet.class$2
            --> am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.MethodsStorage
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        getNNextArgumentTypes(int)
            --> am.englet.DataStack
            --> am.englet.DataStack.nTopArgumentTypes(int)
            --> am.englet.Englet.CLASSES
            --> am.englet.Englet.getStack()
            --> java.lang.Class *
        getParserFactory()
            --> am.englet.Englet.class$11
            --> am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.ServiceTokenizerFactory
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        getRstack()
            --> am.englet.CommandSource
            --> am.englet.Englet.class$1
            --> am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.Englet.run()
            <-- am.englet.Management.start(am.englet.Englet)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        getServiceObject(java.lang.Class)
            --> am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            --> am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            --> am.englet.Englet.singletons
            --> am.englet.SingletonPool$Derivation
            --> am.englet.SingletonPool$Derivation.clasz
            --> am.englet.SingletonPool$Derivation.method
            --> am.englet.SingletonPool$util.derivationMap
            --> am.englet.SingletonPool$util.implMap
            --> am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
            --> java.util.HashMap *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        getSingleton(java.lang.Class)
            <-- am.englet.Englet.Englet()
            <-> am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getCastingContext()
            <-- am.englet.Englet.getMethods()
            <-- am.englet.Englet.getParserFactory()
            <-- am.englet.Englet.getRstack()
            <-- am.englet.Englet.getStack()
            <-- am.englet.Englet.parse(java.lang.String)
            --> am.englet.Englet.singletons
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            --> am.englet.SingletonPool$util.implMap
            --> am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.HashMap *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
            --> java.util.Map.get(java.lang.Object) *
        getStack()
            --> am.englet.DataStack
            --> am.englet.Englet.class$0
            <-- am.englet.Englet.getArgument()
            <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            <-- am.englet.Englet.getNNextArgumentTypes(int)
            --> am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.Englet.handleResult(java.lang.Object)
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.start(am.englet.Englet)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.TestUtils0$10.tryNextContent()
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        handleResult(java.lang.Object)
            --> am.englet.DataStack
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.Englet.getStack()
            --> java.lang.Object *
        isManagementMethod(java.lang.Object)
            --> am.englet.Englet.class$0
            --> am.englet.Englet.class$1
            --> am.englet.Englet.class$2
            --> am.englet.Englet.class$8
            --> am.englet.Englet.class$9
            <-- am.englet.Management$1.check(java.lang.reflect.Method)
            <-- am.englet.Management.toAdapt(int, java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.HashSet.HashSet(java.util.Collection) *
            --> java.util.List *
            --> java.util.Set.contains(java.lang.Object) *
        managementArgClasses
            <-- am.englet.Englet.managementArgClasses()
            <-- am.englet.Englet.static {}
            --> java.lang.Class *
        managementArgClasses()
            --> am.englet.Englet.managementArgClasses
            --> java.lang.Class *
        parse(java.lang.String)
            --> am.englet.ArgumentProvider
            --> am.englet.Englet.class$11
            --> am.englet.Englet.class$12
            --> am.englet.Englet.class$13
            --> am.englet.Englet.class$2
            --> am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.ServiceTokenizerFactory
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            --> am.englet.ArgumentProvider
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.ResultHandler
            --> am.englet.TokenizerFactory
            --> am.englet.TokenizerFactory.forObject(java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
        putSingleton(java.lang.Object)
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Englet.singletons
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.util.HashMap *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
        putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
            --> am.englet.Englet.singletons
            --> java.lang.Class *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.HashMap *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
        run()
            --> am.englet.ArgumentProvider
            --> am.englet.CommandSource
            --> am.englet.Englet.class$2
            --> am.englet.Englet.class$4
            --> am.englet.Englet.class$7
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.Management.start(am.englet.Englet)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.SingletonPool.getSingleton(java.lang.Class)
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable *
            --> java.lang.Throwable.getMessage() *
        runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.CommandSource
            --> am.englet.CommandSource.content() *
            --> am.englet.CommandSource.tryNext() *
            --> am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.run()
            <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.ResultHandler
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.InvocationTargetException.getTargetException() *
        setCastingContext(am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.Englet.class$10
            --> am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        singletons
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.Englet.putSingleton(java.lang.Object)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            --> java.util.HashMap *
        static {}
            --> am.englet.Englet.CLASSES
            --> am.englet.Englet.class$0
            --> am.englet.Englet.class$1
            --> am.englet.Englet.class$2
            --> am.englet.Englet.debug
            --> am.englet.Englet.managementArgClasses
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
    Englet$1
        --> am.englet.ArgumentProvider$ArgumentsAndTarget
        --> java.lang.Object *
        Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
            --> am.englet.Englet
            --> am.englet.Englet$1.filledArgs0
            --> am.englet.Englet$1.target0
            --> am.englet.Englet$1.this$0
            <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        arguments()
            --> am.englet.Englet$1.filledArgs0
            --> java.lang.Object *
        clean()
            --> am.englet.Englet$1.filledArgs0
            --> am.englet.Englet$1.target0
            --> java.lang.Object *
        filledArgs0
            <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
            <-- am.englet.Englet$1.arguments()
            <-- am.englet.Englet$1.clean()
            <-- am.englet.Englet$1.toString()
            --> java.lang.Object *
        target()
            --> am.englet.Englet$1.target0
            --> java.lang.Object *
        target0
            <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
            <-- am.englet.Englet$1.clean()
            <-- am.englet.Englet$1.target()
            <-- am.englet.Englet$1.toString()
            --> java.lang.Object *
        this$0
            --> am.englet.Englet
            <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
        toString()
            --> am.englet.Englet$1.filledArgs0
            --> am.englet.Englet$1.target0
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
    EngletBasedChecker
        --> am.englet.util.Checker
        --> java.lang.Object *
        EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
            --> am.englet.Englet
            --> am.englet.EngletBasedChecker.englet
            --> am.englet.EngletBasedChecker.link
            --> am.englet.Utils.lazy(am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        check(java.lang.Object)
            --> am.englet.Englet
            --> am.englet.EngletBasedChecker.englet
            --> am.englet.EngletBasedChecker.link
            --> am.englet.Utils.STACK_IS_EMPTY
            --> am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
        englet
            --> am.englet.Englet
            <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
        link
            <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
            --> am.englet.link.Link
    EngletBasedValueConverter
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            --> am.englet.Englet
            --> am.englet.EngletBasedValueConverter.englet
            --> am.englet.EngletBasedValueConverter.link
            <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.Utils.lazy(am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.Englet
            --> am.englet.EngletBasedValueConverter.englet
            --> am.englet.EngletBasedValueConverter.link
            --> am.englet.Utils.STACK_IS_EMPTY
            --> am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Boolean *
            --> java.lang.Boolean.FALSE *
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
        englet
            --> am.englet.Englet
            <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        link
            <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
            --> am.englet.link.Link
        serialVersionUID
    EngletParserReaderTokenizerFactory
        --> am.englet.ServiceTokenizerFactory
        --> java.lang.Object *
        EngletParserReaderTokenizerFactory()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
            --> java.lang.Object.Object() *
        forObject(java.lang.Object)
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.backadapters.LineReaderStrategy.LineReaderStrategy()
            --> java.io.Reader *
            --> java.io.StringReader.StringReader(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.util.Iterator *
        main(java.lang.String[])
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext()
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.backadapters.LineReaderStrategy.LineReaderStrategy()
            --> java.io.File.File(java.lang.String) *
            --> java.io.File.getAbsolutePath() *
            --> java.io.FileReader.FileReader(java.lang.String) *
            --> java.io.PrintStream *
            --> java.io.Reader *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
    EngletSettings
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.SimpleStringArrayEngletSettings
        <-- am.englet.YAMLBasedEngletSettings
        --> java.lang.Object *
        apply(am.englet.Englet)
            --> am.englet.Englet
            <-- am.englet.Main.main(java.lang.String[])
            --> java.lang.Exception *
    FieldGetInvokable
        --> am.englet.reflect.MemberInvokable
        FieldGetInvokable(java.lang.reflect.Field)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
            <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        NO_CLASSES *
            <-- am.englet.FieldGetInvokable.parameterTypes(java.lang.reflect.Member)
        invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
        name(java.lang.reflect.Member)
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.lang.reflect.Member *
        parameterTypes(java.lang.reflect.Member)
            --> am.englet.FieldGetInvokable.NO_CLASSES *
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        returnType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getType() *
            --> java.lang.reflect.Member *
        serialVersionUID
        targetType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getDeclaringClass() *
            --> java.lang.reflect.Member.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        type()
            --> java.lang.String *
    FieldSetInvokable
        --> am.englet.reflect.MemberInvokable
        FieldSetInvokable(java.lang.reflect.Field)
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.set(java.lang.Object, java.lang.Object) *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
        name(java.lang.reflect.Member)
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.lang.reflect.Member *
        parameterTypes(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getType() *
            --> java.lang.reflect.Member *
        returnType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.Void.TYPE *
            --> java.lang.reflect.Member *
        serialVersionUID
        targetType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getDeclaringClass() *
            --> java.lang.reflect.Member.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        type()
            --> java.lang.String *
    Immediate
        --> java.lang.Object *
        Immediate()
            --> java.lang.Object.Object() *
        METHOD_NAME_REPLACEMENTS
            --> java.lang.String *
        bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage
            --> java.lang.String *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.BigDecimal(java.lang.String) *
        chain(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.deframe()
            --> am.englet.DataStack.enlist()
            --> am.englet.DataStack.pop()
            --> am.englet.link.FinalLink
            --> am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
            --> java.lang.Object *
            --> java.util.List *
        doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage
            --> java.lang.Double *
            --> java.lang.Double.Double(java.lang.String) *
            --> java.lang.String *
        floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage
            --> java.lang.Float *
            --> java.lang.Float.Float(java.lang.String) *
            --> java.lang.String *
        frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.frame()
            --> am.englet.MethodsStorage
        integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage
            --> java.lang.Integer *
            --> java.lang.Integer.Integer(java.lang.String) *
            --> java.lang.String *
        longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage
            --> java.lang.Long *
            --> java.lang.Long.Long(java.lang.String) *
            --> java.lang.String *
        perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.getContent()
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            --> am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.get(java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.lang.reflect.InvocationTargetException *
        popContent(am.englet.DataStack)
            --> am.englet.DataStack
            <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            --> am.englet.Immediate.popContentObject(am.englet.DataStack)
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        popContentObject(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            <-- am.englet.Immediate.popContent(am.englet.DataStack)
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.getContent()
            --> java.lang.Object *
        run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.CommandSource
            --> am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Throwable *
    Invokable
        <-- am.englet.CompoundInvokable
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invokable
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.returnType()
        <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
        <-- am.englet.ConditionalValueConverter.condition
        <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        <-- am.englet.ConditionalValueConverter.converter
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.Invokable$1
        <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
        <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.InvokableBasedValueConverter.invokable
        <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.InvokableDescription.getInvokable()
        <-- am.englet.InvokableDescription.invokable
        <-- am.englet.InvokableDescription.toString()
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodInvokableMetadata.invokable()
        <-- am.englet.MethodsStorage$MethodRecord
        <-- am.englet.MethodsStorage$MethodRecord$InvokableMetadata.invokable()
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.MethodsStorage$MethodRecord.createInvocableImplInstance(java.lang.Object)
        <-- am.englet.MethodsStorage$MethodRecord.getMethod()
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.method
        <-- am.englet.MethodsStorage$MethodRecord.parameterTypes()
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage$MethodRecord.returnType()
        <-- am.englet.MethodsStorage$MethodRecord.toString()
        <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage$Training$Invocation.invokable
        <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.TestUtils0$4.TestUtils0$4(am.englet.Invokable)
        <-- am.englet.TestUtils0$4.convert(java.lang.Object)
        <-- am.englet.TestUtils0$4.val$each
        <-- am.englet.TestUtils0$5.TestUtils0$5(am.englet.Invokable)
        <-- am.englet.TestUtils0$5.convert(java.lang.Object)
        <-- am.englet.TestUtils0$5.val$each
        <-- am.englet.TestUtils0$6.TestUtils0$6(am.englet.Invokable)
        <-- am.englet.TestUtils0$6.check(java.lang.Object)
        <-- am.englet.TestUtils0$6.val$each
        <-- am.englet.TestUtils0$7.TestUtils0$7(am.englet.Invokable)
        <-- am.englet.TestUtils0$7.check(java.lang.Object)
        <-- am.englet.TestUtils0$7.val$each
        <-- am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0$8.tryNextContent()
        <-- am.englet.TestUtils0$8.val$through
        <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.nonstaticInvokableBasedCkecker(am.englet.Invokable)
        <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.staticInvokableBasedCkecker(am.englet.Invokable)
        <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.toString(am.englet.Invokable)
        <-- am.englet.Utils$3
        <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
        <-- am.englet.Utils$3.inv
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$3.toString()
        <-- am.englet.Utils$4
        <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
        <-- am.englet.Utils$4.inv
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.toString()
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.staticInvokable(am.englet.Invokable, int)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
        <-- am.englet.bsh.MethodInvokable
        <-- am.englet.bsh.MethodInvokableMetadata.invokable()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.close
        <-- am.englet.link.InvokableTargetBackAdapterImpl.current
        <-- am.englet.link.InvokableTargetBackAdapterImpl.current()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext
        <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext
        <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext
        <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.i
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.inv
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        <-- am.englet.reflect.MemberInvokable
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
        <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.reflect.SimpleInvokableGetter.valueType()
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable)
        <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
        <-- am.englet.reflect.SimpleInvokableSetter.valueType()
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        --> java.lang.Object *
        NO_CLASSES
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.Invokable.static {}
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
            --> java.lang.Class *
        SAME_OBJECT_RETURNING_INVOKABLE
            <-- am.englet.Invokable.static {}
            <-- am.englet.Management.same(am.englet.ArgumentProvider)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
        invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
            <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
            <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.TestUtils0$4.convert(java.lang.Object)
            <-- am.englet.TestUtils0$5.convert(java.lang.Object)
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
            <-- am.englet.TestUtils0$8.tryNextContent()
            <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
            <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        parameterTypes()
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.parameterTypes()
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.reflect.SimpleInvokableSetter.valueType()
            --> java.lang.Class *
        returnType()
            <-- am.englet.CompoundInvokable.returnType()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.returnType()
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.reflect.SimpleInvokableGetter.valueType()
            --> java.lang.Class *
        static {}
            --> am.englet.Invokable$1.Invokable$1()
            --> am.englet.Invokable.NO_CLASSES
            --> am.englet.Invokable.SAME_OBJECT_RETURNING_INVOKABLE
            --> java.lang.Class *
        targetType()
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            --> java.lang.Class *
    Invokable$1
        --> am.englet.Invokable
        --> java.lang.Object *
        Invokable$1()
            <-- am.englet.Invokable.static {}
            --> java.lang.Object.Object() *
        invoke(java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        parameterTypes()
            --> java.lang.Class *
        returnType()
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        targetType()
            --> java.lang.Class *
        toString()
            --> java.lang.Object.hashCode() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.toString() *
    InvokableBasedValueConverter
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        InvokableBasedValueConverter(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            --> am.englet.InvokableBasedValueConverter.invokable
            --> am.englet.InvokableBasedValueConverter.isStatic
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.InvokableBasedValueConverter.invokable
            --> am.englet.InvokableBasedValueConverter.isStatic
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.Throwable *
        invokable
            --> am.englet.Invokable
            <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
            <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        isStatic
            <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
            <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        serialVersionUID
    InvokableDescription
        <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
        <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.createInvokableWrappwerArgSource(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.Management.compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        --> java.lang.Object *
        InvokableDescription(am.englet.Invokable, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.InvokableDescription.invokable
            --> am.englet.InvokableDescription.multiKey
            --> am.englet.InvokableDescription.sources
            --> am.englet.InvokableDescription.visited
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Integer *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        access$0(am.englet.InvokableDescription, java.lang.Integer)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            --> am.englet.InvokableDescription.multiKey
            --> java.lang.Integer *
        getInvokable()
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.InvokableDescription.invokable
        getMultiKey()
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.InvokableDescription.multiKey
            --> java.lang.Integer *
        getSources()
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.InvokableDescription.sources
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Object *
        invokable
            --> am.englet.Invokable
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableDescription.getInvokable()
            <-- am.englet.InvokableDescription.toString()
        multiKey
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableDescription.access$0(am.englet.InvokableDescription, java.lang.Integer)
            <-- am.englet.InvokableDescription.getMultiKey()
            <-- am.englet.InvokableDescription.toString()
            --> java.lang.Integer *
        prepare()
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> am.englet.InvokableDescription$PreparationContext
            --> am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
            --> am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            --> am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
        prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            --> am.englet.InvokableDescription$PreparationContext
            --> am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            <-- am.englet.InvokableDescription.prepare()
            --> am.englet.InvokableDescription.sources
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        sources
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableDescription.getSources()
            <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            <-- am.englet.InvokableDescription.toString()
            --> java.lang.Object *
        toString()
            --> am.englet.Invokable
            --> am.englet.InvokableDescription.invokable
            --> am.englet.InvokableDescription.multiKey
            --> am.englet.InvokableDescription.sources
            --> am.englet.InvokableDescription.visited
            --> java.lang.Integer *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.delete(int, int) *
            --> java.lang.StringBuffer.length() *
            --> java.lang.StringBuffer.toString() *
        visited
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableDescription.toString()
    InvokableDescription$PreparationContext
        <-- am.englet.InvokableDescription.prepare()
        <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
        --> java.lang.Object *
        InvokableDescription$PreparationContext()
            --> am.englet.InvokableDescription$PreparationContext.found
            --> am.englet.InvokableDescription$PreparationContext.next
            <-- am.englet.InvokableDescription.prepare()
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        add(am.englet.InvokableDescription)
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription$PreparationContext$Counter
            --> am.englet.InvokableDescription$PreparationContext$Counter.InvokableDescription$PreparationContext$Counter()
            --> am.englet.InvokableDescription$PreparationContext$Counter.timesUsed
            --> am.englet.InvokableDescription$PreparationContext.found
            <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        found
            <-- am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
            <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            --> java.util.Map *
        next
            <-- am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        setMultiKeys()
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription$PreparationContext$Counter
            --> am.englet.InvokableDescription$PreparationContext$Counter.timesUsed
            --> am.englet.InvokableDescription$PreparationContext.found
            --> am.englet.InvokableDescription$PreparationContext.next
            --> am.englet.InvokableDescription.access$0(am.englet.InvokableDescription, java.lang.Integer)
            <-- am.englet.InvokableDescription.prepare()
            --> java.lang.Integer *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
    InvokableDescription$PreparationContext$Counter
        <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        --> java.lang.Object *
        InvokableDescription$PreparationContext$Counter()
            --> am.englet.InvokableDescription$PreparationContext$Counter.timesUsed
            <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            --> java.lang.Object.Object() *
        timesUsed
            <-- am.englet.InvokableDescription$PreparationContext$Counter.InvokableDescription$PreparationContext$Counter()
            <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
    InvokableSerializer
        --> java.lang.Object *
        InvokableSerializer()
            --> java.lang.Object.Object() *
        access$0()
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> am.englet.InvokableSerializer.provs
            --> java.util.Map *
        class$0
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$1
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$2
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$3
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$4
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$5
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        class$6
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> java.lang.Class *
        create(java.lang.reflect.Member, java.lang.String)
            --> am.englet.Invokable
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> am.englet.InvokableSerializer.creators
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
            --> java.lang.reflect.Member *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        creators
            <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
            <-- am.englet.InvokableSerializer.static {}
            --> java.util.Map *
        describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.InvokableSerializer$SerializeInvokableDescription()
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.access$0(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.access$1(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.access$2(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.access$3(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class[])
            --> am.englet.reflect.MemberInvokable
            --> am.englet.reflect.MemberInvokable.declaringType()
            --> am.englet.reflect.MemberInvokable.parameterTypes()
            <-- am.englet.reflect.MemberInvokable.writeReplace()
            --> java.lang.Class *
            --> java.lang.String *
        provs
            <-- am.englet.InvokableSerializer.access$0()
            <-- am.englet.InvokableSerializer.static {}
            --> java.util.Map *
        static {}
            --> am.englet.InvokableSerializer$1.InvokableSerializer$1()
            --> am.englet.InvokableSerializer$2.InvokableSerializer$2()
            --> am.englet.InvokableSerializer.creators
            --> am.englet.InvokableSerializer.provs
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.Map *
    InvokableSerializer$1
        --> java.util.HashMap *
        InvokableSerializer$1()
            --> am.englet.InvokableSerializer$1.put(java.lang.Object, java.lang.Object) *
            --> am.englet.InvokableSerializer.class$0
            --> am.englet.InvokableSerializer.class$1
            --> am.englet.InvokableSerializer.class$2
            --> am.englet.InvokableSerializer.class$3
            --> am.englet.InvokableSerializer.class$4
            --> am.englet.InvokableSerializer.class$5
            --> am.englet.InvokableSerializer.class$6
            <-- am.englet.InvokableSerializer.static {}
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
            --> java.util.HashMap.HashMap() *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        serialVersionUID
    InvokableSerializer$2
        <-- am.englet.InvokableSerializer$3.InvokableSerializer$3(am.englet.InvokableSerializer$2)
        <-- am.englet.InvokableSerializer$3.this$1
        <-- am.englet.InvokableSerializer$4.InvokableSerializer$4(am.englet.InvokableSerializer$2)
        <-- am.englet.InvokableSerializer$4.this$1
        <-- am.englet.InvokableSerializer$5.InvokableSerializer$5(am.englet.InvokableSerializer$2)
        <-- am.englet.InvokableSerializer$5.this$1
        --> java.util.HashMap *
        InvokableSerializer$2()
            --> am.englet.InvokableSerializer$2.put(java.lang.Object, java.lang.Object) *
            --> am.englet.InvokableSerializer$3.InvokableSerializer$3(am.englet.InvokableSerializer$2)
            --> am.englet.InvokableSerializer$4.InvokableSerializer$4(am.englet.InvokableSerializer$2)
            --> am.englet.InvokableSerializer$5.InvokableSerializer$5(am.englet.InvokableSerializer$2)
            <-- am.englet.InvokableSerializer.static {}
            --> java.lang.Object *
            --> java.util.HashMap.HashMap() *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
        serialVersionUID
    InvokableSerializer$3
        --> am.englet.InvokableSerializer$MemberProvider
        --> java.lang.Object *
        InvokableSerializer$3(am.englet.InvokableSerializer$2)
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
            --> am.englet.InvokableSerializer$3.this$1
            --> java.lang.Object.Object() *
        member(java.lang.Class, java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Member *
        this$1
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$3.InvokableSerializer$3(am.englet.InvokableSerializer$2)
    InvokableSerializer$4
        --> am.englet.InvokableSerializer$MemberProvider
        --> java.lang.Object *
        InvokableSerializer$4(am.englet.InvokableSerializer$2)
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
            --> am.englet.InvokableSerializer$4.this$1
            --> java.lang.Object.Object() *
        member(java.lang.Class, java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.getMethod(java.lang.String, java.lang.Class[]) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        this$1
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$4.InvokableSerializer$4(am.englet.InvokableSerializer$2)
    InvokableSerializer$5
        --> am.englet.InvokableSerializer$MemberProvider
        --> java.lang.Object *
        InvokableSerializer$5(am.englet.InvokableSerializer$2)
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
            --> am.englet.InvokableSerializer$5.this$1
            --> java.lang.Object.Object() *
        member(java.lang.Class, java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.getField(java.lang.String) *
            --> java.lang.NoSuchFieldException *
            --> java.lang.NoSuchMethodException *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Member *
        this$1
            --> am.englet.InvokableSerializer$2
            <-- am.englet.InvokableSerializer$5.InvokableSerializer$5(am.englet.InvokableSerializer$2)
    InvokableSerializer$MemberProvider
        <-- am.englet.InvokableSerializer$3
        <-- am.englet.InvokableSerializer$4
        <-- am.englet.InvokableSerializer$5
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        --> java.lang.Object *
        member(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> java.lang.Class *
            --> java.lang.NoSuchFieldException *
            --> java.lang.NoSuchMethodException *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Member *
    InvokableSerializer$SerializeInvokableDescription
        <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
        <-- am.englet.reflect.MemberInvokable.writeReplace()
        --> java.io.Serializable *
        --> java.lang.Object *
        InvokableSerializer$SerializeInvokableDescription()
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> java.lang.Object.Object() *
        access$0(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.type
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> java.lang.String *
        access$1(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.name
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> java.lang.String *
        access$2(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class)
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.declaringType
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> java.lang.Class *
        access$3(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class[])
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.parameterTypes
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> java.lang.Class *
        declaringType
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$2(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> java.lang.Class *
        name
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$1(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> java.lang.String *
        parameterTypes
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$3(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class[])
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> java.lang.Class *
        readResolve()
            --> am.englet.Invokable
            --> am.englet.InvokableSerializer$MemberProvider
            --> am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.declaringType
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.name
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.parameterTypes
            --> am.englet.InvokableSerializer$SerializeInvokableDescription.type
            --> am.englet.InvokableSerializer.access$0()
            --> am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
            --> java.io.ObjectStreamException *
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.String *
            --> java.lang.Throwable *
            --> java.lang.reflect.Member *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        serialVersionUID
        type
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$0(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            --> java.lang.String *
    Links
        --> java.lang.Object *
        Links()
            --> java.lang.Object.Object() *
        NULL
            <-- am.englet.Links$5.tryNextContent()
            <-- am.englet.Links$6.tryNextContent()
            <-- am.englet.Links$7.tryNextContent()
            <-- am.englet.Links$TryNextContentBased.calculateNext()
            <-- am.englet.Links.nullCorrect(java.lang.Object)
            <-- am.englet.Links.static {}
            --> java.lang.Object *
        checkerBased(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.link.Link
            --> am.englet.util.Checker
        div(am.englet.link.Link, int)
            --> am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.TestUtils0.div(am.englet.link.Link, int)
            --> am.englet.link.Link
            --> java.lang.Object *
        flat(am.englet.link.Link)
            --> am.englet.Links.flat(am.englet.link.Link, int)
            --> am.englet.link.Link
        flat(am.englet.link.Link, int)
            --> am.englet.Links$8.Links$8(java.util.Stack, int)
            --> am.englet.Links$NextContentProvider
            <-- am.englet.Links.flat(am.englet.link.Link)
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
            --> java.util.Stack.push(java.lang.Object) *
        nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            --> am.englet.Links$TryNextContentBased.next() *
            <-- am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Links.div(am.englet.link.Link, int)
            <-- am.englet.Links.flat(am.englet.link.Link, int)
            <-- am.englet.Links.plusz(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links.toLazyChain(java.lang.String[])
            <-- am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Processing.loop(am.englet.link.Link)
            <-- am.englet.TestUtils0.divL(java.io.InputStream)
            <-- am.englet.TestUtils0.forLink(int, int)
            <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
            <-- am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
        nullCorrect(java.lang.Object)
            <-- am.englet.Links$4.tryNextContent()
            <-- am.englet.Links$5.tryNextContent()
            <-- am.englet.Links$6.tryNextContent()
            <-- am.englet.Links$9.tryNextContent()
            --> am.englet.Links.NULL
            <-- am.englet.Processing$1.tryNextContent()
            <-- am.englet.TestUtils0$2.tryNextContent()
            --> java.lang.Object *
        plusz(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Links$2.Links$2(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.TestUtils0.plusz(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
            --> am.englet.link.Link
        recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.link.Link
        static {}
            --> am.englet.Links.NULL
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        toChain(java.lang.Object[])
            <-- am.englet.Links$3.tryNextContent()
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Object *
        toLazyChain(java.lang.String[])
            --> am.englet.Links$9.Links$9(java.lang.String[])
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.lang.String *
        valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.timesdd(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
            <-- am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.link.Link
    Links$1
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        Links$1()
            <-- am.englet.Links$ValueConverter.static {}
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> java.lang.Object *
        serialVersionUID
    Links$2
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$2(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Links$2.l1
            --> am.englet.Links$2.l2
            <-- am.englet.Links.plusz(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        l1
            <-- am.englet.Links$2.Links$2(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Links$2.tryNextContent()
            --> am.englet.link.Link
        l2
            <-- am.englet.Links$2.Links$2(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Links$2.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$2.l1
            --> am.englet.Links$2.l2
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
    Links$3
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$3(am.englet.link.Link, java.lang.Object[])
            --> am.englet.Links$3.link
            --> am.englet.Links$3.val$buv
            <-- am.englet.Links.div(am.englet.link.Link, int)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        link
            <-- am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
            <-- am.englet.Links$3.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$3.link
            --> am.englet.Links$3.val$buv
            --> am.englet.Links.toChain(java.lang.Object[])
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$buv
            <-- am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
            <-- am.englet.Links$3.tryNextContent()
            --> java.lang.Object *
    Links$4
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$4(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.Links$4.linkA
            --> am.englet.Links$4.val$checker
            <-- am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.link.Link
            --> am.englet.util.Checker
            --> java.lang.Object.Object() *
        linkA
            <-- am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Links$4.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$4.linkA
            --> am.englet.Links$4.val$checker
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> am.englet.util.Checker
            --> am.englet.util.Checker.check(java.lang.Object)
            --> java.lang.Object *
        val$checker
            <-- am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Links$4.tryNextContent()
            --> am.englet.util.Checker
    Links$5
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$5.linkA
            --> am.englet.Links$5.val$vc
            --> am.englet.Links$ValueConverter
            <-- am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        linkA
            <-- am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$5.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$5.linkA
            --> am.englet.Links$5.val$vc
            --> am.englet.Links$ValueConverter
            --> am.englet.Links$ValueConverter.convert(java.lang.Object)
            --> am.englet.Links.NULL
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$vc
            <-- am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$5.tryNextContent()
            --> am.englet.Links$ValueConverter
    Links$6
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$6.linkA
            --> am.englet.Links$6.val$vc
            --> am.englet.Links$ValueConverter
            <-- am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        convert(am.englet.Links$ValueConverter, java.lang.Object)
            --> am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.tryNextContent()
            --> am.englet.Links$ValueConverter
            --> am.englet.Links$ValueConverter.TO_SAME_VALUE_CONVERTER
            --> java.lang.Object *
        convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.convert(am.englet.Links$ValueConverter, java.lang.Object)
            --> am.englet.Links$ValueConverter
            --> am.englet.Links$ValueConverter.convert(java.lang.Object)
            --> am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.link.Link
            --> java.lang.Object *
        linkA
            <-- am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$6.convert(am.englet.Links$ValueConverter, java.lang.Object)
            --> am.englet.Links$6.linkA
            --> am.englet.Links$6.val$vc
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.NULL
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$vc
            <-- am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.tryNextContent()
            --> am.englet.Links$ValueConverter
    Links$7
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Links$7.linkA
            --> am.englet.Links$7.val$vc
            --> am.englet.Links$ValueConverter
            <-- am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        convert(am.englet.Links$ValueConverter, java.lang.Object)
            <-- am.englet.Links$7.tryNextContent()
            --> am.englet.Links$ValueConverter
            --> am.englet.Links$ValueConverter.convert(java.lang.Object)
            --> am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.link.Link
            --> java.lang.Object *
        linkA
            <-- am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$7.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
            --> am.englet.Links$7.linkA
            --> am.englet.Links$7.val$vc
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.NULL
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$vc
            <-- am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$7.tryNextContent()
            --> am.englet.Links$ValueConverter
    Links$8
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$8(java.util.Stack, int)
            --> am.englet.Links$8.val$limit
            --> am.englet.Links$8.val$st
            <-- am.englet.Links.flat(am.englet.link.Link, int)
            --> java.lang.Object.Object() *
            --> java.util.Stack *
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$8.val$limit
            --> am.englet.Links$8.val$st
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.elementAt(int) *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.push(java.lang.Object) *
            --> java.util.Stack.removeElementAt(int) *
            --> java.util.Stack.set(int, java.lang.Object) *
            --> java.util.Stack.size() *
        val$limit
            <-- am.englet.Links$8.Links$8(java.util.Stack, int)
            <-- am.englet.Links$8.tryNextContent()
        val$st
            <-- am.englet.Links$8.Links$8(java.util.Stack, int)
            <-- am.englet.Links$8.tryNextContent()
            --> java.util.Stack *
    Links$9
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Links$9(java.lang.String[])
            --> am.englet.Links$9.i
            --> am.englet.Links$9.l
            --> am.englet.Links$9.val$buv
            <-- am.englet.Links.toLazyChain(java.lang.String[])
            --> java.lang.Object.Object() *
            --> java.lang.String *
        i
            <-- am.englet.Links$9.Links$9(java.lang.String[])
            <-- am.englet.Links$9.tryNextContent()
        l
            <-- am.englet.Links$9.Links$9(java.lang.String[])
            <-- am.englet.Links$9.tryNextContent()
        serialVersionUID
        tryNextContent()
            --> am.englet.Links$9.i
            --> am.englet.Links$9.l
            --> am.englet.Links$9.val$buv
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        val$buv
            <-- am.englet.Links$9.Links$9(java.lang.String[])
            <-- am.englet.Links$9.tryNextContent()
            --> java.lang.String *
    Links$Calculate_Next_Based
        <-- am.englet.Links$TryNextContentBased
        <-- am.englet.Links$TryNextContentBased.calculateNext()
        --> am.englet.link.Link$Serializable
        --> java.lang.Object *
        Links$Calculate_Next_Based()
            <-- am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            --> java.lang.Object.Object() *
        calculateNext()
            <-- am.englet.Links$Calculate_Next_Based.next()
        next
            <-- am.englet.Links$Calculate_Next_Based.next()
        next()
            --> am.englet.Links$Calculate_Next_Based.calculateNext()
            --> am.englet.Links$Calculate_Next_Based.next
            --> am.englet.link.Link
        serialVersionUID
    Links$NextContentProvider
        <-- am.englet.Links$2
        <-- am.englet.Links$3
        <-- am.englet.Links$4
        <-- am.englet.Links$5
        <-- am.englet.Links$6
        <-- am.englet.Links$7
        <-- am.englet.Links$8
        <-- am.englet.Links$9
        <-- am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
        <-- am.englet.Links$TryNextContentBased.calculateNext()
        <-- am.englet.Links$TryNextContentBased.ncp
        <-- am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Links.div(am.englet.link.Link, int)
        <-- am.englet.Links.flat(am.englet.link.Link, int)
        <-- am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
        <-- am.englet.Links.plusz(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.toLazyChain(java.lang.String[])
        <-- am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Processing$1
        <-- am.englet.Processing.loop(am.englet.link.Link)
        <-- am.englet.TestUtils0$1
        <-- am.englet.TestUtils0$10
        <-- am.englet.TestUtils0$11
        <-- am.englet.TestUtils0$2
        <-- am.englet.TestUtils0$8
        <-- am.englet.TestUtils0$9
        <-- am.englet.TestUtils0.divL(java.io.InputStream)
        <-- am.englet.TestUtils0.forLink(int, int)
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
        --> java.io.Serializable *
        --> java.lang.Object *
        tryNextContent()
            <-- am.englet.Links$TryNextContentBased.calculateNext()
            --> java.lang.Object *
    Links$TryNextContentBased
        --> am.englet.Links$Calculate_Next_Based
        Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            --> am.englet.Links$Calculate_Next_Based.Links$Calculate_Next_Based()
            --> am.englet.Links$NextContentProvider
            <-- am.englet.Links$TryNextContentBased.calculateNext()
            --> am.englet.Links$TryNextContentBased.content
            --> am.englet.Links$TryNextContentBased.ncp
            <-- am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> java.lang.Object *
        calculateNext()
            --> am.englet.Links$Calculate_Next_Based
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links$NextContentProvider.tryNextContent()
            --> am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            --> am.englet.Links$TryNextContentBased.ncp
            --> am.englet.Links.NULL
            --> java.lang.Object *
        content
            <-- am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            <-- am.englet.Links$TryNextContentBased.content()
            --> java.lang.Object *
        content()
            --> am.englet.Links$TryNextContentBased.content
            --> java.lang.Object *
        ncp
            --> am.englet.Links$NextContentProvider
            <-- am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
            <-- am.englet.Links$TryNextContentBased.calculateNext()
        next() *
            <-- am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
        serialVersionUID
    Links$ValueConverter
        <-- am.englet.ConditionalValueConverter
        <-- am.englet.EngletBasedValueConverter
        <-- am.englet.InvokableBasedValueConverter
        <-- am.englet.Links$1
        <-- am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$5.tryNextContent()
        <-- am.englet.Links$5.val$vc
        <-- am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$6.convert(am.englet.Links$ValueConverter, java.lang.Object)
        <-- am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
        <-- am.englet.Links$6.tryNextContent()
        <-- am.englet.Links$6.val$vc
        <-- am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
        <-- am.englet.Links$7.tryNextContent()
        <-- am.englet.Links$7.val$vc
        <-- am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.TestUtils0$3
        <-- am.englet.TestUtils0$4
        <-- am.englet.TestUtils0$5
        <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
        <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter, am.englet.TestUtils0$FS1)
        <-- am.englet.TestUtils0$FS1.c
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.timesdd(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Utils$7
        <-- am.englet.Utils$8
        <-- am.englet.Utils$9
        <-- am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
        <-- am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
        --> java.io.Serializable *
        --> java.lang.Object *
        TO_SAME_VALUE_CONVERTER
            <-- am.englet.Links$6.convert(am.englet.Links$ValueConverter, java.lang.Object)
            <-- am.englet.Links$ValueConverter.static {}
        convert(java.lang.Object)
            <-- am.englet.Links$5.tryNextContent()
            <-- am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
            <-- am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
            <-- am.englet.TestUtils0$FS1.tryNext()
            --> java.lang.Object *
        static {}
            --> am.englet.Links$1.Links$1()
            --> am.englet.Links$ValueConverter.TO_SAME_VALUE_CONVERTER
    Lookup
        --> java.lang.Object *
        CLASSES
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        CR
            <-- am.englet.Lookup.access$0()
            <-- am.englet.Lookup.static {}
            --> java.lang.String *
        CollectionsMethodMaxArgCount
        InstantiatorMaxArgCount
        Lookup()
            --> java.lang.Object.Object() *
        MethodBasicMaxArgCount
        MethodNonBasicMaxArgCount
        PART_PATTERN
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.static {}
            --> java.util.regex.Pattern *
        SetOrAddMaxArgCount
        StaticMethodMaxArgCount
        TypedMaxArgCount
        access$0()
            <-- am.englet.Lookup$1.result()
            <-- am.englet.Lookup$7.result()
            <-- am.englet.Lookup$9.result()
            --> am.englet.Lookup.CR
            --> java.lang.String *
        adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.Invokable
            <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.String *
            --> java.lang.reflect.Field *
        checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            --> am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            --> am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getName() *
        class$0
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        class$10
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> java.lang.Class *
        class$11
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> java.lang.Class *
        class$12
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> java.lang.Class *
        class$2
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        class$3
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        class$4
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.static {}
            --> java.lang.Class *
        class$5
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            --> java.lang.Class *
        class$6
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> java.lang.Class *
        class$7
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            --> java.lang.Class *
        class$8
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            --> java.lang.Class *
        class$9
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            --> java.lang.Class *
        correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup$4.provide()
            <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            --> am.englet.Utils.isPublic(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getParameterTypes() *
        dataProvidersEnumeration(am.englet.Lookup$DataProvider[])
            --> am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup$5.provide()
            --> am.englet.Lookup$DataProvider
            --> java.util.Enumeration *
        doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            --> am.englet.Invokable
            --> am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        dp1(java.lang.Class, java.lang.Class, am.englet.Lookup$DataProvider[], boolean, boolean)
            --> am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            --> am.englet.Lookup$DataProvider
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> java.lang.Class *
        extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            --> am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
        findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            --> am.englet.$.$(java.lang.Class, java.lang.Class)
            --> am.englet.$.method(int, int, java.lang.Class[], java.lang.String[]) *
            --> am.englet.Lookup.class$9
            <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            --> am.englet.Utils.isPublic(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
        firstNotNull(am.englet.Lookup$DataProvider[])
            --> am.englet.Lookup$DataProvider
            --> am.englet.Lookup$DataProvider.provide()
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> java.lang.Object *
        fitsClassName(java.lang.Class, boolean, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.String *
            --> java.lang.String.startsWith(java.lang.String) *
        getPossibleClassNameStarts(java.lang.Class[], int)
            --> am.englet.Lookup.PART_PATTERN
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            --> java.lang.CharSequence *
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.lastIndexOf(int) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Iterator *
            --> java.util.List.add(int, java.lang.Object) *
            --> java.util.List.get(int) *
            --> java.util.List.iterator() *
            --> java.util.List.set(int, java.lang.Object) *
            --> java.util.List.size() *
            --> java.util.regex.Matcher *
            --> java.util.regex.Matcher.find() *
            --> java.util.regex.Matcher.group(int) *
            --> java.util.regex.Pattern *
            --> java.util.regex.Pattern.matcher(java.lang.CharSequence) *
        importStatic(java.lang.Class)
            --> am.englet.Lookup.class$0
            --> am.englet.Lookup.staticClasses
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getMethods() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
            --> java.util.Set *
            --> java.util.Set.add(java.lang.Object) *
        isCastable(java.lang.Class, java.lang.Class)
            --> am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        iter1(java.lang.Class)
            --> am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.util.Iterator *
        lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage
            <-- am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Lookup.underscoredToClassName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.toUpperCase() *
            --> java.lang.System.out *
        lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.String *
        lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> am.englet.CodeBlock
            --> am.englet.Invokable
            --> am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
            --> am.englet.Lookup.class$10
            --> am.englet.Lookup.class$11
            --> am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            --> am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
        lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            --> am.englet.CodeBlock
            --> am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.class$4
            --> am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            --> am.englet.Lookup.iter1(java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            --> am.englet.Utils.simpleName(java.lang.Class)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
        lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.Invokable
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Field *
        lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.String *
        lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Invokable
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.reflect.MemberInvokable
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.reflect.MemberInvokable
            --> am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.String.toUpperCase() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Method *
        lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            --> am.englet.Lookup.staticClasses
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            --> am.englet.Lookup.underscoredToClassName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            --> am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.String *
        lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            --> am.englet.ArgumentProvider
            --> am.englet.Lookup.fitsClassName(java.lang.Class, boolean, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.String.substring(int) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
        lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.simpleName(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.SecurityException *
            --> java.lang.String *
        lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
            --> am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Void.TYPE *
        lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
            --> am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToClassName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.SecurityException *
            --> java.lang.String *
        lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.System.out *
        lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> am.englet.CodeBlock
            --> am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            --> am.englet.Lookup.CLASSES
            --> am.englet.Lookup.class$2
            --> am.englet.Lookup.class$5
            --> am.englet.Lookup.class$6
            --> am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            --> am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isArray() *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getName() *
        lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
            --> am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.SecurityException *
            --> java.lang.String *
        lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.target()
            --> am.englet.ArgumentProvider.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.ArgumentProvider.getCastingContext()
            --> am.englet.CastingContext
            --> am.englet.Invokable
            --> am.englet.Lookup.class$12
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToClassName(java.lang.String)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isInterface() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.System.out *
            --> java.lang.Throwable.getMessage() *
        lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            --> am.englet.Invokable
            --> am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup$10.method(int, int) *
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.System.out *
            --> java.lang.reflect.Method *
        lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            --> am.englet.Invokable
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> am.englet.reflect.MemberInvokable
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.Lookup$2.Lookup$2(java.lang.String)
            --> am.englet.Lookup$3.Lookup$3(java.lang.String)
            --> am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            --> am.englet.Lookup$DataProvider
            --> am.englet.Lookup.dp1(java.lang.Class, java.lang.Class, am.englet.Lookup$DataProvider[], boolean, boolean)
            --> am.englet.Lookup.firstNotNull(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.reflect.MemberInvokable
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            --> am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            --> am.englet.Lookup.underscoredToClassName(java.lang.String)
            --> am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.String.endsWith(java.lang.String) *
            --> java.lang.String.replaceAll(java.lang.String, java.lang.String) *
            --> java.lang.String.split(java.lang.String, int) *
            --> java.lang.String.toUpperCase() *
        lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            --> am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.lang.reflect.Field *
        lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            --> am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.System.out *
        lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.indexOf(int) *
            --> java.lang.System.out *
        lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            --> am.englet.Invokable
            --> am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            --> am.englet.Lookup$6.method(int, int) *
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            --> am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.System.out *
        paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            --> am.englet.Lookup.class$7
            --> am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            --> am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            --> am.englet.Utils.isPublic(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getInterfaces() *
            --> java.lang.Class.getSuperclass() *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
        static {}
            --> am.englet.Lookup.CLASSES
            --> am.englet.Lookup.CR
            --> am.englet.Lookup.PART_PATTERN
            --> am.englet.Lookup.class$0
            --> am.englet.Lookup.class$1
            --> am.englet.Lookup.class$2
            --> am.englet.Lookup.class$3
            --> am.englet.Lookup.class$4
            --> am.englet.Lookup.staticClasses
            --> java.lang.Byte.TYPE *
            --> java.lang.Character.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Short.TYPE *
            --> java.lang.String *
            --> java.lang.System.getProperty(java.lang.String) *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashSet.HashSet() *
            --> java.util.Set *
            --> java.util.Set.add(java.lang.Object) *
            --> java.util.regex.Pattern *
            --> java.util.regex.Pattern.compile(java.lang.String) *
        staticClasses
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            <-- am.englet.Lookup.static {}
            --> java.util.Set *
        stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            --> am.englet.Lookup.class$5
            --> am.englet.Lookup.class$8
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
            --> am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            --> am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.System.out *
        tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
            --> am.englet.Invokable
            --> am.englet.Lookup$11.Lookup$11(java.lang.Class, java.lang.Class)
            --> am.englet.Lookup$11.method(int, int, java.lang.Class[]) *
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            --> am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> am.englet.Englet.debug
            --> am.englet.Invokable
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            --> am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodInvokable
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.reflect.MemberInvokable
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.getModifiers() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.reflect.Modifier.isAbstract(int) *
        tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            --> am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            --> am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
        underscoredToCamel(java.lang.String, boolean)
            <-- am.englet.Lookup.underscoredToClassName(java.lang.String)
            <-- am.englet.Lookup.underscoredToMemberName(java.lang.String)
            --> java.lang.Character.toLowerCase(char) *
            --> java.lang.Character.toTitleCase(char) *
            --> java.lang.String *
            --> java.lang.String.String(char[], int, int) *
            --> java.lang.String.toCharArray() *
        underscoredToClassName(java.lang.String)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
            --> java.lang.String *
        underscoredToMemberName(java.lang.String)
            <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
            --> java.lang.String *
    Lookup$1
        --> am.englet.CodeBlock
        Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.Lookup$1.val$argCount
            --> am.englet.Lookup$1.val$name
            --> am.englet.Lookup$1.val$ofWhat
            --> am.englet.Lookup$1.val$staticFlagMask
            --> am.englet.Lookup$1.val$types
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            --> java.lang.Class *
            --> java.lang.String *
        result()
            --> am.englet.Lookup$1.val$argCount
            --> am.englet.Lookup$1.val$name
            --> am.englet.Lookup$1.val$ofWhat
            --> am.englet.Lookup$1.val$staticFlagMask
            --> am.englet.Lookup$1.val$types
            --> am.englet.Lookup.access$0()
            --> java.lang.Class *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$argCount
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$1.result()
        val$name
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$1.result()
            --> java.lang.String *
        val$ofWhat
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$1.result()
            --> java.lang.Class *
        val$staticFlagMask
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$1.result()
        val$types
            <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
            <-- am.englet.Lookup$1.result()
            --> java.lang.Class *
    Lookup$10
        --> am.englet.$
        Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Lookup$10.val$command
            --> am.englet.Lookup$10.val$nNextArgumentTypes
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.Lookup$10.val$command
            --> am.englet.Lookup$10.val$nNextArgumentTypes
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.String *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getParameterTypes() *
        method(int, int) *
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        val$command
            <-- am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            --> java.lang.String *
        val$nNextArgumentTypes
            <-- am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            --> java.lang.Class *
    Lookup$11
        --> am.englet.$
        Lookup$11(java.lang.Class, java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Lookup$11.val$cls0
            <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> am.englet.Lookup$11.val$cls0
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
        method(int, int, java.lang.Class[]) *
            <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        val$cls0
            <-- am.englet.Lookup$11.Lookup$11(java.lang.Class, java.lang.Class)
            <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
            --> java.lang.Class *
    Lookup$12
        --> java.lang.Object *
        --> java.util.Enumeration *
        Lookup$12(am.englet.Lookup$DataProvider[])
            --> am.englet.Lookup$12.i
            --> am.englet.Lookup$12.l
            --> am.englet.Lookup$12.val$dps
            --> am.englet.Lookup$DataProvider
            <-- am.englet.Lookup.dataProvidersEnumeration(am.englet.Lookup$DataProvider[])
            --> java.lang.Object.Object() *
        hasMoreElements()
            --> am.englet.Lookup$12.i
            --> am.englet.Lookup$12.l
        i
            <-- am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup$12.hasMoreElements()
            <-- am.englet.Lookup$12.nextElement()
        l
            <-- am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup$12.hasMoreElements()
        nextElement()
            --> am.englet.Lookup$12.i
            --> am.englet.Lookup$12.val$dps
            --> am.englet.Lookup$DataProvider
            --> am.englet.Lookup$DataProvider.provide()
            --> java.lang.Object *
        val$dps
            <-- am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup$12.nextElement()
            --> am.englet.Lookup$DataProvider
    Lookup$2
        --> am.englet.Lookup$DataProvider
        --> java.lang.Object *
        Lookup$2(java.lang.String)
            --> am.englet.Lookup$2.val$name
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> java.lang.Object.Object() *
            --> java.lang.String *
        provide()
            --> am.englet.Lookup$2.val$name
            --> java.lang.Object *
            --> java.lang.String *
        val$name
            <-- am.englet.Lookup$2.Lookup$2(java.lang.String)
            <-- am.englet.Lookup$2.provide()
            --> java.lang.String *
    Lookup$3
        --> am.englet.Lookup$DataProvider
        --> java.lang.Object *
        Lookup$3(java.lang.String)
            --> am.englet.Lookup$3.val$command
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> java.lang.Object.Object() *
            --> java.lang.String *
        provide()
            --> am.englet.Lookup$3.val$command
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.toUpperCase() *
        val$command
            <-- am.englet.Lookup$3.Lookup$3(java.lang.String)
            <-- am.englet.Lookup$3.provide()
            --> java.lang.String *
    Lookup$4
        --> am.englet.Lookup$DataProvider
        --> java.lang.Object *
        Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            --> am.englet.Lookup$4.val$at
            --> am.englet.Lookup$4.val$cls
            --> am.englet.Lookup$4.val$name
            <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Object.Object() *
            --> java.lang.String *
        provide()
            --> am.englet.Lookup$4.val$at
            --> am.englet.Lookup$4.val$cls
            --> am.englet.Lookup$4.val$name
            --> am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        val$at
            <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup$4.provide()
            --> java.lang.Class *
        val$cls
            <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup$4.provide()
            --> java.lang.Class *
        val$name
            <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup$4.provide()
            --> java.lang.String *
    Lookup$5
        --> am.englet.Lookup$DataProvider
        --> java.lang.Object *
        Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            --> am.englet.Lookup$5.val$at
            --> am.englet.Lookup$5.val$cls
            --> am.englet.Lookup$5.val$declaredOnly
            --> am.englet.Lookup$5.val$dps
            --> am.englet.Lookup$5.val$includeDeclared
            --> am.englet.Lookup$DataProvider
            <-- am.englet.Lookup.dp1(java.lang.Class, java.lang.Class, am.englet.Lookup$DataProvider[], boolean, boolean)
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        provide()
            --> am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
            --> am.englet.Lookup$5.val$at
            --> am.englet.Lookup$5.val$cls
            --> am.englet.Lookup$5.val$declaredOnly
            --> am.englet.Lookup$5.val$dps
            --> am.englet.Lookup$5.val$includeDeclared
            --> am.englet.Lookup$DataProvider
            --> am.englet.Lookup.class$5
            --> am.englet.Lookup.class$6
            --> am.englet.Lookup.dataProvidersEnumeration(am.englet.Lookup$DataProvider[])
            --> am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getType() *
            --> java.util.Enumeration *
            --> java.util.Enumeration.hasMoreElements() *
            --> java.util.Enumeration.nextElement() *
        val$at
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$5.provide()
            --> java.lang.Class *
        val$cls
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$5.provide()
            --> java.lang.Class *
        val$declaredOnly
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$5.provide()
        val$dps
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$5.provide()
            --> am.englet.Lookup$DataProvider
        val$includeDeclared
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$5.provide()
    Lookup$6
        --> am.englet.$
        Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Lookup$6.val$command
            --> am.englet.Lookup$6.val$n
            --> am.englet.Lookup$6.val$nNextArgumentTypes
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.Lookup$6.val$command
            --> am.englet.Lookup$6.val$n
            --> am.englet.Lookup$6.val$nNextArgumentTypes
            --> am.englet.Utils.simpleName(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.String.length() *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.String.substring(int) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getParameterTypes() *
        method(int, int) *
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        val$command
            <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            --> java.lang.String *
        val$n
            <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
        val$nNextArgumentTypes
            <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            --> java.lang.Class *
    Lookup$7
        --> am.englet.CodeBlock
        Lookup$7(java.lang.String, java.lang.Class[], int)
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.Lookup$7.val$i
            --> am.englet.Lookup$7.val$types
            --> am.englet.Lookup$7.val$underscoredToMemberName
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> java.lang.Class *
            --> java.lang.String *
        result()
            --> am.englet.Lookup$7.val$i
            --> am.englet.Lookup$7.val$types
            --> am.englet.Lookup$7.val$underscoredToMemberName
            --> am.englet.Lookup.access$0()
            --> java.lang.Class *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$i
            <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
            <-- am.englet.Lookup$7.result()
        val$types
            <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
            <-- am.englet.Lookup$7.result()
            --> java.lang.Class *
        val$underscoredToMemberName
            <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
            <-- am.englet.Lookup$7.result()
            --> java.lang.String *
    Lookup$8
        --> java.lang.Object *
        --> java.util.Iterator *
        Lookup$8(java.lang.Class)
            --> am.englet.Lookup$8.base
            --> am.englet.Lookup$8.base()
            --> am.englet.Lookup$8.current
            --> am.englet.Lookup$8.val$cls
            --> am.englet.Lookup$8.wasnext
            <-- am.englet.Lookup.iter1(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        base
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup$8.nxt()
            --> java.lang.Class *
        base()
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            --> am.englet.Lookup$8.val$cls
            --> am.englet.Lookup.class$10
            --> am.englet.Lookup.class$11
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        current
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup$8.hasNext()
            <-- am.englet.Lookup$8.next()
            <-- am.englet.Lookup$8.nxt()
            --> java.lang.Class *
        hasNext()
            --> am.englet.Lookup$8.current
            --> am.englet.Lookup$8.nxt()
            --> am.englet.Lookup$8.wasnext
            --> java.lang.Class *
        next()
            --> am.englet.Lookup$8.current
            --> am.englet.Lookup$8.nxt()
            --> am.englet.Lookup$8.wasnext
            --> java.lang.Class *
            --> java.lang.Object *
        nxt()
            --> am.englet.Lookup$8.base
            --> am.englet.Lookup$8.current
            <-- am.englet.Lookup$8.hasNext()
            <-- am.englet.Lookup$8.next()
            --> java.lang.Class *
            --> java.lang.Class.getInterfaces() *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
        remove()
        val$cls
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup$8.base()
            --> java.lang.Class *
        wasnext
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup$8.hasNext()
            <-- am.englet.Lookup$8.next()
    Lookup$9
        --> am.englet.CodeBlock
        Lookup$9(java.lang.String, java.lang.Class[])
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.Lookup$9.val$cc
            --> am.englet.Lookup$9.val$name
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.String *
        result()
            --> am.englet.Lookup$9.val$cc
            --> am.englet.Lookup$9.val$name
            --> am.englet.Lookup.access$0()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$cc
            <-- am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup$9.result()
            --> java.lang.Class *
        val$name
            <-- am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup$9.result()
            --> java.lang.String *
    Lookup$DataProvider
        <-- am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
        <-- am.englet.Lookup$12.nextElement()
        <-- am.englet.Lookup$12.val$dps
        <-- am.englet.Lookup$2
        <-- am.englet.Lookup$3
        <-- am.englet.Lookup$4
        <-- am.englet.Lookup$5
        <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup$5.val$dps
        <-- am.englet.Lookup.dataProvidersEnumeration(am.englet.Lookup$DataProvider[])
        <-- am.englet.Lookup.dp1(java.lang.Class, java.lang.Class, am.englet.Lookup$DataProvider[], boolean, boolean)
        <-- am.englet.Lookup.firstNotNull(am.englet.Lookup$DataProvider[])
        <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
        --> java.lang.Object *
        provide()
            <-- am.englet.Lookup$12.nextElement()
            <-- am.englet.Lookup.firstNotNull(am.englet.Lookup$DataProvider[])
            --> java.lang.Object *
    LoopTest
        <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
        <-- am.englet.LoopTest$1.this$0
        <-- am.englet.LoopTest$2.LoopTest$2(am.englet.LoopTest, java.lang.Class)
        <-- am.englet.LoopTest$2.this$0
        <-- am.englet.LoopTest$3.LoopTest$3(am.englet.LoopTest, java.lang.Class)
        <-- am.englet.LoopTest$3.this$0
        --> junit.framework.TestCase *
        LoopTest()
            --> junit.framework.TestCase.TestCase() *
        class$0
            <-- am.englet.LoopTest.test1()
            --> java.lang.Class *
        test1()
            --> am.englet.$$Declared
            --> am.englet.$$Declared.$() *
            --> am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
            --> am.englet.LoopTest$1.declared *
            --> am.englet.LoopTest$2.$() *
            --> am.englet.LoopTest$2.LoopTest$2(am.englet.LoopTest, java.lang.Class)
            --> am.englet.LoopTest$3.$(int, int) *
            --> am.englet.LoopTest$3.LoopTest$3(am.englet.LoopTest, java.lang.Class)
            --> am.englet.LoopTest.class$0
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.lang.Throwable.getMessage() *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List *
    LoopTest$1
        --> am.englet.$
        LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.LoopTest
            --> am.englet.LoopTest$1.this$0
            --> am.englet.LoopTest$1.val$l
            <-- am.englet.LoopTest.test1()
            --> java.lang.Class *
            --> java.util.List *
        declared *
            <-- am.englet.LoopTest.test1()
        each(java.lang.reflect.Field)
            --> am.englet.LoopTest$1.val$l
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        this$0
            --> am.englet.LoopTest
            <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
        val$l
            <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
            <-- am.englet.LoopTest$1.each(java.lang.reflect.Field)
            --> java.util.List *
    LoopTest$2
        --> am.englet.$
        $() *
            <-- am.englet.LoopTest.test1()
        LoopTest$2(am.englet.LoopTest, java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.LoopTest
            --> am.englet.LoopTest$2.this$0
            <-- am.englet.LoopTest.test1()
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
        this$0
            --> am.englet.LoopTest
            <-- am.englet.LoopTest$2.LoopTest$2(am.englet.LoopTest, java.lang.Class)
    LoopTest$3
        --> am.englet.$
        $(int, int) *
            <-- am.englet.LoopTest.test1()
        LoopTest$3(am.englet.LoopTest, java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.LoopTest
            --> am.englet.LoopTest$3.this$0
            <-- am.englet.LoopTest.test1()
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
        this$0
            --> am.englet.LoopTest
            <-- am.englet.LoopTest$3.LoopTest$3(am.englet.LoopTest, java.lang.Class)
    Main
        --> java.lang.Object *
        Main()
            --> java.lang.Object.Object() *
        class$0
            <-- am.englet.Main.getSettings(java.lang.String[])
            --> java.lang.Class *
        class$1
            <-- am.englet.Main.getSettings(java.lang.String[])
            --> java.lang.Class *
        englet
            --> am.englet.Englet
            <-- am.englet.Main.main(java.lang.String[])
        getSettings(java.lang.String[])
            --> am.englet.EngletSettings
            --> am.englet.Main.class$0
            --> am.englet.Main.class$1
            <-- am.englet.Main.main(java.lang.String[])
            --> am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[])
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.Class.getName() *
            --> java.lang.Class.newInstance() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.NoSuchMethodException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.SecurityException.printStackTrace() *
            --> java.lang.String *
            --> java.lang.System.getProperty(java.lang.String, java.lang.String) *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
        main(java.lang.String[])
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.deframeAll()
            --> am.englet.DataStack.top()
            --> am.englet.Englet
            --> am.englet.Englet.Englet()
            --> am.englet.Englet.getStack()
            --> am.englet.EngletSettings
            --> am.englet.EngletSettings.apply(am.englet.Englet)
            --> am.englet.Main.englet
            --> am.englet.Main.getSettings(java.lang.String[])
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.lang.Throwable *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Stack *
            --> java.util.Stack.iterator() *
    Management
        --> java.lang.Object *
        DEFRAMER_FINAL_LINK
            <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
            <-- am.englet.Management.static {}
            --> am.englet.link.FinalLink
        IF(am.englet.DataStack, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Object *
        IFeq(am.englet.DataStack, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.peek()
            --> am.englet.DataStack.pop()
            --> am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        METHOD_NAME_REPLACEMENTS
            --> java.lang.String *
        Management()
            --> java.lang.Object.Object() *
        access$0(int, java.lang.reflect.Method)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            --> am.englet.Management.toAdapt(int, java.lang.reflect.Method)
            --> java.lang.reflect.Method *
        access$1(java.util.HashMap, java.lang.String)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            --> am.englet.Management.replacement(java.util.HashMap, java.lang.String)
            --> java.lang.String *
            --> java.util.HashMap *
        access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            --> am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.String *
            --> java.lang.reflect.Method *
        adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.Management$2.$() *
            --> am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            <-- am.englet.Management.adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Management.adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Management.adapt_processing_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Management.getReplacementsMap(java.lang.Class)
            --> am.englet.MethodsStorage
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.util.HashMap *
        adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            --> am.englet.Invokable
            <-- am.englet.Management.access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
            <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> java.lang.String *
            --> java.lang.reflect.Method *
        adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.Englet()
            --> am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.ConstructorInvokable
            --> am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
            --> am.englet.Invokable
            <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
            <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            --> am.englet.Management.check(am.englet.Invokable, java.lang.String)
            --> am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.reflect.MemberInvokable
            --> am.englet.reflect.MemberInvokable.getMember()
            --> java.lang.Class *
            --> java.lang.Class.getConstructors() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.equals(java.lang.Object) *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getDeclaringClass() *
        adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
            --> am.englet.Management$1.Management$1(java.lang.Class, java.lang.String)
            --> am.englet.Management$1.method(java.lang.String[]) *
            --> am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoSuchMethodException *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.Englet()
            --> am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            --> am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            --> am.englet.MethodsStorage
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            --> am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        adapt_processing_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        add_url(java.net.URL, am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.addURL(java.net.URL)
            --> java.net.URL *
        append(am.englet.link.Link, int, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.append(am.englet.link.Link, int) *
            --> am.englet.link.Link
        array(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.deframe()
            --> am.englet.DataStack.top()
            --> java.util.ArrayList.ArrayList(java.util.Collection) *
            --> java.util.Collection *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
        as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.CastingContext.canCast(java.lang.Class, java.lang.Class)
            --> am.englet.MethodsStorage$Cast
            --> am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        asClass(am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        atX(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.at(int)
            --> java.lang.Object *
        atXX(am.englet.DataStack, int, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.at(int, int)
            --> java.lang.Object *
        call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
            --> am.englet.ArgumentProvider
            --> am.englet.CommandSource
            --> am.englet.Invokable
            --> am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
            --> am.englet.ResultHandler
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.reflect.InvocationTargetException *
        chain(int, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.link.Chain
            --> am.englet.link.Chain.Chain(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.FinalLink
            --> java.lang.Object *
        check(am.englet.Invokable, java.lang.String)
            --> am.englet.Invokable
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.reflect.MemberInvokable
            --> am.englet.reflect.MemberInvokable.getMember()
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.String.lastIndexOf(int) *
            --> java.lang.String.replaceAll(java.lang.String, java.lang.String) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.toLowerCase() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getDeclaringClass() *
            --> java.lang.reflect.Member *
        class$0
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            --> java.lang.Class *
        class$1
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> java.lang.Class *
        class$2
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> java.lang.Class *
        class$3
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> java.lang.Class *
        class$4
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> java.lang.Class *
        class$5
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> java.lang.Class *
        compose(am.englet.InvokableDescription, am.englet.DataStack, am.englet.ArgumentProvider)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getCastingContext()
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable
            --> am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> am.englet.DataStack
            --> am.englet.DataStack.isFaking()
            --> am.englet.DataStack.setFaking(boolean)
            --> am.englet.InvokableDescription
        debug(am.englet.DataStack, boolean)
            --> am.englet.DataStack
            --> am.englet.Englet.debug
        debug(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.Englet.debug
        debug2(am.englet.DataStack, boolean)
            --> am.englet.DataStack
            --> am.englet.DataStack.DEBUG
        debug2(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.DEBUG
        deframe(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.deframe()
        describe(am.englet.Invokable, am.englet.ArgumentProvider)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.arguments()
            --> am.englet.ArgumentProvider.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.targetType()
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            --> am.englet.Management.class$0
            <-- am.englet.Management.same(am.englet.ArgumentProvider)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.InvocationTargetException *
        direct(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.Management$3.Management$3(am.englet.link.Link)
            <-- am.englet.Management.startDirect(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.TestUtils0.timesd(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.Invokable
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> java.lang.String *
        drop(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> java.lang.Object *
        dropAll(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.stack()
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
        dump(am.englet.MethodsStorage)
            --> am.englet.MethodsStorage
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Object *
            --> java.lang.System.err *
        dup(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.DataStack.push(java.lang.Object)
            --> java.lang.Object *
        dupClone(java.lang.StringBuffer, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.push(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.toString() *
        each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.Slider
        englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.DataStack
            --> am.englet.DataStack.derive()
            --> am.englet.Englet
            --> am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
        excl(am.englet.CommandSource, am.englet.DataStack)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.param(int)
            --> am.englet.DataStack.pop()
            --> am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            --> java.lang.Object *
        excl(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.System.out *
        excl(java.lang.Integer, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.current(int) *
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.link.Link
            --> java.io.PrintStream *
            --> java.lang.Integer *
            --> java.lang.Integer.intValue() *
            --> java.lang.Object *
            --> java.lang.System.out *
        excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.put(java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        excl(java.util.Map, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Management.frame(am.englet.DataStack, java.util.Map)
            --> java.util.Map *
        fake(am.englet.DataStack, boolean)
            --> am.englet.DataStack
            --> am.englet.DataStack.setFaking(boolean)
        fake(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.setFaking(boolean)
        filter(am.englet.DataStack, am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.DataStack
            --> am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.link.Link
            --> am.englet.util.Checker
        forgive(am.englet.MethodsStorage, boolean)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.forgiveErrors
        forgive(am.englet.MethodsStorage, int)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.forgiveErrors
        frame(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.frame()
        frame(am.englet.DataStack, java.util.Map)
            --> am.englet.DataStack
            --> am.englet.DataStack.frame(java.util.Map)
            <-- am.englet.Management.excl(java.util.Map, am.englet.DataStack)
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
            --> java.util.Map *
        get(java.lang.String, am.englet.VariablesStorage)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.get(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.getField(java.lang.String) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.System.out *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
            --> java.util.ArrayList *
            --> java.util.Collections.list(java.util.Enumeration) *
            --> java.util.Enumeration *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.get(java.lang.Object) *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String) *
        go(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.go(am.englet.link.Link, int) *
            --> am.englet.link.Link
        goFakeLing(am.englet.CommandSource, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
            --> am.englet.link.Link
        if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.DataStack
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.link.Link
            --> java.lang.Object *
        ifgo(am.englet.CommandSource, boolean, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link, int)
            --> am.englet.link.Link
        ifgo(am.englet.CommandSource, boolean, am.englet.link.Link, int)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.go(am.englet.link.Link, int) *
            <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link)
            --> am.englet.link.Link
        impl(am.englet.VariablesStorage, java.lang.Class)
            --> am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
            --> am.englet.VariablesStorage
            --> java.lang.Class *
            --> java.lang.Object *
        impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        import_package(am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.importPackage(java.lang.String)
            --> java.lang.String *
        invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
            --> am.englet.DataStack
            --> am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.lang.Object[])
            --> am.englet.reflect.MemberInvokable
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
        invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
            --> am.englet.Invokable
            --> am.englet.Management$4.Management$4(java.lang.Class, java.lang.String)
            --> am.englet.Management$4.constructor() *
            --> am.englet.Management$5.Management$5(java.lang.Class, java.lang.String)
            --> am.englet.Management$5.field() *
            --> am.englet.Management$6.Management$6(java.lang.Class, java.lang.String)
            --> am.englet.Management$6.field() *
            --> am.englet.Management$7.Management$7(java.lang.Class, java.lang.String)
            --> am.englet.Management$7.method() *
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Character.toLowerCase(char) *
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Method *
        lastT(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastU(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastV(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastW(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastX(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastY(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        lastZ(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.last(int)
            --> java.lang.Object *
        multiPut(java.lang.String, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.peekResultList()
            --> am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        nAtIn(int, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.stack()
            --> am.englet.Utils.stackIndex(java.util.List, int)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.insertElementAt(java.lang.Object, int) *
            --> java.util.Stack.pop() *
        nAtOut(int, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.stack()
            --> am.englet.Utils.stackIndex(java.util.List, int)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.push(java.lang.Object) *
            --> java.util.Stack.remove(int) *
        ngo(am.englet.link.Link, int, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.go(am.englet.link.Link, int) *
            --> am.englet.link.Link
        ntrec(int, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.current(int) *
            --> am.englet.CommandSource.go(am.englet.link.Link, int) *
            --> am.englet.link.Link
        param(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.param()
            --> am.englet.DataStack.param(int)
            --> am.englet.DataStack.top()
            <-- am.englet.Management.param1(am.englet.DataStack)
            --> java.util.Stack *
            --> java.util.Stack.size() *
        param1(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Management.param(am.englet.DataStack)
        param1(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.param(int)
        parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            --> am.englet.ArgumentProvider
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.deframe()
            --> am.englet.DataStack.enlist()
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.pop()
            --> am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.TokenizerFactory
            --> am.englet.link.FinalLink
            --> am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.List *
        parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
            --> am.englet.ArgumentProvider
            <-- am.englet.Englet.parse(java.lang.String)
            --> am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.ServiceTokenizerFactory
            --> am.englet.TokenizerFactory
            --> java.lang.Exception *
            --> java.lang.String *
        parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            --> am.englet.ArgumentProvider
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.entrySet() *
            --> am.englet.DataStack$StackFrame.get(java.lang.Object) *
            --> am.englet.DataStack$StackFrame.put(java.lang.Object, java.lang.Object) *
            --> am.englet.DataStack$StackFrame.remove(java.lang.Object) *
            --> am.englet.DataStack.top()
            --> am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.ResultHandler
            --> am.englet.TokenizerFactory
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.endsWith(java.lang.String) *
            --> java.lang.String.length() *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.String.substring(int, int) *
            --> java.util.ArrayList.ArrayList(java.util.Collection) *
            --> java.util.ArrayList.iterator() *
            --> java.util.Collection *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Set *
        peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        printstack(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
        processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.Invokable
            --> am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
            --> am.englet.ArgumentProvider
            --> am.englet.Invokable
            --> am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.getMethod()
            --> am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.cast.ClassPool
            --> java.lang.String *
        props(am.englet.DataStack, java.lang.String)
            --> am.englet.DataStack
            --> am.englet.Management.frame(am.englet.DataStack, java.util.Map)
            --> java.io.ByteArrayInputStream.ByteArrayInputStream(byte[]) *
            --> java.io.InputStream *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.String *
            --> java.lang.String.getBytes(java.lang.String) *
            --> java.util.Map *
            --> java.util.Properties.Properties() *
            --> java.util.Properties.load(java.io.InputStream) *
        props(am.englet.DataStack, java.util.Map)
            --> am.englet.DataStack
            --> java.io.ByteArrayOutputStream.ByteArrayOutputStream() *
            --> java.io.ByteArrayOutputStream.toString(java.lang.String) *
            --> java.io.OutputStream *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Properties.Properties() *
            --> java.util.Properties.setProperty(java.lang.String, java.lang.String) *
            --> java.util.Properties.store(java.io.OutputStream, java.lang.String) *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        pure(am.englet.Invokable, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.top()
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.targetType()
            --> java.lang.Class *
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
            --> java.util.Stack.size() *
        put2(java.lang.String, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.peekResultList(int)
            --> am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        put3(java.lang.String, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.peekResultList(int)
            --> am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        put4(java.lang.String, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.peekResultList(int)
            --> am.englet.DataStack.put(java.lang.Object, java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
        replacement(java.util.HashMap, java.lang.String)
            <-- am.englet.Management.access$1(java.util.HashMap, java.lang.String)
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
        res(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.res(int)
        run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.DataStack
            --> am.englet.Englet
            --> am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
        runner(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Invokable
            --> am.englet.Management.class$1
            --> am.englet.Management.class$2
            --> am.englet.Management.class$3
            --> am.englet.Management.class$4
            --> am.englet.Management.class$5
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getMethod(java.lang.String, java.lang.Class[]) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
        same(am.englet.ArgumentProvider)
            --> am.englet.ArgumentProvider
            --> am.englet.Invokable
            --> am.englet.Invokable.SAME_OBJECT_RETURNING_INVOKABLE
            --> am.englet.InvokableDescription
            --> am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.reflect.InvocationTargetException *
        service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
            --> am.englet.ServiceObject
            --> am.englet.SingletonPool
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        service_object(am.englet.SingletonPool, java.lang.Class)
            <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.ServiceObject
            --> am.englet.SingletonPool
            --> am.englet.SingletonPool.getSingleton(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
        setTopQiuet(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.quiet
            --> am.englet.DataStack.at(int, int)
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.DataStack.top()
            --> java.lang.Object *
        start(am.englet.Englet)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Englet
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.getStack()
            --> am.englet.Englet.run()
            --> am.englet.Management.start(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
        start(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            <-- am.englet.Management.start(am.englet.Englet)
            <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.link.Link
        start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.peek()
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.Management.DEFRAMER_FINAL_LINK
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> java.lang.Object *
        startDirect(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.Management.direct(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.link.Link
        startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.DataStack
            --> am.englet.DataStack.push(java.lang.Object)
            <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
            --> am.englet.link.Link
            --> java.lang.Object *
        startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.top()
            --> am.englet.Management.DEFRAMER_FINAL_LINK
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
        startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.getStack()
            --> am.englet.Englet.run()
            --> am.englet.Management.start(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.MethodsStorage
            --> am.englet.cast.ClassPool
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
        startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
            --> am.englet.CommandSource
            --> am.englet.CommandSource.start(am.englet.link.Link) *
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.shading
            --> am.englet.DataStack.frame()
            --> am.englet.DataStack.param(int)
            --> am.englet.Management.DEFRAMER_FINAL_LINK
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
        static {}
            --> am.englet.Management.DEFRAMER_FINAL_LINK
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.intern() *
        stringize(am.englet.MethodsStorage, boolean)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.notFoundCommandAsString
        stringize(am.englet.MethodsStorage, int)
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage.notFoundCommandAsString
        sub(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.DataStack.sub(int)
            --> java.util.Map *
        toAdapt(int, java.lang.reflect.Method)
            --> am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Management.access$0(int, java.lang.reflect.Method)
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        top(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.top()
            --> java.util.Stack *
            --> java.util.Stack.size() *
        trace(am.englet.DataStack, boolean)
            --> am.englet.DataStack
            <-- am.englet.Management.trace(am.englet.DataStack, int)
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.close()
        trace(am.englet.DataStack, int)
            --> am.englet.DataStack
            --> am.englet.Management.trace(am.englet.DataStack, boolean)
        yOut(java.lang.Object, java.lang.Object, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.push(java.lang.Object)
            --> java.lang.Object *
    Management$1
        --> am.englet.$
        Management$1(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$1.val$mtdName
            <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.Englet.isManagementMethod(java.lang.Object)
            --> am.englet.Management$1.val$mtdName
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
        method(java.lang.String[]) *
            <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        val$mtdName
            <-- am.englet.Management$1.Management$1(java.lang.Class, java.lang.String)
            <-- am.englet.Management$1.check(java.lang.reflect.Method)
            --> java.lang.String *
    Management$2
        --> am.englet.$
        $() *
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$2.val$mstor
            --> am.englet.Management$2.val$replacements
            --> am.englet.Management$2.val$type
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            --> java.lang.Class *
            --> java.util.HashMap *
        each(java.lang.reflect.Method)
            --> am.englet.Management$2.val$mstor
            --> am.englet.Management$2.val$replacements
            --> am.englet.Management$2.val$type
            --> am.englet.Management.access$0(int, java.lang.reflect.Method)
            --> am.englet.Management.access$1(java.util.HashMap, java.lang.String)
            --> am.englet.Management.access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            --> am.englet.MethodsStorage
            --> java.lang.String *
            --> java.lang.String.trim() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.util.HashMap *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String) *
            --> java.util.StringTokenizer.hasMoreTokens() *
            --> java.util.StringTokenizer.nextToken() *
        val$mstor
            <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            --> am.englet.MethodsStorage
        val$replacements
            <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            --> java.util.HashMap *
        val$type
            <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
    Management$3
        --> am.englet.link.Link
        --> java.lang.Object *
        Management$3(am.englet.link.Link)
            --> am.englet.Management$3.l1
            <-- am.englet.Management.direct(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        content()
            --> am.englet.Management$3.l1
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> java.lang.Object *
        l1
            <-- am.englet.Management$3.Management$3(am.englet.link.Link)
            <-- am.englet.Management$3.content()
            <-- am.englet.Management$3.next()
            <-- am.englet.Management$3.toString()
            --> am.englet.link.Link
        next()
            --> am.englet.Management$3.l1
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
        toString()
            --> am.englet.Management$3.l1
            --> am.englet.link.Link
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    Management$4
        --> am.englet.$
        Management$4(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$4.val$mask
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Constructor)
            --> am.englet.Management$4.val$mask
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.matches(java.lang.String) *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.toString() *
        constructor() *
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        val$mask
            <-- am.englet.Management$4.Management$4(java.lang.Class, java.lang.String)
            <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
            --> java.lang.String *
    Management$5
        --> am.englet.$
        Management$5(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$5.val$mask
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Field)
            --> am.englet.Management$5.val$mask
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.matches(java.lang.String) *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.toString() *
        field() *
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        val$mask
            <-- am.englet.Management$5.Management$5(java.lang.Class, java.lang.String)
            <-- am.englet.Management$5.check(java.lang.reflect.Field)
            --> java.lang.String *
    Management$6
        --> am.englet.$
        Management$6(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$6.val$mask
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Field)
            --> am.englet.Management$6.val$mask
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.matches(java.lang.String) *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.toString() *
        field() *
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        val$mask
            <-- am.englet.Management$6.Management$6(java.lang.Class, java.lang.String)
            <-- am.englet.Management$6.check(java.lang.reflect.Field)
            --> java.lang.String *
    Management$7
        --> am.englet.$
        Management$7(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Management$7.val$mask
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.Management$7.val$mask
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.matches(java.lang.String) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.toString() *
        method() *
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        val$mask
            <-- am.englet.Management$7.Management$7(java.lang.Class, java.lang.String)
            <-- am.englet.Management$7.check(java.lang.reflect.Method)
            --> java.lang.String *
    Management$8
        --> am.englet.link.Link
        --> java.lang.Object *
        Management$8(am.englet.CommandSource, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.Management$8.val$cs
            --> am.englet.Management$8.val$l
            <-- am.englet.Management.goFakeLing(am.englet.CommandSource, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
        content()
            --> am.englet.CommandSource
            --> am.englet.CommandSource.go(am.englet.link.Link, int) *
            --> am.englet.Const.NO_RESULT
            --> am.englet.Management$8.val$cs
            --> am.englet.Management$8.val$l
            --> am.englet.link.Link
            --> java.lang.Object *
        next()
            --> am.englet.link.Link
        val$cs
            --> am.englet.CommandSource
            <-- am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
            <-- am.englet.Management$8.content()
        val$l
            <-- am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
            <-- am.englet.Management$8.content()
            --> am.englet.link.Link
    MethodInvokable
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        --> am.englet.reflect.MemberInvokable
        MethodInvokable(java.lang.reflect.Method)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.Lookup$4.provide()
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
            <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
            <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            <-- am.englet.Management.runner(am.englet.DataStack)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokableMetadata.invokable()
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.reflect.Method *
        MethodInvokable(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodInvokable.p0class
            --> am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        arrayClass(java.lang.Class)
            <-- am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.NegativeArraySizeException *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.reflect.Array.newInstance(java.lang.Class, int) *
        arrayClass(java.lang.Class, java.lang.Class[])
            --> am.englet.MethodInvokable.arrayClass(java.lang.Class)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Void.TYPE *
        bpt(java.lang.reflect.Method, java.lang.Class)
            --> am.englet.MethodInvokable.arrayClass(java.lang.Class)
            --> am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
            --> am.englet.MethodInvokable.class$0
            --> am.englet.MethodInvokable.class$1
            <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Method.getReturnType() *
        class$0
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            --> java.lang.Class *
        class$1
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            --> java.lang.Class *
        deprimitivise(java.lang.Class[]) *
            <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
        dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.reflect.Member *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        extraToString()
            --> am.englet.MethodInvokable.parameterTypes() *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        name(java.lang.reflect.Member)
            --> java.lang.String *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
        p0class
            <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
            --> java.lang.Class *
        parameterTypes() *
            <-- am.englet.MethodInvokable.extraToString()
        parameterTypes(java.lang.reflect.Member)
            --> am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            --> am.englet.MethodInvokable.deprimitivise(java.lang.Class[]) *
            --> am.englet.MethodInvokable.p0class
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
        returnType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
        serialVersionUID
        targetType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        type()
            --> java.lang.String *
    MethodInvokableMetadata
        --> am.englet.MethodsStorage$MethodRecord$InvokableMetadata
        --> java.lang.Object *
        MethodInvokableMetadata(java.lang.reflect.Method)
            --> am.englet.MethodInvokableMetadata.method
            --> java.lang.Object.Object() *
            --> java.lang.reflect.Method *
        invokable()
            --> am.englet.Invokable
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.MethodInvokableMetadata.method
            --> java.lang.reflect.Method *
        isStatic()
            --> am.englet.MethodInvokableMetadata.method
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        method
            <-- am.englet.MethodInvokableMetadata.MethodInvokableMetadata(java.lang.reflect.Method)
            <-- am.englet.MethodInvokableMetadata.invokable()
            <-- am.englet.MethodInvokableMetadata.isStatic()
            <-- am.englet.MethodInvokableMetadata.targetType()
            --> java.lang.reflect.Method *
        targetType()
            --> am.englet.MethodInvokableMetadata.method
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
    MethodsStorage
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.getMethods()
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.frame(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
        <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
        <-- am.englet.Management$2.each(java.lang.reflect.Method)
        <-- am.englet.Management$2.val$mstor
        <-- am.englet.Management.access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Management.adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
        <-- am.englet.Management.adapt_processing_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.dump(am.englet.MethodsStorage)
        <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.forgive(am.englet.MethodsStorage, boolean)
        <-- am.englet.Management.forgive(am.englet.MethodsStorage, int)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.stringize(am.englet.MethodsStorage, boolean)
        <-- am.englet.Management.stringize(am.englet.MethodsStorage, int)
        --> am.englet.ServiceObject
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        --> java.lang.Object *
        MethodsStorage()
            <-- am.englet.Englet.Englet()
            --> am.englet.MethodsStorage.methods
            --> java.lang.Object.Object() *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
        class$0
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> java.lang.Class *
        class$1
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> java.lang.Class *
        class$2
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> java.lang.Class *
        class$3
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> java.lang.Class *
        class$4
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> java.lang.Class *
        forgiveErrors
            <-- am.englet.Management.forgive(am.englet.MethodsStorage, boolean)
            <-- am.englet.Management.forgive(am.englet.MethodsStorage, int)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            --> am.englet.CastingContext
            --> am.englet.MethodsStorage$Dispatcher
            --> am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
            --> am.englet.MethodsStorage$MethodRecord
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            --> am.englet.MethodsStorage.methods
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.System.out *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
        getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider.getCastingContext()
            --> am.englet.ArgumentProvider.getNNextArgumentTypes(int)
            --> am.englet.CastingContext
            --> am.englet.MethodsStorage$Dispatcher
            --> am.englet.MethodsStorage$Dispatcher.getMaxArgsCount()
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.isImmediate()
            --> am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage.methods
            <-- am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
        handleDirect(java.lang.Object, am.englet.ResultHandler)
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.getContent()
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage$Training.direct(java.lang.Object)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage.training
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Trace.directObject(java.lang.Object)
            --> java.lang.Object *
        handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Trace.got(java.lang.Object, java.lang.String)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.get(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> java.lang.Double *
            --> java.lang.Double.valueOf(java.lang.String) *
            --> java.lang.Integer *
            --> java.lang.Integer.decode(java.lang.String) *
            --> java.lang.Long *
            --> java.lang.Long.decode(java.lang.String) *
            --> java.lang.NumberFormatException *
            --> java.lang.Object *
            --> java.lang.String *
        handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.MethodsStorage.forgiveErrors
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            --> am.englet.ResultHandler
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.Exception *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.RuntimeException *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.err *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.InvocationTargetException.getTargetException() *
        invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
            --> am.englet.ArgumentProvider
            --> am.englet.Invokable
            <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> am.englet.ResultHandler
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.reflect.InvocationTargetException *
        invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> am.englet.ArgumentProvider
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.arguments()
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.clean()
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.target()
            --> am.englet.ArgumentProvider.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
            --> am.englet.Const.NO_RESULT
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.returnType()
            --> am.englet.Invokable.targetType()
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.method
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.RuntimeException *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.Void.TYPE *
            --> java.lang.reflect.InvocationTargetException *
        invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage$Training.direct(java.lang.Object)
            --> am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            --> am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            --> am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage.training
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Trace.unfound(java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.VariablesStorage
            --> am.englet.cast.ClassPool
            --> java.io.PrintStream *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.System.out *
            --> java.lang.reflect.InvocationTargetException *
        invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.ArgumentProvider
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.Invokable
            --> am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.MethodsStorage$Getter.MethodsStorage$Getter(java.lang.String)
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            --> am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage.notFoundCommandAsString
            --> am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.MethodsStorage.training
            --> am.englet.ResultHandler
            --> am.englet.ResultHandler.handleResult(java.lang.Object)
            --> am.englet.Trace.command(java.lang.String)
            --> am.englet.Trace.unfoundString(java.lang.String)
            --> am.englet.cast.ClassPool
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.intern() *
            --> java.lang.String.length() *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toLowerCase() *
            --> java.lang.reflect.InvocationTargetException *
        lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.ArgumentProvider
            --> am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.cast.ClassPool
            --> java.lang.String *
            --> java.lang.String.length() *
        methods
            <-- am.englet.MethodsStorage.MethodsStorage()
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage.toString()
            --> java.util.HashMap *
        notFoundCommandAsString
            <-- am.englet.Management.stringize(am.englet.MethodsStorage, boolean)
            <-- am.englet.Management.stringize(am.englet.MethodsStorage, int)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        processor(java.lang.String, am.englet.ArgumentProvider)
            --> am.englet.ArgumentProvider
            <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> java.lang.String *
        put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage$Dispatcher
            --> am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage.class$4
            --> am.englet.MethodsStorage.methods
            --> am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.intern() *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.Map *
        repInvokeStringFail(java.lang.Object)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.err *
        retain()
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage$Training.retain()
            --> am.englet.MethodsStorage.training
        toString()
            --> am.englet.MethodsStorage.methods
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.HashMap *
        train()
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage$Training.MethodsStorage$Training()
            --> am.englet.MethodsStorage.training
        trained()
            --> am.englet.MethodsStorage$Training
            --> am.englet.MethodsStorage.training
        training
            --> am.englet.MethodsStorage$Training
            <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.MethodsStorage.retain()
            <-- am.englet.MethodsStorage.train()
            <-- am.englet.MethodsStorage.trained()
    MethodsStorage$1
        --> java.lang.Object *
        --> java.util.Comparator *
        MethodsStorage$1(am.englet.MethodsStorage$Dispatcher)
            --> am.englet.MethodsStorage$1.this$1
            --> am.englet.MethodsStorage$Dispatcher
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            --> java.lang.Object.Object() *
        compare(java.lang.Object, java.lang.Object)
            --> am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.getParameterTypes()
            --> java.lang.Class *
            --> java.lang.Object *
        this$1
            <-- am.englet.MethodsStorage$1.MethodsStorage$1(am.englet.MethodsStorage$Dispatcher)
            --> am.englet.MethodsStorage$Dispatcher
    MethodsStorage$Cast
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.Englet.getArgument()
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        --> am.englet.MethodsStorage$Direct
        MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> am.englet.InvokableDescription
            <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            --> am.englet.MethodsStorage$Cast.castClass
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.MethodsStorage.class$1
            --> am.englet.MethodsStorage.class$2
            --> am.englet.MethodsStorage.class$3
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.lang.CharSequence *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.ClassCastException.ClassCastException(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Throwable.getMessage() *
        castClass
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$Cast.toString()
            --> java.lang.Class *
        getContent() *
            <-- am.englet.Englet.getArgument()
            <-- am.englet.MethodsStorage$Cast.toString()
        serialVersionUID
        toString()
            --> am.englet.MethodsStorage$Cast.castClass
            --> am.englet.MethodsStorage$Cast.getContent() *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    MethodsStorage$CommandNotFoundException
        --> java.lang.RuntimeException *
        MethodsStorage$CommandNotFoundException()
            --> java.lang.RuntimeException.RuntimeException() *
        MethodsStorage$CommandNotFoundException(java.lang.String)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> java.lang.RuntimeException.RuntimeException(java.lang.String) *
            --> java.lang.String *
        MethodsStorage$CommandNotFoundException(java.lang.String, java.lang.Throwable)
            --> java.lang.RuntimeException.RuntimeException(java.lang.String, java.lang.Throwable) *
            --> java.lang.String *
            --> java.lang.Throwable *
        MethodsStorage$CommandNotFoundException(java.lang.Throwable)
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.Throwable *
        serialVersionUID
    MethodsStorage$Direct
        <-- am.englet.CompoundInvokable$DirectArgSource.CompoundInvokable$DirectArgSource(am.englet.MethodsStorage$Direct)
        <-- am.englet.CompoundInvokable$DirectArgSource.d
        <-- am.englet.CompoundInvokable$DirectArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$DirectArgSource.toString()
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.popContentObject(am.englet.DataStack)
        <-- am.englet.Management$3.content()
        <-- am.englet.MethodsStorage$Cast
        <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        --> java.io.Serializable *
        --> java.lang.Object *
        MethodsStorage$Direct(java.lang.Object)
            <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            <-- am.englet.Management$3.content()
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            --> am.englet.MethodsStorage$Direct.content
            <-- am.englet.MethodsStorage$Training.direct(java.lang.Object)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.TestUtils0$3.convert(java.lang.Object)
            <-- am.englet.TestUtils0.direct(java.lang.Object)
            <-- am.englet.TestUtils0.directPlus(java.lang.Object, am.englet.link.Link)
            <-- am.englet.TestUtils0.times(java.lang.Object, boolean)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        content
            <-- am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            <-- am.englet.MethodsStorage$Direct.getContent()
            --> java.lang.Object *
        getContent()
            <-- am.englet.CompoundInvokable$DirectArgSource.getData(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.Immediate.popContentObject(am.englet.DataStack)
            --> am.englet.MethodsStorage$Direct.content
            <-- am.englet.MethodsStorage$Direct.toString()
            <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> java.lang.Object *
        serialVersionUID
        toString()
            <-- am.englet.CompoundInvokable$DirectArgSource.toString()
            --> am.englet.MethodsStorage$Direct.getContent()
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
    MethodsStorage$Dispatcher
        <-- am.englet.MethodsStorage$1.MethodsStorage$1(am.englet.MethodsStorage$Dispatcher)
        <-- am.englet.MethodsStorage$1.this$1
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        --> java.lang.Object *
        MethodsStorage$Dispatcher()
            --> am.englet.MethodsStorage$Dispatcher.records
            --> am.englet.MethodsStorage$MethodRecord
            --> java.lang.Object.Object() *
        get(java.lang.Class[], am.englet.CastingContext, boolean)
            --> am.englet.CastingContext
            --> am.englet.MethodsStorage$Dispatcher.records
            --> am.englet.MethodsStorage$MethodRecord
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            --> am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        getMaxArgsCount()
            --> am.englet.MethodsStorage$Dispatcher.records
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.getParametersCount()
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        put(am.englet.MethodsStorage$MethodRecord)
            --> am.englet.Englet.debug
            --> am.englet.MethodsStorage$1.MethodsStorage$1(am.englet.MethodsStorage$Dispatcher)
            --> am.englet.MethodsStorage$Dispatcher.records
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.getParametersCount()
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.System.out *
            --> java.util.Arrays.sort(java.lang.Object[], java.util.Comparator) *
            --> java.util.Comparator *
        records
            <-- am.englet.MethodsStorage$Dispatcher.MethodsStorage$Dispatcher()
            <-- am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
            <-- am.englet.MethodsStorage$Dispatcher.getMaxArgsCount()
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$Dispatcher.toString()
            --> am.englet.MethodsStorage$MethodRecord
        toString()
            --> am.englet.MethodsStorage$Dispatcher.records
            --> am.englet.MethodsStorage$MethodRecord
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
    MethodsStorage$Getter
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
        <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.Utils$7.convert(java.lang.Object)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils$9.convert(java.lang.Object)
        --> java.io.Serializable *
        --> java.lang.Object *
        MethodsStorage$Getter(java.lang.String)
            --> am.englet.MethodsStorage$Getter.varname
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> java.lang.Object.Object() *
            --> java.lang.String *
        serialVersionUID
        toString()
            --> am.englet.MethodsStorage$Getter.varname
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        varname
            <-- am.englet.MethodsStorage$Getter.MethodsStorage$Getter(java.lang.String)
            <-- am.englet.MethodsStorage$Getter.toString()
            <-- am.englet.MethodsStorage$Getter.varname()
            --> java.lang.String *
        varname()
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage$Getter.varname
            <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.Utils$7.convert(java.lang.Object)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            <-- am.englet.Utils$9.convert(java.lang.Object)
            --> java.lang.String *
    MethodsStorage$MethodRecord
        --> am.englet.Invokable
        <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.MethodsStorage$Dispatcher.MethodsStorage$Dispatcher()
        <-- am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.MethodsStorage$Dispatcher.getMaxArgsCount()
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage$Dispatcher.records
        <-- am.englet.MethodsStorage$Dispatcher.toString()
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
        --> am.englet.dispatch.DispatcherRecord
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        --> java.lang.Object *
        MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.returnType()
            --> am.englet.Invokable.targetType()
            <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
            <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            --> am.englet.MethodsStorage$MethodRecord.argTypes
            --> am.englet.MethodsStorage$MethodRecord.argsCount
            --> am.englet.MethodsStorage$MethodRecord.isStatic
            --> am.englet.MethodsStorage$MethodRecord.isVoid
            --> am.englet.MethodsStorage$MethodRecord.method
            --> am.englet.MethodsStorage$MethodRecord.nonSingletonArgCount
            --> am.englet.MethodsStorage$MethodRecord.nonSingletonArgTypes
            --> am.englet.MethodsStorage$MethodRecord.resultType
            --> am.englet.MethodsStorage$MethodRecord.targetType
            --> am.englet.MethodsStorage$MethodRecord.type
            --> am.englet.MethodsStorage.class$0
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Class[] *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.Void.TYPE *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.toArray(java.lang.Object[]) *
        argTypes
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.argTypes()
            --> java.lang.Class *
        argTypes()
            --> am.englet.MethodsStorage$MethodRecord.argTypes
            --> am.englet.MethodsStorage$MethodRecord.copy(java.lang.Class[])
            --> java.lang.Class *
        argsCount
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        copy(java.lang.Class[])
            <-- am.englet.MethodsStorage$MethodRecord.argTypes()
            <-- am.englet.MethodsStorage$MethodRecord.getParameterTypes()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
        createInvocableImplInstance(java.lang.Object)
            --> am.englet.Invokable
            --> java.lang.Object *
        getMethod()
            --> am.englet.Invokable
            <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
            --> am.englet.MethodsStorage$MethodRecord.method
        getParameterTypes()
            <-- am.englet.MethodsStorage$1.compare(java.lang.Object, java.lang.Object)
            --> am.englet.MethodsStorage$MethodRecord.copy(java.lang.Class[])
            --> am.englet.MethodsStorage$MethodRecord.nonSingletonArgTypes
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        getParametersCount()
            <-- am.englet.MethodsStorage$Dispatcher.getMaxArgsCount()
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            --> am.englet.MethodsStorage$MethodRecord.nonSingletonArgCount
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.MethodsStorage$MethodRecord.method
            --> am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            --> am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.reflect.InvocationTargetException *
        isImmediate()
            --> am.englet.MethodsStorage$MethodRecord.type
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        isProcessing()
            --> am.englet.MethodsStorage$MethodRecord.type
        isStatic
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.isStatic()
        isStatic()
            --> am.englet.MethodsStorage$MethodRecord.isStatic
        isVoid
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        method
            --> am.englet.Invokable
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.getMethod()
            <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.MethodsStorage$MethodRecord.parameterTypes()
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage$MethodRecord.returnType()
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        nonSingletonArgCount
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.getParametersCount()
        nonSingletonArgTypes
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.getParameterTypes()
            --> java.lang.Class *
        parameterTypes()
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.MethodsStorage$MethodRecord.method
            --> java.lang.Class *
        reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            --> am.englet.Invokable
            <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.MethodsStorage$MethodRecord.method
            --> am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
            --> java.lang.Throwable.printStackTrace(java.io.PrintStream) *
        resultType
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> java.lang.Class *
        returnType()
            --> am.englet.Invokable
            --> am.englet.Invokable.returnType()
            --> am.englet.MethodsStorage$MethodRecord.method
            --> java.lang.Class *
        targetType
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.targetType()
            --> java.lang.Class *
        targetType()
            --> am.englet.MethodsStorage$MethodRecord.targetType
            --> java.lang.Class *
        toString()
            --> am.englet.Invokable
            --> am.englet.MethodsStorage$MethodRecord$Type.toString(int)
            --> am.englet.MethodsStorage$MethodRecord.method
            --> am.englet.MethodsStorage$MethodRecord.type
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        type
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$MethodRecord.isImmediate()
            <-- am.englet.MethodsStorage$MethodRecord.isProcessing()
            <-- am.englet.MethodsStorage$MethodRecord.toString()
    MethodsStorage$MethodRecord$InvokableMetadata
        <-- am.englet.MethodInvokableMetadata
        <-- am.englet.bsh.MethodInvokableMetadata
        --> java.lang.Object *
        invokable()
            --> am.englet.Invokable
    MethodsStorage$MethodRecord$Type
        --> java.lang.Object *
        IMMEDIATE
        MANAGEMENT
        MethodsStorage$MethodRecord$Type()
            --> java.lang.Object.Object() *
        PROCESSING
        toString(int)
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            --> java.lang.String *
    MethodsStorage$Training
        <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.retain()
        <-- am.englet.MethodsStorage.train()
        <-- am.englet.MethodsStorage.trained()
        <-- am.englet.MethodsStorage.training
        --> java.io.Serializable *
        --> java.lang.Object *
        MethodsStorage$Training()
            --> am.englet.MethodsStorage$Training.data
            <-- am.englet.MethodsStorage.train()
            --> java.lang.Object.Object() *
            --> java.util.ArrayList *
            --> java.util.ArrayList.ArrayList() *
        data
            <-- am.englet.MethodsStorage$Training.MethodsStorage$Training()
            <-- am.englet.MethodsStorage$Training.data()
            <-- am.englet.MethodsStorage$Training.direct(java.lang.Object)
            <-- am.englet.MethodsStorage$Training.retain()
            <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            --> java.util.ArrayList *
        data()
            --> am.englet.MethodsStorage$Training$Invocation
            --> am.englet.MethodsStorage$Training$Invocation.clone()
            --> am.englet.MethodsStorage$Training$Invocation[] *
            --> am.englet.MethodsStorage$Training.data
            --> java.lang.CloneNotSupportedException *
            --> java.lang.CloneNotSupportedException.printStackTrace() *
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.toArray(java.lang.Object[]) *
        direct(java.lang.Object)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.MethodsStorage$Training.data
            <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.add(java.lang.Object) *
        retain()
            --> am.englet.MethodsStorage$Training.data
            <-- am.englet.MethodsStorage.retain()
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.add(java.lang.Object) *
        serialVersionUID
        step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.Invokable
            --> am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            --> am.englet.MethodsStorage$Training.data
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            --> java.lang.Object *
            --> java.util.ArrayList *
            --> java.util.ArrayList.add(java.lang.Object) *
    MethodsStorage$Training$Invocation
        <-- am.englet.MethodsStorage$Training.data()
        --> java.io.Serializable *
        --> java.lang.Cloneable *
        --> java.lang.Object *
        MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            --> am.englet.ArgumentProvider$ArgumentsAndTarget
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.arguments()
            --> am.englet.ArgumentProvider$ArgumentsAndTarget.target()
            --> am.englet.Invokable
            --> am.englet.MethodsStorage$Training$Invocation.arguments
            --> am.englet.MethodsStorage$Training$Invocation.invokable
            --> am.englet.MethodsStorage$Training$Invocation.result
            --> am.englet.MethodsStorage$Training$Invocation.target
            <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.System.identityHashCode(java.lang.Object) *
        arguments
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.MethodsStorage$Training$Invocation.clone()
        clone()
            --> I[] *
            --> am.englet.MethodsStorage$Training$Invocation.arguments
            <-- am.englet.MethodsStorage$Training.data()
            --> java.lang.CloneNotSupportedException *
            --> java.lang.Object *
            --> java.lang.Object.clone() *
        invokable
            --> am.englet.Invokable
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        result
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        target
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
    MethodsStorage$Training$Invocation[] *
        <-- am.englet.MethodsStorage$Training.data()
    MultiplySliderImpl
        --> am.englet.CallStackSliderImpl
        MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.CallStackSliderImpl.CallStackSliderImpl()
            <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
            --> am.englet.MultiplySliderImpl.each
            --> am.englet.MultiplySliderImpl.through
            <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
            <-- am.englet.TestUtils0.times0(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
        each
            <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.MultiplySliderImpl.restart()
            --> am.englet.link.Link
        restart()
            --> am.englet.MultiplySliderImpl.each
            --> am.englet.MultiplySliderImpl.start(am.englet.link.Link) *
            --> am.englet.MultiplySliderImpl.through
            <-- am.englet.MultiplySliderImpl.tryNext()
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider
            --> am.englet.link.backadapters.slider.LinkSlider.content()
            --> java.lang.Object *
        start(am.englet.link.Link) *
            <-- am.englet.MultiplySliderImpl.restart()
        through
            <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.MultiplySliderImpl.restart()
            <-- am.englet.MultiplySliderImpl.tryNext()
            --> am.englet.link.backadapters.slider.LinkSlider
        tryNext()
            --> am.englet.CallStackSliderImpl.tryNext()
            --> am.englet.MultiplySliderImpl.restart()
            --> am.englet.MultiplySliderImpl.through
            --> am.englet.link.backadapters.slider.LinkSlider
            --> am.englet.link.backadapters.slider.LinkSlider.tryNext()
    Processing
        --> java.lang.Object *
        CR
        LF
        METHOD_NAME_REPLACEMENTS
            --> java.lang.String *
        Processing()
            --> java.lang.Object.Object() *
        appendCleanBytes(java.lang.StringBuffer, java.lang.String)
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
            <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
            --> java.lang.String *
            --> java.lang.String.toCharArray() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(char) *
        appendToFile(byte[], java.lang.String)
            --> am.englet.Processing.toFile(byte[], java.lang.String, boolean)
            --> java.lang.Exception *
            --> java.lang.String *
        appendToFile(java.lang.CharSequence, java.lang.String)
            --> am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            --> java.lang.CharSequence *
            --> java.lang.Exception *
            --> java.lang.String *
        as_linked_list(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
            --> java.util.LinkedList.LinkedList() *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        as_list(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.ArrayList.add(java.lang.Object) *
            --> java.util.List *
        as_list(byte[])
            --> am.englet.Processing.wrap(java.lang.Object)
            --> java.lang.Object *
            --> java.util.List *
        as_list(char[])
            --> am.englet.Processing.wrap(java.lang.Object)
            --> java.lang.Object *
            --> java.util.List *
        chr(int)
            --> java.lang.Exception *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
        condReplace(java.lang.StringBuffer, java.lang.String, int, int)
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
        copy(am.englet.link.Link)
            --> am.englet.Utils.lazy(am.englet.link.Link)
            --> am.englet.link.Link
        fromBytes(byte[], java.lang.String)
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.String.String(byte[], java.lang.String) *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
        fromBytes(java.lang.String, java.lang.String)
            --> am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.String.String(byte[], java.lang.String) *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.String) *
        fromClip()
            --> am.englet.Utils.getClipString()
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
        fromFile(java.io.File)
            <-- am.englet.Processing.fromFile(java.lang.String)
            --> am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
            --> java.io.File *
            --> java.io.FileInputStream.FileInputStream(java.io.File) *
            --> java.io.FileInputStream.close() *
            --> java.io.FileNotFoundException *
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.lang.StringBuffer *
        fromFile(java.lang.String)
            --> am.englet.Processing.fromFile(java.io.File)
            --> java.io.File *
            --> java.io.File.File(java.lang.String) *
            --> java.io.InputStream *
            --> java.io.InputStream.read() *
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.System.in *
        fromFileo(java.io.File)
            <-- am.englet.Processing.fromFileo(java.lang.String)
            --> java.io.File *
            --> java.io.FileInputStream.FileInputStream(java.io.File) *
            --> java.io.FileInputStream.close() *
            --> java.io.FileNotFoundException *
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.io.ObjectInputStream.ObjectInputStream(java.io.InputStream) *
            --> java.io.ObjectInputStream.readObject() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Object *
        fromFileo(java.lang.String)
            --> am.englet.Processing.fromFileo(java.io.File)
            --> java.io.File *
            --> java.io.File.File(java.lang.String) *
            --> java.io.FileNotFoundException *
            --> java.io.IOException *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Object *
            --> java.lang.String *
        fromUrl(java.lang.String)
            --> am.englet.Utils.suckThru(byte[], java.io.InputStream)
            --> java.io.InputStream *
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.net.URL.URL(java.lang.String) *
            --> java.net.URL.openStream() *
        gotted(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.DataStack.sub(int)
            --> am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
            --> am.englet.link.Link
            --> java.util.Map *
        gotted(am.englet.link.Link, java.util.Map)
            <-- am.englet.Processing.gotted(am.englet.link.Link, am.englet.DataStack)
            <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
            --> am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            --> am.englet.Processing.reverse(am.englet.link.Link)
            --> am.englet.link.Link
            --> java.util.Map *
        join(am.englet.link.Link, am.englet.VariablesStorage)
            --> am.englet.Processing.join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
            --> am.englet.VariablesStorage
            --> am.englet.link.Link
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.toString() *
        join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
            <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
            --> am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> am.englet.VariablesStorage
            --> am.englet.link.Link
            --> java.lang.StringBuffer *
        loop(am.englet.link.Link)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.Processing$1.Processing$1(am.englet.link.Link)
            --> am.englet.link.Link
        part(java.lang.CharSequence, java.lang.String, int, int)
            --> am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.length() *
            --> java.lang.CharSequence.subSequence(int, int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
        partLink(java.lang.CharSequence, java.lang.String, int, int)
            --> am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            --> am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.Link
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.length() *
            --> java.lang.CharSequence.subSequence(int, int) *
            --> java.lang.CharSequence.toString() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
        prcess(java.lang.Object, java.util.Map)
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            --> am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
            <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
            --> java.util.Map.get(java.lang.Object) *
        pump(java.io.InputStream, java.io.OutputStream)
            --> am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
            --> java.io.InputStream *
            --> java.io.OutputStream *
        replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            --> am.englet.Processing.condReplace(java.lang.StringBuffer, java.lang.String, int, int)
            --> am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
            --> am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.indexOf(java.lang.String) *
            --> java.lang.StringBuffer.indexOf(java.lang.String, int) *
            --> java.lang.StringBuffer.lastIndexOf(java.lang.String) *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
        replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.lastIndexOf(java.lang.String) *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
        replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.indexOf(java.lang.String) *
            --> java.lang.StringBuffer.replace(int, int, java.lang.String) *
        resetToFalse(java.lang.StringBuffer, int)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.setLength(int) *
        revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            <-- am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
            --> am.englet.Processing.prcess(java.lang.Object, java.util.Map)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
            --> java.util.Map *
        reverse(am.englet.link.Link)
            <-- am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        slide(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.Link
        slide(java.lang.Object[])
            --> am.englet.Processing.slide(java.util.Collection)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.List *
        slide(java.util.Collection)
            <-- am.englet.Processing.slide(java.lang.Object[])
            <-- am.englet.Processing.slide(java.util.Map)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.Link
            --> am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.SimpleLinkFactory.instance()
            --> am.englet.link.backadapters.IteratorAdapter.IteratorAdapter(java.util.Iterator)
            --> am.englet.link.backadapters.IteratorStrategy
            --> am.englet.link.backadapters.IteratorStrategy.INSTANCE
            --> java.util.Collection *
            --> java.util.Collection.iterator() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
        slide(java.util.Map)
            --> am.englet.Processing.slide(java.util.Collection)
            --> am.englet.link.Link
            --> java.util.Collection *
            --> java.util.Map *
            --> java.util.Map.entrySet() *
            --> java.util.Set *
        suckThru(java.io.File, java.io.InputStream)
            <-- am.englet.Processing.fromFile(java.io.File)
            --> am.englet.Utils.suckThru(byte[], java.io.InputStream)
            --> java.io.File *
            --> java.io.File.length() *
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.lang.StringBuffer *
        toBytes(java.lang.String, java.lang.String)
            --> am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.String.getBytes(java.lang.String) *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
        toClip(java.lang.String)
            --> am.englet.Utils.getClipboard()
            --> java.awt.datatransfer.Clipboard *
            --> java.awt.datatransfer.Clipboard.setContents(java.awt.datatransfer.Transferable, java.awt.datatransfer.ClipboardOwner) *
            --> java.awt.datatransfer.ClipboardOwner *
            --> java.awt.datatransfer.StringSelection.StringSelection(java.lang.String) *
            --> java.awt.datatransfer.Transferable *
            --> java.lang.Exception *
            --> java.lang.String *
        toFile(byte[], java.lang.String)
            --> am.englet.Processing.toFile(byte[], java.lang.String, boolean)
            --> java.lang.Exception *
            --> java.lang.String *
        toFile(byte[], java.lang.String, boolean)
            <-- am.englet.Processing.appendToFile(byte[], java.lang.String)
            <-- am.englet.Processing.toFile(byte[], java.lang.String)
            --> am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
            --> am.englet.Processing.toFileOpen(java.lang.String, boolean)
            --> java.io.FileNotFoundException *
            --> java.io.IOException *
            --> java.io.OutputStream *
            --> java.io.OutputStream.write(byte[], int, int) *
            --> java.lang.String *
        toFile(java.lang.CharSequence, java.lang.String)
            --> am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            --> java.lang.CharSequence *
            --> java.lang.Exception *
            --> java.lang.String *
        toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.Processing.appendToFile(java.lang.CharSequence, java.lang.String)
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String)
            --> am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
            --> am.englet.Processing.toFileOpen(java.lang.String, boolean)
            --> java.io.FileNotFoundException *
            --> java.io.IOException *
            --> java.io.OutputStream *
            --> java.io.OutputStream.write(byte[], int, int) *
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.charAt(int) *
            --> java.lang.CharSequence.length() *
            --> java.lang.String *
        toFileClose(java.lang.String, java.io.OutputStream)
            <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
            --> java.io.IOException *
            --> java.io.OutputStream *
            --> java.io.OutputStream.close() *
            --> java.io.OutputStream.flush() *
            --> java.lang.String *
            --> java.lang.String.length() *
        toFileOpen(java.lang.String, boolean)
            <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
            --> java.io.FileNotFoundException *
            --> java.io.FileOutputStream.FileOutputStream(java.lang.String, boolean) *
            --> java.io.OutputStream *
            --> java.io.PrintStream *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.System.out *
        toFileo(java.lang.Object, java.lang.String)
            --> am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
            --> am.englet.Processing.toFileOpen(java.lang.String, boolean)
            --> java.io.ObjectOutputStream.ObjectOutputStream(java.io.OutputStream) *
            --> java.io.ObjectOutputStream.flush() *
            --> java.io.ObjectOutputStream.writeObject(java.lang.Object) *
            --> java.io.OutputStream *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
        tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> am.englet.MethodsStorage$Direct
            --> am.englet.MethodsStorage$Direct.getContent()
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            <-- am.englet.Processing.join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
            --> am.englet.Processing.resetToFalse(java.lang.StringBuffer, int)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.get(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.LinkSlider.content()
            --> am.englet.link.backadapters.slider.LinkSlider.tryNext()
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.length() *
        wrap(java.lang.Object)
            --> am.englet.Processing$2.Processing$2(java.lang.Object)
            <-- am.englet.Processing.as_list(byte[])
            <-- am.englet.Processing.as_list(char[])
            --> java.lang.Object *
            --> java.util.List *
    Processing$1
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        Processing$1(am.englet.link.Link)
            --> am.englet.Processing$1.curr
            --> am.englet.Processing$1.val$l
            <-- am.englet.Processing.loop(am.englet.link.Link)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        curr
            <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
            <-- am.englet.Processing$1.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        tryNextContent()
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> am.englet.Processing$1.curr
            --> am.englet.Processing$1.val$l
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$l
            <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
            <-- am.englet.Processing$1.tryNextContent()
            --> am.englet.link.Link
    Processing$2
        --> java.util.AbstractList *
        Processing$2(java.lang.Object)
            --> am.englet.Processing$2.val$arr
            <-- am.englet.Processing.wrap(java.lang.Object)
            --> java.lang.Object *
            --> java.util.AbstractList.AbstractList() *
        get(int)
            <-- am.englet.Processing$2.set(int, java.lang.Object)
            --> am.englet.Processing$2.val$arr
            --> java.lang.Object *
            --> java.lang.reflect.Array.get(java.lang.Object, int) *
        set(int, java.lang.Object)
            --> am.englet.Processing$2.get(int)
            --> am.englet.Processing$2.val$arr
            --> java.lang.Object *
            --> java.lang.reflect.Array.set(java.lang.Object, int, java.lang.Object) *
        size()
            --> am.englet.Processing$2.val$arr
            --> java.lang.Object *
            --> java.lang.reflect.Array.getLength(java.lang.Object) *
        val$arr
            <-- am.englet.Processing$2.Processing$2(java.lang.Object)
            <-- am.englet.Processing$2.get(int)
            <-- am.englet.Processing$2.set(int, java.lang.Object)
            <-- am.englet.Processing$2.size()
            --> java.lang.Object *
    ResultHandler
        <-- am.englet.Englet
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        --> am.englet.ServiceObject
        --> java.lang.Object *
        handleResult(java.lang.Object)
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> java.lang.Object *
    ResultList
        <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
        <-- am.englet.DataStack.peekResultList()
        <-- am.englet.DataStack.peekResultList(int)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
        <-- am.englet.TestUtils0.head(am.englet.link.Link)
        <-- am.englet.TestUtils0.isLink(java.lang.Object)
        <-- am.englet.TestUtils0.tail(am.englet.link.Link)
        <-- am.englet.TestUtils0.xor(am.englet.link.Link)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        --> java.lang.Object *
        ResultList(java.lang.Object[])
            <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
            --> am.englet.ResultList.content
            <-- am.englet.TestUtils0.head(am.englet.link.Link)
            <-- am.englet.TestUtils0.isLink(java.lang.Object)
            <-- am.englet.TestUtils0.tail(am.englet.link.Link)
            <-- am.englet.TestUtils0.xor(am.englet.link.Link)
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        ResultList(java.util.List)
            <-- am.englet.DataStack.peekResultList()
            --> am.englet.ResultList.content
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.List *
            --> java.util.List.toArray() *
        ResultList(java.util.List, int)
            <-- am.englet.DataStack.peekResultList(int)
            --> am.englet.ResultList.content
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.List *
            --> java.util.List.size() *
            --> java.util.List.subList(int, int) *
            --> java.util.List.toArray() *
        appendTo(java.util.List)
            <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
            --> am.englet.ResultList.content
            --> am.englet.Utils.correctValue(java.lang.Object)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        content
            <-- am.englet.ResultList.ResultList(java.lang.Object[])
            <-- am.englet.ResultList.ResultList(java.util.List)
            <-- am.englet.ResultList.ResultList(java.util.List, int)
            <-- am.englet.ResultList.appendTo(java.util.List)
            <-- am.englet.ResultList.content()
            --> java.lang.Object *
        content()
            --> am.englet.ResultList.content
            <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Object *
    ServiceObject
        <-- am.englet.ArgumentProvider
        <-- am.englet.CastingContext
        <-- am.englet.CommandSource
        <-- am.englet.DataStack
        <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
        <-- am.englet.MethodsStorage
        <-- am.englet.ResultHandler
        <-- am.englet.ServiceTokenizerFactory
        <-- am.englet.SingletonPool
        <-- am.englet.VariablesStorage
        <-- am.englet.cast.ClassPool
        <-- am.englet.cast.SameObjectCasterProvider
        <-- am.englet.wiring.BeanPool
        --> java.lang.Object *
    ServiceTokenizerFactory
        <-- am.englet.Englet.getParserFactory()
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.EngletParserReaderTokenizerFactory
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        --> am.englet.ServiceObject
        --> am.englet.TokenizerFactory
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.FACTORY
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
        --> java.lang.Object *
    SimpleCastingContext
        --> am.englet.CastingContext
        --> java.lang.Object *
        NUMBER_CASTERS
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.static {}
            --> java.util.Map *
        SimpleCastingContext()
            --> java.lang.Object.Object() *
        canCast(java.lang.Class, java.lang.Class)
            --> am.englet.SimpleCastingContext.class$1
            --> am.englet.SimpleCastingContext.class$2
            --> am.englet.SimpleCastingContext.class$3
            --> am.englet.SimpleCastingContext.class$4
            --> am.englet.SimpleCastingContext.class$5
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
            --> java.io.PrintStream *
            --> java.lang.Boolean *
            --> java.lang.Boolean.TYPE *
            --> java.lang.Boolean.valueOf(boolean) *
            --> java.lang.Byte.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getComponentType() *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.lang.Throwable.getMessage() *
        cast(java.lang.Class, java.lang.Object)
            --> am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.Object *
        class$0
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Class *
        class$2
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
        class$3
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
        class$4
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
        class$5
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        class$6
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
        class$7
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Class *
        doCast(java.lang.Class, java.lang.Object)
            --> am.englet.SimpleCastingContext$NumberCaster
            --> am.englet.SimpleCastingContext$NumberCaster.cast(java.lang.Number)
            --> am.englet.SimpleCastingContext.NUMBER_CASTERS
            <-- am.englet.SimpleCastingContext.cast(java.lang.Class, java.lang.Object)
            --> am.englet.SimpleCastingContext.class$1
            --> am.englet.SimpleCastingContext.class$2
            --> am.englet.SimpleCastingContext.class$3
            --> am.englet.SimpleCastingContext.class$4
            --> am.englet.SimpleCastingContext.class$6
            --> am.englet.SimpleCastingContext.class$7
            --> am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            --> am.englet.SimpleCastingContext.toCharSequence(java.lang.Object)
            --> am.englet.SimpleCastingContext.toInt(java.lang.Number)
            --> am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
            --> am.englet.cast.CastException.CastException(java.lang.String)
            --> java.lang.Boolean *
            --> java.lang.Boolean.valueOf(boolean) *
            --> java.lang.CharSequence *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.Integer *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Throwable.getMessage() *
            --> java.math.BigDecimal *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
            --> am.englet.SimpleCastingContext$NumberCaster
            <-- am.englet.SimpleCastingContext.static {}
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        static {}
            --> am.englet.SimpleCastingContext$1.SimpleCastingContext$1()
            --> am.englet.SimpleCastingContext$2.SimpleCastingContext$2()
            --> am.englet.SimpleCastingContext$3.SimpleCastingContext$3()
            --> am.englet.SimpleCastingContext$4.SimpleCastingContext$4()
            --> am.englet.SimpleCastingContext$5.SimpleCastingContext$5()
            --> am.englet.SimpleCastingContext$6.SimpleCastingContext$6()
            --> am.englet.SimpleCastingContext$7.SimpleCastingContext$7()
            --> am.englet.SimpleCastingContext$8.SimpleCastingContext$8()
            --> am.englet.SimpleCastingContext$NumberCaster
            --> am.englet.SimpleCastingContext.NUMBER_CASTERS
            --> am.englet.SimpleCastingContext.class$0
            --> am.englet.SimpleCastingContext.class$1
            --> am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
            --> java.lang.Byte.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Short.TYPE *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        toBigDecimal(java.lang.Object)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Double *
            --> java.lang.Double.doubleValue() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.BigDecimal(double) *
            --> java.math.BigDecimal.BigDecimal(java.lang.String) *
        toCharSequence(java.lang.Object)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.CharSequence *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        toInt(java.lang.Number)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Integer *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
        toStringBuffer(java.lang.Object)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
    SimpleCastingContext$1
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$1()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
            --> java.lang.Object *
    SimpleCastingContext$2
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$2()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Long.Long(long) *
            --> java.lang.Number *
            --> java.lang.Number.longValue() *
            --> java.lang.Object *
    SimpleCastingContext$3
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$3()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Byte.Byte(byte) *
            --> java.lang.Number *
            --> java.lang.Number.byteValue() *
            --> java.lang.Object *
    SimpleCastingContext$4
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$4()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Number *
            --> java.lang.Number.shortValue() *
            --> java.lang.Object *
            --> java.lang.Short.Short(short) *
    SimpleCastingContext$5
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$5()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Float.Float(float) *
            --> java.lang.Number *
            --> java.lang.Number.floatValue() *
            --> java.lang.Object *
    SimpleCastingContext$6
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$6()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Double.Double(double) *
            --> java.lang.Number *
            --> java.lang.Number.doubleValue() *
            --> java.lang.Object *
    SimpleCastingContext$7
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$7()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Number *
            --> java.lang.Number.longValue() *
            --> java.lang.Object *
            --> java.math.BigInteger *
            --> java.math.BigInteger.valueOf(long) *
    SimpleCastingContext$8
        --> am.englet.SimpleCastingContext$NumberCaster
        --> java.lang.Object *
        SimpleCastingContext$8()
            <-- am.englet.SimpleCastingContext.static {}
            --> java.lang.Object.Object() *
        cast(java.lang.Number)
            --> java.lang.Number *
            --> java.lang.Number.doubleValue() *
            --> java.lang.Object *
            --> java.math.BigDecimal.BigDecimal(double) *
    SimpleCastingContext$NumberCaster
        <-- am.englet.SimpleCastingContext$1
        <-- am.englet.SimpleCastingContext$2
        <-- am.englet.SimpleCastingContext$3
        <-- am.englet.SimpleCastingContext$4
        <-- am.englet.SimpleCastingContext$5
        <-- am.englet.SimpleCastingContext$6
        <-- am.englet.SimpleCastingContext$7
        <-- am.englet.SimpleCastingContext$8
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
        <-- am.englet.SimpleCastingContext.static {}
        --> java.lang.Object *
        cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.Number *
            --> java.lang.Object *
    SimpleStringArrayEngletSettings
        --> am.englet.EngletSettings
        --> java.lang.Object *
        SimpleStringArrayEngletSettings()
            --> am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            --> am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.lang.String *
            --> java.util.Properties *
        SimpleStringArrayEngletSettings(java.lang.String[])
            <-- am.englet.Main.getSettings(java.lang.String[])
            --> am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            --> am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.lang.String *
            --> java.util.Properties *
        SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings()
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[])
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.util.Properties)
            --> am.englet.SimpleStringArrayEngletSettings.args
            --> am.englet.SimpleStringArrayEngletSettings.props
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.util.Properties *
        SimpleStringArrayEngletSettings(java.util.Properties)
            --> am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            --> java.lang.String *
            --> java.util.Properties *
        adaptClasses(am.englet.Englet, java.lang.String)
            --> am.englet.Englet
            --> am.englet.Englet.getMethods()
            --> am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            --> am.englet.SimpleStringArrayEngletSettings.class$0
            --> am.englet.cast.ClassPool
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String) *
            --> java.util.StringTokenizer.hasMoreTokens() *
            --> java.util.StringTokenizer.nextToken() *
        adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            --> am.englet.Englet
            --> am.englet.Englet.getMethods()
            --> am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            --> am.englet.MethodsStorage
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.String *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String, java.lang.String) *
            --> java.util.StringTokenizer.hasMoreTokens() *
            --> java.util.StringTokenizer.nextToken() *
        adaptMethods(am.englet.Englet, java.lang.String)
            --> am.englet.Englet
            --> am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            --> java.lang.String *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String, java.lang.String) *
            --> java.util.StringTokenizer.hasMoreElements() *
            --> java.util.StringTokenizer.nextToken() *
        apply(am.englet.Englet)
            --> am.englet.Englet
            --> am.englet.Englet.debug
            --> am.englet.Englet.parse(java.lang.String)
            --> am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            --> am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            --> am.englet.SimpleStringArrayEngletSettings.args
            --> am.englet.SimpleStringArrayEngletSettings.getPre()
            --> am.englet.SimpleStringArrayEngletSettings.props
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Boolean.valueOf(java.lang.String) *
            --> java.lang.Exception *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Properties *
            --> java.util.Properties.getProperty(java.lang.String, java.lang.String) *
        args
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            --> java.lang.String *
        class$0
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            --> java.lang.Class *
        class$1
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.lang.Class *
        getPre()
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            --> am.englet.SimpleStringArrayEngletSettings.props
            --> java.lang.String *
            --> java.util.Properties *
            --> java.util.Properties.getProperty(java.lang.String, java.lang.String) *
        getProperties()
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings()
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[])
            --> am.englet.SimpleStringArrayEngletSettings.class$1
            --> am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
            --> am.englet.SimpleStringArrayEngletSettings.propsFile()
            --> am.englet.SimpleStringArrayEngletSettings.propsURLInput()
            --> java.io.File *
            --> java.io.FileInputStream.FileInputStream(java.io.File) *
            --> java.io.InputStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getResourceAsStream(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.System.getProperties() *
            --> java.lang.Throwable.getMessage() *
            --> java.net.URL *
            --> java.net.URL.openStream() *
            --> java.util.Properties *
            --> java.util.Properties.Properties(java.util.Properties) *
        props
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.SimpleStringArrayEngletSettings.getPre()
            --> java.util.Properties *
        props(java.io.InputStream)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.lang.System.getProperties() *
            --> java.util.Properties *
            --> java.util.Properties.Properties(java.util.Properties) *
            --> java.util.Properties.load(java.io.InputStream) *
        propsFile()
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.io.File *
            --> java.io.File.File(java.lang.String) *
            --> java.io.File.canRead() *
            --> java.io.File.exists() *
            --> java.lang.String *
            --> java.lang.System.getProperty(java.lang.String) *
        propsURLInput()
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            --> java.io.IOException *
            --> java.lang.String *
            --> java.lang.System.getProperty(java.lang.String) *
            --> java.net.URL *
            --> java.net.URL.URL(java.lang.String) *
    SingletonPool
        <-- am.englet.Englet
        <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
        --> am.englet.ServiceObject
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.singletonPool
        <-- am.englet.wiring.PoolsBuilder.wire()
        --> java.lang.Object *
        DERIVED_FROM
            --> java.lang.String *
        SINGLETON_IMPLEMENTATIONS_PROPERTIES
            --> java.lang.String *
        derivationMap
            <-- am.englet.SingletonPool.static {}
            --> java.util.Map *
        findImplementation(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
        getSingleton(java.lang.Class)
            <-- am.englet.Englet.run()
            <-- am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            --> java.lang.Class *
            --> java.lang.Object *
        implMap
            <-- am.englet.SingletonPool.static {}
            --> java.util.Map *
        putSingleton(java.lang.Object)
            --> java.lang.Object *
        putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Class *
            --> java.lang.Object *
        static {}
            --> am.englet.SingletonPool$util.derivationMap
            --> am.englet.SingletonPool$util.implMap
            --> am.englet.SingletonPool.derivationMap
            --> am.englet.SingletonPool.implMap
            --> java.util.Map *
    SingletonPool$1
        --> java.util.HashMap *
        SingletonPool$1()
            --> am.englet.SingletonPool$1.put(java.lang.Object, java.lang.Object) *
            --> am.englet.SingletonPool$util.access$0()
            --> am.englet.SingletonPool$util.access$1(java.lang.String)
            --> am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$util.static {}
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.endsWith(java.lang.String) *
            --> java.lang.System.out *
            --> java.util.Enumeration *
            --> java.util.Enumeration.hasMoreElements() *
            --> java.util.Enumeration.nextElement() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Properties *
            --> java.util.Properties.getProperty(java.lang.String) *
            --> java.util.Properties.propertyNames() *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.SingletonPool$1.SingletonPool$1()
        serialVersionUID
    SingletonPool$2
        --> java.util.HashMap *
        SingletonPool$2()
            --> am.englet.SingletonPool$2.put(java.lang.Object, java.lang.Object) *
            --> am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
            --> am.englet.SingletonPool$util.access$0()
            --> am.englet.SingletonPool$util.access$1(java.lang.String)
            --> am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$util.static {}
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.getMethod(java.lang.String, java.lang.Class[]) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.endsWith(java.lang.String) *
            --> java.lang.String.length() *
            --> java.lang.String.split(java.lang.String) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.System.out *
            --> java.lang.reflect.Method *
            --> java.util.Enumeration *
            --> java.util.Enumeration.hasMoreElements() *
            --> java.util.Enumeration.nextElement() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Properties *
            --> java.util.Properties.getProperty(java.lang.String) *
            --> java.util.Properties.propertyNames() *
        put(java.lang.Object, java.lang.Object) *
            <-- am.englet.SingletonPool$2.SingletonPool$2()
        serialVersionUID
    SingletonPool$Derivation
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        --> java.lang.Object *
        SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            --> am.englet.SingletonPool$Derivation.clasz
            --> am.englet.SingletonPool$Derivation.method
            --> java.lang.Class *
            --> java.lang.Object.Object() *
            --> java.lang.reflect.Method *
        clasz
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
            <-- am.englet.SingletonPool$Derivation.toString()
            --> java.lang.Class *
        method
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
            <-- am.englet.SingletonPool$Derivation.toString()
            --> java.lang.reflect.Method *
        toString()
            --> am.englet.SingletonPool$Derivation.clasz
            --> am.englet.SingletonPool$Derivation.method
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Method *
    SingletonPool$util
        --> java.lang.Object *
        SingletonPool$util()
            --> java.lang.Object.Object() *
        access$0()
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            --> am.englet.SingletonPool$util.sImpls()
            --> java.util.Properties *
        access$1(java.lang.String)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            --> am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
            --> java.lang.Class *
            --> java.lang.ClassNotFoundException *
            --> java.lang.String *
        access$2(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            --> am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.ClassNotFoundException *
            --> java.lang.String *
        derivationMap
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.SingletonPool$util.static {}
            <-- am.englet.SingletonPool.static {}
            --> java.util.Map *
        getAssigneeClass(java.lang.String)
            <-- am.englet.SingletonPool$util.access$1(java.lang.String)
            --> am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        getClass(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getPackage() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Object *
            --> java.lang.Package *
            --> java.lang.Package.getName() *
            --> java.lang.String *
            --> java.lang.String.indexOf(int) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        implMap
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.SingletonPool$util.static {}
            <-- am.englet.SingletonPool.static {}
            --> java.util.Map *
        sImpls()
            <-- am.englet.SingletonPool$util.access$0()
            --> java.io.IOException *
            --> java.io.IOException.printStackTrace() *
            --> java.io.InputStream *
            --> java.io.InputStream.close() *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getResourceAsStream(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Properties *
            --> java.util.Properties.Properties() *
            --> java.util.Properties.load(java.io.InputStream) *
        static {}
            --> am.englet.SingletonPool$1.SingletonPool$1()
            --> am.englet.SingletonPool$2.SingletonPool$2()
            --> am.englet.SingletonPool$util.derivationMap
            --> am.englet.SingletonPool$util.implMap
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.Map *
    TestUtils0
        --> java.lang.Object *
        BOOLEAN(java.lang.Object)
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> java.lang.Object *
        EXCL_FNAL_LINK
            <-- am.englet.TestUtils0.static {}
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.FinalLink
        FALSE()
        METHOD_NAME_REPLACEMENTS
            --> java.lang.String *
        TRUE()
        TestUtils0()
            --> java.lang.Object.Object() *
        access$0(java.util.regex.Matcher)
            <-- am.englet.TestUtils0$11.tryNextContent()
            <-- am.englet.TestUtils0$12.step()
            --> am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.util.regex.Matcher *
        bigdec(java.lang.Object)
            <-- am.englet.TestUtils0.gt(java.lang.Number, java.lang.Number)
            <-- am.englet.TestUtils0.lt(java.lang.Number, java.lang.Number)
            <-- am.englet.TestUtils0.minus(java.lang.Number, java.lang.Number)
            <-- am.englet.TestUtils0.minus(java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
            --> java.lang.Double *
            --> java.lang.Double.doubleValue() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.BigDecimal(double) *
            --> java.math.BigDecimal.BigDecimal(java.lang.String) *
        class$0
            <-- am.englet.TestUtils0$FS1.tryNext()
            --> java.lang.Class *
        class$1
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            --> java.lang.Class *
        class$2
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            --> java.lang.Class *
        class$3
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            --> java.lang.Class *
        class$4
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            --> java.lang.Class *
        class$5
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            --> java.lang.Class *
        class$6
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            --> java.lang.Class *
        direct(java.lang.Object)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        directPlus(java.lang.Object, am.englet.link.Link)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
        div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Englet
            --> am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            --> am.englet.Links$ValueConverter
            --> am.englet.MethodsStorage
            --> am.englet.TestUtils0$FS1
            --> am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter, am.englet.TestUtils0$FS1)
            --> am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.cast.ClassPool
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
        div(am.englet.link.Link, int)
            --> am.englet.Links.div(am.englet.link.Link, int)
            --> am.englet.link.Link
        div(am.englet.link.Link, java.util.Map)
            --> am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
            --> am.englet.link.Link
            --> java.util.Map *
        div(java.lang.String, java.lang.String)
            --> am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
            --> am.englet.link.Link
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.length() *
        div(java.math.BigDecimal, java.math.BigDecimal)
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.divide(java.math.BigDecimal, int) *
        divL(java.io.InputStream)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.TestUtils0$9.TestUtils0$9(java.io.BufferedReader)
            --> am.englet.link.Link
            --> java.io.BufferedReader *
            --> java.io.BufferedReader.BufferedReader(java.io.Reader) *
            --> java.io.InputStream *
            --> java.io.InputStreamReader.InputStreamReader(java.io.InputStream) *
            --> java.io.Reader *
        dp(java.lang.Object, int, java.util.List)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.set(int, java.lang.Object) *
        dp(java.lang.Object, java.lang.String, java.util.Map)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        dp(java.lang.Object, java.util.Collection)
            --> java.lang.Object *
            --> java.util.Collection *
            --> java.util.Collection.add(java.lang.Object) *
        dp(java.lang.Object, java.util.List, java.util.Map)
            --> am.englet.TestUtils0.class$2
            --> am.englet.TestUtils0.class$3
            --> am.englet.TestUtils0.class$4
            --> am.englet.TestUtils0.class$5
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.Class.newInstance() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.IllegalAccessException *
            --> java.lang.InstantiationException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        equals(byte, byte)
        equals(char, char)
        equals(double, double)
        equals(float, float)
        equals(int, int)
        equals(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        equals(java.math.BigDecimal, java.math.BigDecimal)
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.compareTo(java.math.BigDecimal) *
        equals(java.math.BigInteger, java.math.BigInteger)
            --> java.math.BigInteger *
            --> java.math.BigInteger.compareTo(java.math.BigInteger) *
        equals(long, long)
        equals(short, short)
        extracted3(java.util.regex.Matcher)
            --> am.englet.Links.toLazyChain(java.lang.String[])
            <-- am.englet.TestUtils0.access$0(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.lang.String *
            --> java.util.regex.Matcher *
            --> java.util.regex.Matcher.group(int) *
            --> java.util.regex.Matcher.groupCount() *
        filterLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            --> am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.TestUtils0.nonstaticInvokableBasedCkecker(am.englet.Invokable)
            --> am.englet.TestUtils0.staticInvokableBasedCkecker(am.englet.Invokable)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.link.Link
            --> am.englet.util.Checker
            --> java.lang.Class *
        forLink(int, int)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.TestUtils0$1.TestUtils0$1(int, int)
            --> am.englet.link.Link
        ge(int, int)
        gt(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
        gt(double, double)
        gt(java.io.File)
            --> java.io.File *
            --> java.io.FileInputStream.FileInputStream(java.io.File) *
            --> java.io.FileNotFoundException *
            --> java.io.InputStream *
        gt(java.lang.Comparable, java.lang.Comparable)
            --> java.lang.Comparable *
            --> java.lang.Comparable.compareTo(java.lang.Object) *
            --> java.lang.Object *
        gt(java.lang.Number, java.lang.Number)
            --> am.englet.TestUtils0.bigdec(java.lang.Object)
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.compareTo(java.math.BigDecimal) *
        gt(long, long)
        head(am.englet.link.Link)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.lang.Object[])
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        iif(boolean, java.lang.Object, java.lang.Object)
            --> java.lang.Object *
        iif(java.lang.Object, boolean, java.lang.Object)
            --> java.lang.Object *
        isLink(java.lang.Object)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.lang.Object[])
            --> am.englet.link.Link
            --> java.lang.Boolean.Boolean(boolean) *
            --> java.lang.Object *
        lt(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> java.lang.Object *
        lt(double, double)
        lt(java.io.File)
            --> java.io.File *
            --> java.io.FileNotFoundException *
            --> java.io.FileOutputStream *
            --> java.io.FileOutputStream.FileOutputStream(java.io.File) *
        lt(java.lang.Comparable, java.lang.Comparable)
            --> java.lang.Comparable *
            --> java.lang.Comparable.compareTo(java.lang.Object) *
            --> java.lang.Object *
        lt(java.lang.Number, java.lang.Number)
            --> am.englet.TestUtils0.bigdec(java.lang.Object)
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.compareTo(java.math.BigDecimal) *
        lt(long, long)
        minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.MethodsStorage
            --> am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            --> am.englet.cast.ClassPool
            --> am.englet.link.Link
            --> java.lang.Throwable *
        minus(double, double)
        minus(float, float)
        minus(int, int)
        minus(java.lang.Number, java.lang.Number)
            --> am.englet.TestUtils0.bigdec(java.lang.Object)
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.subtract(java.math.BigDecimal) *
        minus(java.lang.String, java.lang.String)
            --> am.englet.TestUtils0.bigdec(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.subtract(java.math.BigDecimal) *
        minus(long, long)
        nonstaticInvokableBasedCkecker(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$6.TestUtils0$6(am.englet.Invokable)
            <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.util.Checker
        not(boolean)
        or(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        or(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
        plus(boolean, boolean)
        plus(double, double)
        plus(float, float)
        plus(int, int)
        plus(java.lang.Object)
            --> java.lang.Object *
        plus(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
        plus(java.lang.Object, java.lang.Object)
            --> am.englet.TestUtils0.bigdec(java.lang.Object)
            --> am.englet.Utils.toStringBuffer(java.lang.Object)
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.StringBuffer) *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.add(java.math.BigDecimal) *
        plus(java.lang.Object, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        plus(long, long)
        plusz(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Links.plusz(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        procLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.TestUtils0$4.TestUtils0$4(am.englet.Invokable)
            --> am.englet.TestUtils0$5.TestUtils0$5(am.englet.Invokable)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.link.Link
            --> java.lang.Class *
        rem(int, int)
        rxlink(java.lang.String, java.lang.String)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.TestUtils0$11.TestUtils0$11(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.lang.CharSequence *
            --> java.lang.String *
            --> java.util.regex.Matcher *
            --> java.util.regex.Pattern *
            --> java.util.regex.Pattern.compile(java.lang.String, int) *
            --> java.util.regex.Pattern.matcher(java.lang.CharSequence) *
        rxsplit(java.lang.String, java.lang.String)
            --> am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.CharSequence *
            --> java.lang.String *
            --> java.util.regex.Matcher *
            --> java.util.regex.Pattern *
            --> java.util.regex.Pattern.compile(java.lang.String, int) *
            --> java.util.regex.Pattern.matcher(java.lang.CharSequence) *
        static {}
            --> am.englet.TestUtils0.EXCL_FNAL_LINK
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.intern() *
        staticInvokableBasedCkecker(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$7.TestUtils0$7(am.englet.Invokable)
            <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.util.Checker
        tail(am.englet.link.Link)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.lang.Object[])
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        times(am.englet.Invokable, java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
            --> am.englet.link.Link
            --> java.lang.Object *
        times(am.englet.link.Chain, am.englet.link.Link)
            --> am.englet.Links$NextContentProvider
            --> am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
            --> am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0.times(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Chain
            --> am.englet.link.Link
        times(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.returnType()
            --> am.englet.TestUtils0.class$6
            --> am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
            --> am.englet.link.Link
            --> java.lang.Boolean.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        times(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.timesd(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.timesdd(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.Link
            --> java.lang.Object *
        times(am.englet.link.Link, boolean)
            --> am.englet.link.Link
        times(am.englet.link.Link, java.lang.String)
            --> am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.lang.String *
        times(boolean, am.englet.link.Link)
            --> am.englet.link.Link
        times(boolean, boolean)
        times(boolean, java.lang.Object)
            --> am.englet.TestUtils0.times(java.lang.Object, boolean)
            --> am.englet.link.Link
            --> java.lang.Object *
        times(double, double)
        times(float, float)
        times(int, int)
        times(java.lang.Object)
            --> java.lang.Object *
        times(java.lang.Object, am.englet.link.Link)
            --> am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
            --> am.englet.link.Chain
            --> am.englet.link.Chain.Chain(java.lang.Object)
            --> am.englet.link.Link
            --> java.lang.Object *
        times(java.lang.Object, boolean)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            <-- am.englet.TestUtils0.times(boolean, java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> am.englet.link.Link
            --> java.lang.Object *
        times(java.math.BigDecimal, java.math.BigDecimal)
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.multiply(java.math.BigDecimal) *
        times(long, long)
        times0(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.Slider
        times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.TestUtils0.EXCL_FNAL_LINK
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.LoopSlider.LoopSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
        timesd(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.Management.direct(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        timesdd(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.TestUtils0$3.TestUtils0$3()
            --> am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
        unString(java.lang.String, java.lang.String)
            --> am.englet.TestUtils0.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.Class.getMethods() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
            --> java.lang.reflect.Modifier.isStatic(int) *
        xor(am.englet.link.Link)
            --> am.englet.ResultList
            --> am.englet.ResultList.ResultList(java.lang.Object[])
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
    TestUtils0$1
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$1(int, int)
            --> am.englet.TestUtils0$1.current
            --> am.englet.TestUtils0$1.val$end
            <-- am.englet.TestUtils0.forLink(int, int)
            --> java.lang.Object.Object() *
        current
            <-- am.englet.TestUtils0$1.TestUtils0$1(int, int)
            <-- am.englet.TestUtils0$1.tryNextContent()
        serialVersionUID
        tryNextContent()
            --> am.englet.TestUtils0$1.current
            --> am.englet.TestUtils0$1.val$end
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
        val$end
            <-- am.englet.TestUtils0$1.TestUtils0$1(int, int)
            <-- am.englet.TestUtils0$1.tryNextContent()
    TestUtils0$10
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.Englet
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.run()
            --> am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.MethodsStorage
            --> am.englet.TestUtils0$10.englet
            --> am.englet.TestUtils0$10.failed
            --> am.englet.TestUtils0$10.val$each
            <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool
            --> am.englet.link.Link
            --> java.lang.Object.Object() *
            --> java.lang.Throwable *
        englet
            --> am.englet.Englet
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
        failed
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
        serialVersionUID
        tryNextContent()
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Englet
            --> am.englet.Englet.debug
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.getStack()
            --> am.englet.Englet.run()
            --> am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            --> am.englet.TestUtils0$10.englet
            --> am.englet.TestUtils0$10.failed
            --> am.englet.TestUtils0$10.val$each
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
        val$each
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$10.tryNextContent()
            --> am.englet.link.Link
    TestUtils0$11
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$11(java.util.regex.Matcher)
            --> am.englet.TestUtils0$11.val$matcher
            <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
            --> java.lang.Object.Object() *
            --> java.util.regex.Matcher *
        serialVersionUID
        tryNextContent()
            --> am.englet.TestUtils0$11.val$matcher
            --> am.englet.TestUtils0.access$0(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.util.regex.Matcher *
            --> java.util.regex.Matcher.find() *
        val$matcher
            <-- am.englet.TestUtils0$11.TestUtils0$11(java.util.regex.Matcher)
            <-- am.englet.TestUtils0$11.tryNextContent()
            --> java.util.regex.Matcher *
    TestUtils0$12
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            --> am.englet.TestUtils0$12.content
            --> am.englet.TestUtils0$12.end
            --> am.englet.TestUtils0$12.match
            --> am.englet.TestUtils0$12.step
            --> am.englet.TestUtils0$12.val$matcher
            --> am.englet.TestUtils0$12.val$src
            <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.util.regex.Matcher *
        content
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.content()
            <-- am.englet.TestUtils0$12.step()
            --> java.lang.Object *
        content()
            --> am.englet.TestUtils0$12.content
            --> am.englet.TestUtils0$12.step
            --> java.lang.Object *
        end
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.step()
        match
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.step()
            <-- am.englet.TestUtils0$12.tryNext()
        step
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.content()
            <-- am.englet.TestUtils0$12.step()
            <-- am.englet.TestUtils0$12.tryNext()
        step()
            --> am.englet.TestUtils0$12.content
            --> am.englet.TestUtils0$12.end
            --> am.englet.TestUtils0$12.match
            --> am.englet.TestUtils0$12.step
            <-- am.englet.TestUtils0$12.tryNext()
            --> am.englet.TestUtils0$12.val$matcher
            --> am.englet.TestUtils0$12.val$src
            --> am.englet.TestUtils0.access$0(java.util.regex.Matcher)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.util.regex.Matcher *
            --> java.util.regex.Matcher.end() *
            --> java.util.regex.Matcher.find() *
            --> java.util.regex.Matcher.start() *
        tryNext()
            --> am.englet.TestUtils0$12.match
            --> am.englet.TestUtils0$12.step
            --> am.englet.TestUtils0$12.step()
        val$matcher
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.step()
            --> java.util.regex.Matcher *
        val$src
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$12.step()
            --> java.lang.String *
    TestUtils0$2
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            --> am.englet.TestUtils0$2.each1
            --> am.englet.TestUtils0$2.through1
            --> am.englet.TestUtils0$2.through2
            --> am.englet.TestUtils0$2.val$each
            <-- am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
            --> am.englet.link.Chain
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        each1
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0$2.tryNextContent()
            --> am.englet.link.Link
        serialVersionUID
        through1
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0$2.tryNextContent()
            --> am.englet.link.Link
        through2
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0$2.tryNextContent()
            --> am.englet.link.Link
        tryNextContent()
            --> am.englet.Links.nullCorrect(java.lang.Object)
            --> am.englet.TestUtils0$2.each1
            --> am.englet.TestUtils0$2.through1
            --> am.englet.TestUtils0$2.through2
            --> am.englet.TestUtils0$2.val$each
            --> am.englet.link.Chain
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Object *
        val$each
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0$2.tryNextContent()
            --> am.englet.link.Chain
    TestUtils0$3
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        TestUtils0$3()
            <-- am.englet.TestUtils0.timesdd(am.englet.link.Link, am.englet.link.Link)
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            --> java.lang.Object *
        serialVersionUID
    TestUtils0$4
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        TestUtils0$4(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$4.val$each
            <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.TestUtils0$4.val$each
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        serialVersionUID
        val$each
            --> am.englet.Invokable
            <-- am.englet.TestUtils0$4.TestUtils0$4(am.englet.Invokable)
            <-- am.englet.TestUtils0$4.convert(java.lang.Object)
    TestUtils0$5
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        TestUtils0$5(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$5.val$each
            <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.TestUtils0$5.val$each
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        serialVersionUID
        val$each
            --> am.englet.Invokable
            <-- am.englet.TestUtils0$5.TestUtils0$5(am.englet.Invokable)
            <-- am.englet.TestUtils0$5.convert(java.lang.Object)
    TestUtils0$6
        --> am.englet.util.Checker
        --> java.lang.Object *
        TestUtils0$6(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$6.val$each
            <-- am.englet.TestUtils0.nonstaticInvokableBasedCkecker(am.englet.Invokable)
            --> java.lang.Object.Object() *
        check(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.TestUtils0$6.val$each
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.System.out *
        val$each
            --> am.englet.Invokable
            <-- am.englet.TestUtils0$6.TestUtils0$6(am.englet.Invokable)
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
    TestUtils0$7
        --> am.englet.util.Checker
        --> java.lang.Object *
        TestUtils0$7(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$7.val$each
            <-- am.englet.TestUtils0.staticInvokableBasedCkecker(am.englet.Invokable)
            --> java.lang.Object.Object() *
        check(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.TestUtils0$7.val$each
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.System.out *
        val$each
            --> am.englet.Invokable
            <-- am.englet.TestUtils0$7.TestUtils0$7(am.englet.Invokable)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
    TestUtils0$8
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$8(am.englet.Invokable, java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.TestUtils0$8.val$each
            --> am.englet.TestUtils0$8.val$through
            <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        serialVersionUID
        tryNextContent()
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.TestUtils0$8.val$each
            --> am.englet.TestUtils0$8.val$through
            --> am.englet.Utils.toBoolean(java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        val$each
            <-- am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
            <-- am.englet.TestUtils0$8.tryNextContent()
            --> java.lang.Object *
        val$through
            --> am.englet.Invokable
            <-- am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
            <-- am.englet.TestUtils0$8.tryNextContent()
    TestUtils0$9
        --> am.englet.Links$NextContentProvider
        --> java.lang.Object *
        TestUtils0$9(java.io.BufferedReader)
            --> am.englet.TestUtils0$9.val$bufferedInputStream
            <-- am.englet.TestUtils0.divL(java.io.InputStream)
            --> java.io.BufferedReader *
            --> java.lang.Object.Object() *
        serialVersionUID
        tryNextContent()
            --> am.englet.Englet.debug
            --> am.englet.TestUtils0$9.val$bufferedInputStream
            --> java.io.BufferedReader *
            --> java.io.BufferedReader.readLine() *
            --> java.io.IOException *
            --> java.io.IOException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
        val$bufferedInputStream
            <-- am.englet.TestUtils0$9.TestUtils0$9(java.io.BufferedReader)
            <-- am.englet.TestUtils0$9.tryNextContent()
            --> java.io.BufferedReader *
    TestUtils0$FS1
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            --> am.englet.Links$ValueConverter
            <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter, am.englet.TestUtils0$FS1)
            --> am.englet.TestUtils0$FS1.c
            --> am.englet.TestUtils0$FS1.s
            --> am.englet.TestUtils0$FS1.ts
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object.Object() *
        TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter, am.englet.TestUtils0$FS1)
            --> am.englet.Links$ValueConverter
            --> am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.link.backadapters.slider.Slider
        c
            --> am.englet.Links$ValueConverter
            <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0$FS1.tryNext()
        content
            <-- am.englet.TestUtils0$FS1.content()
            <-- am.englet.TestUtils0$FS1.tryNext()
            --> java.lang.Object *
        content()
            --> am.englet.TestUtils0$FS1.content
            --> java.lang.Object *
        s
            <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0$FS1.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tryNext()
            --> am.englet.Links$ValueConverter
            --> am.englet.Links$ValueConverter.convert(java.lang.Object)
            --> am.englet.TestUtils0$FS1.c
            --> am.englet.TestUtils0$FS1.content
            --> am.englet.TestUtils0$FS1.s
            --> am.englet.TestUtils0$FS1.ts
            --> am.englet.TestUtils0.class$0
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> am.englet.link.backadapters.slider.Slider.tryNext()
            --> java.lang.Boolean *
            --> java.lang.Boolean.FALSE *
            --> java.lang.Boolean.TRUE *
            --> java.lang.Boolean.equals(java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        ts
            <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0$FS1.tryNext()
            --> am.englet.link.backadapters.slider.Slider
    TokenizerFactory
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.ServiceTokenizerFactory
        --> java.lang.Object *
        forObject(java.lang.Object)
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            --> java.lang.Object *
            --> java.util.Iterator *
    Trace
        --> java.lang.Object *
        TRACE
            <-- am.englet.Management.trace(am.englet.DataStack, boolean)
            <-- am.englet.Trace.direct(java.lang.Object)
            <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Trace.static {}
            <-- am.englet.Trace.unfound(java.lang.Object)
            <-- am.englet.Trace.unfoundString(java.lang.String)
        Trace()
            --> java.lang.Object.Object() *
        call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
            <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.hash(java.lang.Object)
            --> am.englet.Trace.hexHash(java.lang.Object[])
            --> am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.toString(am.englet.Invokable)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        close()
            <-- am.englet.Management.trace(am.englet.DataStack, boolean)
            --> am.englet.Trace.ps
            --> java.io.PrintStream *
            --> java.io.PrintStream.close() *
        command(java.lang.String)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.Trace.lastCommand
            --> java.lang.String *
        constant(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.direct(java.lang.Object)
            <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
            --> am.englet.Trace.hash(java.lang.Object)
            --> am.englet.Trace.objects(java.lang.Object[])
            --> am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Trace.unfound(java.lang.Object)
            <-- am.englet.Trace.unfoundString(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
        direct(java.lang.Object)
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.constant(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.directObject(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        directObject(java.lang.Object)
            <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
            --> am.englet.Trace.direct(java.lang.Object)
            --> java.lang.Object *
        fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> am.englet.Invokable
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            --> am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.lastCommand
            --> java.lang.Object *
            --> java.lang.String *
        fail(java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> java.lang.Object *
            --> java.lang.String *
        got(java.lang.Object, java.lang.String)
            <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.constant(java.lang.Object, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        hash(java.lang.Object)
            <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.hexHash(java.lang.Object[])
            <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.toHexString(int)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.identityHashCode(java.lang.Object) *
        hexDigit
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Trace.static {}
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Trace.toHexString(int)
        hexHash(java.lang.Object[])
            <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.hash(java.lang.Object)
            --> java.lang.Object *
        lastCommand
            <-- am.englet.Trace.command(java.lang.String)
            <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
            <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> java.lang.String *
        log()
        objects(java.lang.Object[])
            --> am.englet.Trace.TRACE
            <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
            --> am.englet.Trace.open()
            --> am.englet.Trace.ps
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> java.io.PrintStream *
            --> java.io.PrintStream.flush() *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.print(java.lang.String) *
            --> java.lang.Class *
            --> java.lang.Class.getComponentType() *
            --> java.lang.Class.isArray() *
            --> java.lang.Class.isPrimitive() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.Object[] *
            --> java.lang.String *
        open()
            <-- am.englet.Trace.objects(java.lang.Object[])
            --> am.englet.Trace.ps
            --> am.englet.Trace.timeString(long)
            --> java.io.FileOutputStream.FileOutputStream(java.lang.String, boolean) *
            --> java.io.OutputStream *
            --> java.io.PrintStream *
            --> java.io.PrintStream.PrintStream(java.io.OutputStream) *
            --> java.io.PrintStream.checkError() *
            --> java.io.PrintStream.print(java.lang.String) *
            --> java.io.PrintStream.println() *
            --> java.lang.Exception *
            --> java.lang.Integer.toString(int) *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.currentTimeMillis() *
        ps
            <-- am.englet.Trace.close()
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Trace.open()
            --> java.io.PrintStream *
        saveConvert(java.lang.String, boolean)
            <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
            --> am.englet.Trace.hexDigit
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.indexOf(int) *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(int) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.toString() *
        static {}
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.hexDigit
        success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> am.englet.Invokable
            <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Trace.lastCommand
            --> am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> java.lang.Object *
            --> java.lang.String *
        success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.ResultList
            --> am.englet.ResultList.content()
            --> am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> am.englet.Trace.hash(java.lang.Object)
            <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
            --> java.lang.Object *
            --> java.lang.String *
        timeString(long)
            --> am.englet.Trace.hexDigit
            <-- am.englet.Trace.open()
            --> java.lang.Integer.toString(int, int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Date.Date(long) *
            --> java.util.Date.getDate() *
            --> java.util.Date.getHours() *
            --> java.util.Date.getMinutes() *
            --> java.util.Date.getMonth() *
            --> java.util.Date.getSeconds() *
            --> java.util.Date.getYear() *
        toHexString(int)
            <-- am.englet.Trace.hash(java.lang.Object)
            --> am.englet.Trace.hexDigit
            --> java.lang.String *
            --> java.lang.String.String(char[]) *
        toString(am.englet.Invokable)
            --> am.englet.Invokable
            <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        unfound(java.lang.Object)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.constant(java.lang.Object, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
        unfoundString(java.lang.String)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            --> am.englet.Trace.TRACE
            --> am.englet.Trace.constant(java.lang.Object, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
    Utils
        --> java.lang.Object *
        MAX_INT
            <-- am.englet.Utils.correctValue(java.lang.Object)
            <-- am.englet.Utils.static {}
            --> java.math.BigInteger *
        MAX_INT_BD
            <-- am.englet.Utils.correctValue(java.lang.Object)
            <-- am.englet.Utils.static {}
            --> java.math.BigDecimal *
        MIN_INT
            <-- am.englet.Utils.correctValue(java.lang.Object)
            <-- am.englet.Utils.static {}
            --> java.math.BigInteger *
        MIN_INT_BD
            <-- am.englet.Utils.correctValue(java.lang.Object)
            <-- am.englet.Utils.static {}
            --> java.math.BigDecimal *
        NUMBER_CAST_RATES
            <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.static {}
            --> java.util.Map *
        STACK_IS_EMPTY
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            <-- am.englet.Utils.static {}
            --> java.lang.Object *
        Utils()
            --> java.lang.Object.Object() *
        add(java.lang.String, java.util.List, java.lang.String)
            --> am.englet.Utils.addClassNames(java.lang.String, java.util.List)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.String.startsWith(java.lang.String) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toLowerCase() *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        addClassNames(java.lang.String, java.util.List)
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            --> am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        assignTargetsSet(java.lang.Class)
            --> am.englet.Utils.class$2
            --> am.englet.Utils.process(java.lang.Class, java.util.Set)
            <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
            <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashSet.HashSet() *
            --> java.util.Set *
            --> java.util.Set.remove(java.lang.Object) *
        atStack(java.util.List, int)
            <-- am.englet.DataStack.at(int)
            <-- am.englet.DataStack.at(int, int)
            --> am.englet.Utils.stackIndex(java.util.List, int)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.get(int) *
        backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.Processing.slide(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.Link
            --> am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.SimpleLinkFactory.instance()
        camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
            --> java.lang.Character.isUpperCase(char) *
            --> java.lang.Character.toLowerCase(char) *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.toString() *
        class$0
            <-- am.englet.Utils.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.Utils.static {}
            --> java.lang.Class *
        class$10
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            --> java.lang.Class *
        class$11
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        class$12
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        class$13
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        class$14
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        class$15
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        class$2
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            --> java.lang.Class *
        class$3
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        class$4
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        class$5
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Class *
        class$6
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Class *
        class$7
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Class *
        class$8
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> java.lang.Class *
        class$9
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        constantProxy(am.englet.VariablesStorage, java.lang.Class)
            <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.Class)
            <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            --> am.englet.Utils.methodsNames(java.lang.Class)
            --> am.englet.VariablesStorage
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
        constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            --> am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
            --> am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            --> am.englet.VariablesStorage
            --> java.lang.Class *
            --> java.lang.Class.getClassLoader() *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getSystemClassLoader() *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationHandler *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.lang.reflect.Proxy.newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) *
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> am.englet.$.$(java.lang.Class, java.lang.Class)
            --> am.englet.$.method(int, int, java.lang.Class[], java.lang.String[]) *
            --> am.englet.CastingContext
            --> am.englet.CompoundInvokable
            --> am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            --> am.englet.Invokable
            --> am.englet.InvokableDescription
            --> am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.Utils.class$5
            --> am.englet.Utils.class$6
            --> am.englet.Utils.class$7
            --> am.englet.Utils.class$8
            --> am.englet.Utils.class$9
            --> am.englet.Utils.methodsNames(java.lang.Class)
            --> am.englet.VariablesStorage
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.util.Map *
        copy(java.lang.Object[])
            <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.parameterTypes()
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableDescription.getSources()
            <-- am.englet.ResultList.ResultList(java.lang.Object[])
            <-- am.englet.ResultList.content()
            <-- am.englet.Utils$3.parameterTypes()
            <-- am.englet.Utils$4.parameterTypes()
            --> java.lang.Class *
            --> java.lang.Class.getComponentType() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.Object[] *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.reflect.Array.newInstance(java.lang.Class, int) *
        correctValue(java.lang.Object)
            <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
            <-- am.englet.ResultList.appendTo(java.util.List)
            --> am.englet.Utils.MAX_INT
            --> am.englet.Utils.MAX_INT_BD
            --> am.englet.Utils.MIN_INT
            --> am.englet.Utils.MIN_INT_BD
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Long *
            --> java.lang.Long.intValue() *
            --> java.lang.Long.longValue() *
            --> java.lang.Number *
            --> java.lang.Object *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.compareTo(java.math.BigDecimal) *
            --> java.math.BigDecimal.intValue() *
            --> java.math.BigDecimal.scale() *
            --> java.math.BigInteger *
            --> java.math.BigInteger.compareTo(java.math.BigInteger) *
            --> java.math.BigInteger.intValue() *
        curryLink(am.englet.link.Link, java.util.Map)
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0.div(am.englet.link.Link, java.util.Map)
            --> am.englet.Utils$9.Utils$9(java.util.Map)
            --> am.englet.link.Link
            --> java.util.Map *
        debug(java.io.PrintStream, am.englet.CodeBlock)
            --> am.englet.CodeBlock
            --> am.englet.CodeBlock.result()
            --> am.englet.Englet.debug
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            --> am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.io.PrintStream *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.System.out *
        debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Englet.debug
            <-- am.englet.Englet.getArgument()
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.InvokableDescription.prepare()
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
            <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.System.out *
        debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.Englet.debug
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.System.out *
        debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            --> am.englet.Englet.debug
            <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            --> am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.System.out *
        debug(java.io.PrintStream, java.lang.Object[])
            --> am.englet.Englet.debug
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
        debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            --> am.englet.Englet.debug
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
        debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.Englet.debug
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.io.PrintStream.println() *
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.lang.Throwable.printStackTrace() *
        defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> am.englet.Utils.class$10
            --> am.englet.Utils.class$11
            --> am.englet.Utils.class$12
            --> am.englet.Utils.class$13
            --> am.englet.Utils.class$14
            --> am.englet.Utils.class$15
            --> am.englet.Utils.class$3
            --> am.englet.Utils.class$9
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            --> java.lang.Boolean *
            --> java.lang.Boolean.FALSE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Double.Double(double) *
            --> java.lang.Float.Float(float) *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Long.Long(long) *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Collections.EMPTY_LIST *
            --> java.util.Collections.EMPTY_MAP *
            --> java.util.List *
            --> java.util.Map *
        deprimitivized(java.lang.Class)
            --> am.englet.$.DEPRIMITIIVISATORS
            <-- am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
            <-- am.englet.reflect.MemberInvokable.deprimitivise(java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.isPrimitive() *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.DataStack
            --> am.englet.DataStack.derive()
            --> am.englet.Englet
            --> am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            --> am.englet.MethodsStorage
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            --> am.englet.cast.ClassPool
        ensuredClassLoader(java.lang.Class)
            <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getClassLoader() *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getSystemClassLoader() *
        filterLink(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Management.filter(am.englet.DataStack, am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.util.Checker
        find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            --> am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            --> am.englet.VariablesStorage
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.iterator() *
        find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            --> am.englet.Utils.class$10
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            --> am.englet.VariablesStorage
            --> am.englet.VariablesStorage.get(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
        findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            --> am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        findStaticFactoryMethod(java.lang.Class, java.lang.Class)
            --> am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        formatLink(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Utils$8.Utils$8(am.englet.DataStack)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            --> am.englet.link.Link
        getClipString()
            <-- am.englet.Processing.fromClip()
            --> am.englet.Utils.getClipboard()
            --> java.awt.datatransfer.Clipboard *
            --> java.awt.datatransfer.Clipboard.getContents(java.lang.Object) *
            --> java.awt.datatransfer.DataFlavor *
            --> java.awt.datatransfer.DataFlavor.stringFlavor *
            --> java.awt.datatransfer.Transferable *
            --> java.awt.datatransfer.Transferable.getTransferData(java.awt.datatransfer.DataFlavor) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        getClipboard()
            <-- am.englet.Processing.toClip(java.lang.String)
            <-- am.englet.Utils.getClipString()
            --> java.awt.Toolkit *
            --> java.awt.Toolkit.getDefaultToolkit() *
            --> java.awt.Toolkit.getSystemClipboard() *
            --> java.awt.datatransfer.Clipboard *
        getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Englet.getSingleton(java.lang.Class)
            --> am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
        getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            --> am.englet.CodeBlock
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            <-- am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.newInstance() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.System.out *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        getFirstMatching(java.lang.Object[], java.lang.String)
            <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            --> java.lang.CharSequence *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.util.regex.Matcher *
            --> java.util.regex.Matcher.matches() *
            --> java.util.regex.Pattern *
            --> java.util.regex.Pattern.compile(java.lang.String) *
            --> java.util.regex.Pattern.matcher(java.lang.CharSequence) *
        indexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String, int) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.indexOf(java.lang.String, int) *
        isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.$.paramTypesFit(java.lang.Class[], java.lang.Class[])
            <-- am.englet.Lookup.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            --> am.englet.Utils.class$3
            --> am.englet.Utils.class$4
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        isLink(java.lang.Object)
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> java.lang.Object *
        isPublic(java.lang.Class)
            <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.getModifiers() *
            --> java.lang.reflect.Modifier.isPublic(int) *
        isStatic(java.lang.reflect.Member)
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getModifiers() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        isUpCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            --> am.englet.Utils.NUMBER_CAST_RATES
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Comparable *
            --> java.lang.Comparable.compareTo(java.lang.Object) *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        lastIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.lastIndexOf(java.lang.String, int) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.lastIndexOf(java.lang.String, int) *
        lazy(am.englet.link.Link)
            <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.Processing.copy(am.englet.link.Link)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
            --> am.englet.link.NextItemProvider
            --> am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            --> am.englet.link.backadapters.ResultSetStrategy
            --> am.englet.link.backadapters.ResultSetStrategy.INSTANCE
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.Slider
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.System.out *
        lookUpConstructor(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.reflect.Constructor *
        lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        method(java.lang.Class, java.lang.String)
            --> am.englet.$$Declared
            --> am.englet.$$Declared.method() *
            --> am.englet.$.declared
            --> am.englet.$.method() *
            --> am.englet.Utils$2.Utils$2(java.lang.Class, java.lang.String)
            <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        method(java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.Utils.method(java.lang.Class, java.lang.String)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.String.split(java.lang.String, int) *
            --> java.lang.reflect.Method *
        methodsNames(java.lang.Class)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            --> am.englet.Utils.names(java.lang.String, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getMethods() *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.String *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getReturnType() *
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.List *
            --> java.util.Map *
        names(java.lang.String, java.lang.Class)
            --> am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            --> am.englet.Utils.addClassNames(java.lang.String, java.util.List)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            --> am.englet.Utils.simpleName(java.lang.Class)
            --> java.lang.Character.isUpperCase(char) *
            --> java.lang.Character.toLowerCase(char) *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.String(char[]) *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.Collections.unmodifiableList(java.util.List) *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
            --> am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
            --> java.io.PrintStream *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.length() *
            --> java.lang.System.out *
        outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Management.printstack(am.englet.DataStack)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.flt.main(java.lang.String[])
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
            <-- am.englet.try1$try2.clone()
            <-- am.englet.try1$try2.try1$try2(am.englet.try1)
            <-- am.englet.try1.clone()
            <-- am.englet.try1.try1()
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.String) *
            --> java.lang.String *
        packageNameToPackagePath(java.lang.String)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            --> java.lang.String *
            --> java.lang.String.replaceAll(java.lang.String, java.lang.String) *
        parameterized(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Links$ValueConverter
            --> am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
            --> am.englet.Utils$7.Utils$7(am.englet.DataStack)
            <-- am.englet.Utils$7.convert(java.lang.Object)
            --> am.englet.link.Link
        print(java.io.PrintStream, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.Object) *
            --> java.lang.ArrayIndexOutOfBoundsException *
            --> java.lang.Class *
            --> java.lang.Class.isArray() *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.reflect.Array.get(java.lang.Object, int) *
            --> java.lang.reflect.Array.getLength(java.lang.Object) *
        process(java.lang.Class, java.util.Set)
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getInterfaces() *
            --> java.lang.Class.getSuperclass() *
            --> java.lang.Object *
            --> java.util.Set *
            --> java.util.Set.add(java.lang.Object) *
        pump(java.io.InputStream, java.io.OutputStream)
            <-- am.englet.Processing.pump(java.io.InputStream, java.io.OutputStream)
            --> java.io.IOException *
            --> java.io.IOException.printStackTrace() *
            --> java.io.InputStream *
            --> java.io.InputStream.available() *
            --> java.io.InputStream.read(byte[], int, int) *
            --> java.io.OutputStream *
            --> java.io.OutputStream.write(byte[], int, int) *
            --> java.lang.Exception *
            --> java.lang.Thread.sleep(long) *
        put(java.util.Map, java.lang.Class, int)
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            <-- am.englet.Utils.static {}
            --> java.lang.Class *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.CommandSource
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.DataStack.push(java.lang.Object)
            --> am.englet.DataStack.size()
            --> am.englet.DataStack.stack()
            --> am.englet.Englet
            --> am.englet.Englet.getRstack()
            --> am.englet.Englet.getStack()
            --> am.englet.Englet.run()
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
            --> am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
            --> am.englet.Utils.STACK_IS_EMPTY
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Throwable *
            --> java.util.Stack *
            --> java.util.Stack.empty() *
        simpleClassname(java.lang.String)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            --> java.lang.String *
            --> java.lang.String.lastIndexOf(int) *
            --> java.lang.String.substring(int) *
        simpleName(java.lang.Class)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.String *
            --> java.lang.String.lastIndexOf(int) *
            --> java.lang.String.substring(int) *
        sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
            <-- am.englet.TestUtils0.times0(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.Link
            --> am.englet.link.backadapters.ResultSetStrategy
            --> am.englet.link.backadapters.ResultSetStrategy.INSTANCE
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.Slider
        splitLink(java.lang.String, java.lang.String, int)
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.TestUtils0.div(java.lang.String, java.lang.String)
            --> am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.Utils.splitSlider(java.lang.String, java.lang.String, int)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.lang.String *
        splitSlider(java.lang.String, java.lang.String, int)
            --> am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.String *
            --> java.lang.String.length() *
        stackIndex(java.util.List, int)
            <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
            <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
            <-- am.englet.Utils.atStack(java.util.List, int)
            --> java.util.List *
            --> java.util.List.size() *
        static {}
            --> am.englet.Utils.MAX_INT
            --> am.englet.Utils.MAX_INT_BD
            --> am.englet.Utils.MIN_INT
            --> am.englet.Utils.MIN_INT_BD
            --> am.englet.Utils.NUMBER_CAST_RATES
            --> am.englet.Utils.STACK_IS_EMPTY
            --> am.englet.Utils.class$0
            --> am.englet.Utils.class$1
            --> am.englet.Utils.put(java.util.Map, java.lang.Class, int)
            --> java.lang.Boolean.TYPE *
            --> java.lang.Byte.TYPE *
            --> java.lang.Character.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Short.TYPE *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.math.BigDecimal *
            --> java.math.BigDecimal.valueOf(long) *
            --> java.math.BigInteger *
            --> java.math.BigInteger.valueOf(long) *
            --> java.util.Collections.unmodifiableMap(java.util.Map) *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        staticInvokable(am.englet.Invokable, int)
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
            --> am.englet.Invokable
            --> am.englet.Invokable.targetType()
            <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            --> am.englet.Utils$3.Utils$3(am.englet.Invokable)
            --> am.englet.Utils$4.Utils$4(am.englet.Invokable)
            --> java.lang.Class *
        suckThru(byte[], java.io.InputStream)
            <-- am.englet.Processing.fromUrl(java.lang.String)
            <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.io.InputStream.close() *
            --> java.io.InputStream.read(byte[]) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
        toBoolean(java.lang.Object)
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
            <-- am.englet.TestUtils0$8.tryNextContent()
            <-- am.englet.TestUtils0.BOOLEAN(java.lang.Object)
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.equalsIgnoreCase(java.lang.String) *
            --> java.lang.String.length() *
        toCharSequence(java.lang.Object)
            --> java.lang.CharSequence *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
        toClassNameCase(java.lang.String)
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toUpperCase() *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        toFieldNameCase(java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.length() *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toLowerCase() *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        toStringBuffer(java.lang.Object)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
        tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> am.englet.Utils.lookUpConstructor(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.InstantiationException *
            --> java.lang.NoSuchMethodException *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
            --> java.lang.reflect.InvocationTargetException *
        tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
            --> am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
            --> am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.IllegalAccessException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
            --> am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
            --> am.englet.Utils.ensuredClassLoader(java.lang.Class)
            --> am.englet.cast.ClassPool$classLoader
            --> am.englet.cast.ClassPool$classLoader.getResource(java.lang.String) *
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            --> java.lang.Class *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getResource(java.lang.String) *
            --> java.lang.String *
            --> java.net.URL *
    Utils$1
        --> am.englet.CodeBlock
        Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.Utils$1.val$key
            --> am.englet.Utils$1.val$res1
            --> am.englet.Utils$1.val$valueClass
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
        result()
            --> am.englet.Utils$1.val$key
            --> am.englet.Utils$1.val$res1
            --> am.englet.Utils$1.val$valueClass
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.String *
        val$key
            <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            <-- am.englet.Utils$1.result()
            --> java.lang.Object *
        val$res1
            <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            <-- am.englet.Utils$1.result()
            --> java.lang.Object *
        val$valueClass
            <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
            <-- am.englet.Utils$1.result()
            --> java.lang.Class *
    Utils$2
        --> am.englet.$
        Utils$2(java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.Utils$2.val$regex
            <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.Utils$2.val$regex
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String) *
            --> java.lang.String.matches(java.lang.String) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.toString() *
        val$regex
            <-- am.englet.Utils$2.Utils$2(java.lang.Class, java.lang.String)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
            --> java.lang.String *
    Utils$3
        --> am.englet.Invokable
        --> java.lang.Object *
        Utils$3(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.returnType()
            --> am.englet.Invokable.targetType()
            --> am.englet.Utils$3.inv
            --> am.englet.Utils$3.parameterTypes
            --> am.englet.Utils$3.returnType
            <-- am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
        inv
            --> am.englet.Invokable
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$3.toString()
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Utils$3.inv
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.reflect.InvocationTargetException *
        parameterTypes
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$3.parameterTypes()
            --> java.lang.Class *
        parameterTypes()
            --> am.englet.Utils$3.parameterTypes
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
        returnType
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$3.returnType()
            --> java.lang.Class *
        returnType()
            --> am.englet.Utils$3.returnType
            --> java.lang.Class *
        targetType()
            --> java.lang.Class *
        toString()
            --> am.englet.Invokable
            --> am.englet.Utils$3.inv
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
    Utils$4
        --> am.englet.Invokable
        --> java.lang.Object *
        Utils$4(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.Invokable.returnType()
            --> am.englet.Invokable.targetType()
            --> am.englet.Utils$4.inv
            --> am.englet.Utils$4.parameterTypes
            --> am.englet.Utils$4.returnType
            <-- am.englet.Utils.staticInvokable(am.englet.Invokable, int)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
        inv
            --> am.englet.Invokable
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$4.toString()
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Utils$4.inv
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.reflect.InvocationTargetException *
        parameterTypes
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils$4.parameterTypes()
            --> java.lang.Class *
        parameterTypes()
            --> am.englet.Utils$4.parameterTypes
            --> am.englet.Utils.copy(java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
        returnType
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils$4.returnType()
            --> java.lang.Class *
        returnType()
            --> am.englet.Utils$4.returnType
            --> java.lang.Class *
        targetType()
            --> java.lang.Class *
        toString()
            --> am.englet.Invokable
            --> am.englet.Utils$4.inv
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
    Utils$5
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        Utils$5(int, java.lang.String, java.lang.String, int)
            --> am.englet.Utils$5.first
            --> am.englet.Utils$5.p
            --> am.englet.Utils$5.p1
            --> am.englet.Utils$5.val$length
            --> am.englet.Utils$5.val$of
            --> am.englet.Utils$5.val$sample
            --> am.englet.Utils$5.wasFirst
            <-- am.englet.Utils.splitSlider(java.lang.String, java.lang.String, int)
            --> java.lang.Object.Object() *
            --> java.lang.String *
        content()
            --> am.englet.Utils$5.p
            --> am.englet.Utils$5.p1
            --> am.englet.Utils$5.val$length
            --> am.englet.Utils$5.val$of
            --> am.englet.Utils$5.wasFirst
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
        first
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.tryNext()
        p
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils$5.tryNext()
        p1
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils$5.tryNext()
        tryNext()
            --> am.englet.Utils$5.first
            --> am.englet.Utils$5.p
            --> am.englet.Utils$5.p1
            --> am.englet.Utils$5.val$of
            --> am.englet.Utils$5.val$sample
            --> am.englet.Utils$5.wasFirst
            --> java.lang.String *
            --> java.lang.String.indexOf(java.lang.String, int) *
        val$length
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.content()
        val$of
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils$5.tryNext()
            --> java.lang.String *
        val$sample
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.tryNext()
            --> java.lang.String *
        wasFirst
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils$5.tryNext()
    Utils$6
        --> java.lang.Object *
        --> java.lang.reflect.InvocationHandler *
        Utils$6(java.lang.Class, java.util.Map)
            --> am.englet.Utils$6.equalsMethod
            --> am.englet.Utils$6.hashCodeMethod
            --> am.englet.Utils$6.toStringMethod
            --> am.englet.Utils$6.val$ifc
            --> am.englet.Utils$6.val$m
            --> am.englet.Utils.class$2
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getMethod(java.lang.String, java.lang.Class[]) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.NoSuchMethodError.NoSuchMethodError(java.lang.String) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.NoSuchMethodException.getMessage() *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.util.Map *
        equalsMethod
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> java.lang.reflect.Method *
        getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> am.englet.Utils.class$6
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        hashCodeMethod
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> java.lang.reflect.Method *
        invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> am.englet.Utils$6.equalsMethod
            --> am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            --> am.englet.Utils$6.hashCodeMethod
            --> am.englet.Utils$6.toStringMethod
            --> am.englet.Utils$6.val$ifc
            --> am.englet.Utils$6.val$m
            --> java.lang.Boolean *
            --> java.lang.Boolean.FALSE *
            --> java.lang.Boolean.TRUE *
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Integer.toHexString(int) *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.Object.hashCode() *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.identityHashCode(java.lang.Object) *
            --> java.lang.Throwable *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.equals(java.lang.Object) *
            --> java.util.Map *
        toStringMethod
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> java.lang.reflect.Method *
        val$ifc
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> java.lang.Class *
        val$m
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            --> java.util.Map *
    Utils$7
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        Utils$7(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Utils$7.val$ds
            <-- am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.DataStack
            --> am.englet.DataStack.get(java.lang.Object)
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            --> am.englet.Utils$7.val$ds
            --> am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.String *
        serialVersionUID
        val$ds
            --> am.englet.DataStack
            <-- am.englet.Utils$7.Utils$7(am.englet.DataStack)
            <-- am.englet.Utils$7.convert(java.lang.Object)
    Utils$8
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        Utils$8(am.englet.DataStack)
            --> am.englet.DataStack
            --> am.englet.Utils$8.val$ds
            <-- am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
            --> java.lang.Object.Object() *
        convert(java.lang.Object)
            --> am.englet.DataStack
            --> am.englet.DataStack$StackFrame
            --> am.englet.DataStack$StackFrame.st
            --> am.englet.DataStack.get(java.lang.Object)
            --> am.englet.DataStack.top()
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            --> am.englet.Utils$8.val$ds
            --> am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
            --> am.englet.link.Link
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
        serialVersionUID
        val$ds
            --> am.englet.DataStack
            <-- am.englet.Utils$8.Utils$8(am.englet.DataStack)
            <-- am.englet.Utils$8.convert(java.lang.Object)
    Utils$9
        --> am.englet.Links$ValueConverter
        --> java.lang.Object *
        Utils$9(java.util.Map)
            --> am.englet.Utils$9.val$m
            <-- am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
            --> java.lang.Object.Object() *
            --> java.util.Map *
        convert(java.lang.Object)
            --> am.englet.MethodsStorage$Getter
            --> am.englet.MethodsStorage$Getter.varname()
            --> am.englet.Utils$9.val$m
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
            --> java.util.Map.get(java.lang.Object) *
        serialVersionUID
        val$m
            <-- am.englet.Utils$9.Utils$9(java.util.Map)
            <-- am.englet.Utils$9.convert(java.lang.Object)
            --> java.util.Map *
    VariablesStorage
        <-- am.englet.DataStack
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.get(java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        --> am.englet.ServiceObject
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        --> java.lang.Object *
        get(java.lang.Object)
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.Management.get(java.lang.String, am.englet.VariablesStorage)
            <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            --> java.lang.Object *
        has(java.lang.Object)
            --> java.lang.Object *
        put(java.lang.Object, java.lang.Object)
            <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
            --> java.lang.Object *
        set(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
    YAMLBasedEngletSettings
        --> am.englet.EngletSettings
        <-- am.englet.YAMLBasedEngletSettings$1.YAMLBasedEngletSettings$1(am.englet.YAMLBasedEngletSettings)
        <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$1.this$0
        <-- am.englet.YAMLBasedEngletSettings$2.YAMLBasedEngletSettings$2(am.englet.YAMLBasedEngletSettings)
        <-- am.englet.YAMLBasedEngletSettings$2.this$0
        --> java.lang.Object *
        YAMLBasedEngletSettings()
            --> java.lang.Object.Object() *
        access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.Englet
            <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        access$1(am.englet.Englet, java.lang.Object)
            --> am.englet.Englet
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
        adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
            --> am.englet.Englet
            --> am.englet.Englet.getMethods()
            --> am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.String *
        apply(am.englet.Englet)
            --> am.englet.DataStack
            --> am.englet.DataStack.clear()
            --> am.englet.Englet
            --> am.englet.Englet.debug
            --> am.englet.Englet.getStack()
            --> am.englet.YAMLBasedEngletSettings$1.YAMLBasedEngletSettings$1(am.englet.YAMLBasedEngletSettings)
            --> am.englet.YAMLBasedEngletSettings$2.YAMLBasedEngletSettings$2(am.englet.YAMLBasedEngletSettings)
            --> am.englet.YAMLBasedEngletSettings$Performer
            --> am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            --> java.io.FileReader.FileReader(java.lang.String) *
            --> java.io.Reader *
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Boolean.valueOf(java.lang.String) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.getProperty(java.lang.String, java.lang.String) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> net.sourceforge.yamlbeans.YamlReader.YamlReader(java.io.Reader) *
            --> net.sourceforge.yamlbeans.YamlReader.read() *
        getClass(java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.String *
        parse(am.englet.Englet, java.lang.Object)
            --> am.englet.Englet
            --> am.englet.Englet.parse(java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.access$1(am.englet.Englet, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
        processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            --> am.englet.Englet
            --> am.englet.YAMLBasedEngletSettings$Performer
            --> am.englet.YAMLBasedEngletSettings$Performer.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.Englet
            <-- am.englet.YAMLBasedEngletSettings.access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String, java.lang.String) *
            --> java.util.StringTokenizer.hasMoreTokens() *
            --> java.util.StringTokenizer.nextToken() *
        processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            --> am.englet.Englet
            --> am.englet.YAMLBasedEngletSettings$Performer
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            --> am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.iterator() *
            --> java.util.Map *
    YAMLBasedEngletSettings$1
        --> am.englet.YAMLBasedEngletSettings$Performer
        --> java.lang.Object *
        YAMLBasedEngletSettings$1(am.englet.YAMLBasedEngletSettings)
            --> am.englet.YAMLBasedEngletSettings
            --> am.englet.YAMLBasedEngletSettings$1.this$0
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            --> java.lang.Object.Object() *
        perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.Englet
            --> am.englet.YAMLBasedEngletSettings
            --> am.englet.YAMLBasedEngletSettings$1.this$0
            --> am.englet.YAMLBasedEngletSettings.access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        this$0
            --> am.englet.YAMLBasedEngletSettings
            <-- am.englet.YAMLBasedEngletSettings$1.YAMLBasedEngletSettings$1(am.englet.YAMLBasedEngletSettings)
            <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
    YAMLBasedEngletSettings$2
        --> am.englet.YAMLBasedEngletSettings$Performer
        --> java.lang.Object *
        YAMLBasedEngletSettings$2(am.englet.YAMLBasedEngletSettings)
            --> am.englet.YAMLBasedEngletSettings
            --> am.englet.YAMLBasedEngletSettings$2.this$0
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            --> java.lang.Object.Object() *
        perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.DataStack
            --> am.englet.DataStack.pop()
            --> am.englet.Englet
            --> am.englet.Englet.getMethods()
            --> am.englet.Englet.getStack()
            --> am.englet.Invokable
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            --> am.englet.YAMLBasedEngletSettings.access$1(am.englet.Englet, java.lang.Object)
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
        this$0
            --> am.englet.YAMLBasedEngletSettings
            <-- am.englet.YAMLBasedEngletSettings$2.YAMLBasedEngletSettings$2(am.englet.YAMLBasedEngletSettings)
    YAMLBasedEngletSettings$Performer
        <-- am.englet.YAMLBasedEngletSettings$1
        <-- am.englet.YAMLBasedEngletSettings$2
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        --> java.lang.Object *
        perform(am.englet.Englet, java.lang.String, java.lang.Object)
            --> am.englet.Englet
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            --> java.lang.Object *
            --> java.lang.String *
    ct
        --> java.lang.Object *
        cc(double)
            <-- am.englet.ct.dd()
        cc0(float)
            <-- am.englet.ct.dd()
        ct()
            --> java.lang.Object.Object() *
        dd()
            --> am.englet.ct.cc(double)
            --> am.englet.ct.cc0(float)
    flt
        --> java.lang.Object *
        flt()
            --> java.lang.Object.Object() *
        main(java.lang.String[])
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.io.File.File(java.lang.String) *
            --> java.io.File.getAbsolutePath() *
            --> java.io.FileInputStream.FileInputStream(java.lang.String) *
            --> java.io.FileNotFoundException *
            --> java.io.FileOutputStream.FileOutputStream(java.lang.String) *
            --> java.io.InputStream *
            --> java.io.ObjectInputStream.ObjectInputStream(java.io.InputStream) *
            --> java.io.ObjectInputStream.readObject() *
            --> java.io.ObjectOutputStream.ObjectOutputStream(java.io.OutputStream) *
            --> java.io.ObjectOutputStream.close() *
            --> java.io.ObjectOutputStream.writeObject(java.lang.Object) *
            --> java.io.OutputStream *
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.out *
    try1
        <-- am.englet.try1$try2.this$0
        <-- am.englet.try1$try2.try1$try2(am.englet.try1)
        <-- am.englet.try1$try2.try1()
        --> java.lang.Cloneable *
        --> java.lang.Object *
        bb
            <-- am.englet.try1.main(java.lang.String[])
            <-- am.englet.try1.try1()
            --> java.lang.StringBuffer *
        clone()
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.try1.main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.lang.CloneNotSupportedException *
            --> java.lang.Object *
            --> java.lang.Object.clone() *
            --> java.lang.String *
            --> java.lang.System.out *
        main(java.lang.String[])
            --> am.englet.try1$try2
            --> am.englet.try1$try2.clone()
            --> am.englet.try1$try2.try1$try2(am.englet.try1)
            --> am.englet.try1$try2.try1()
            --> am.englet.try1.bb
            --> am.englet.try1.clone()
            --> am.englet.try1.try1()
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.System.out *
        try1()
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.try1.bb
            <-- am.englet.try1.main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.System.out *
    try1$try2
        <-- am.englet.try1.main(java.lang.String[])
        --> java.lang.Cloneable *
        --> java.lang.Object *
        clone()
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.try1.main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.lang.CloneNotSupportedException *
            --> java.lang.Object *
            --> java.lang.Object.clone() *
            --> java.lang.String *
            --> java.lang.System.out *
        this$0
            --> am.englet.try1
            <-- am.englet.try1$try2.try1$try2(am.englet.try1)
            <-- am.englet.try1$try2.try1()
        try1$try2(am.englet.try1)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.try1
            --> am.englet.try1$try2.this$0
            <-- am.englet.try1.main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.System.out *
        try1()
            --> am.englet.try1
            --> am.englet.try1$try2.this$0
            <-- am.englet.try1.main(java.lang.String[])
    try2
        --> java.lang.Object *
        main(java.lang.String[])
            --> am.englet.try2$1.p() *
            --> am.englet.try2$1.try2$1()
            --> am.englet.try2$2.p() *
            --> am.englet.try2$2.try2$2()
            --> am.englet.try2$A.p()
            --> am.englet.try2$A.try2$A()
            --> java.lang.String *
        try2()
            --> java.lang.Object.Object() *
    try2$1
        --> am.englet.try2$A
        p() *
            <-- am.englet.try2.main(java.lang.String[])
        try2$1()
            --> am.englet.try2$A.try2$A()
            <-- am.englet.try2.main(java.lang.String[])
    try2$2
        --> am.englet.try2$A
        a()
        p() *
            <-- am.englet.try2.main(java.lang.String[])
        try2$2()
            --> am.englet.try2$A.try2$A()
            <-- am.englet.try2.main(java.lang.String[])
    try2$A
        <-- am.englet.try2$1
        <-- am.englet.try2$2
        --> java.lang.Object *
        a()
        p()
            <-- am.englet.try2.main(java.lang.String[])
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Class.getDeclaredMethods() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.System.out *
            --> java.lang.reflect.Method *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        try2$A()
            <-- am.englet.try2$1.try2$1()
            <-- am.englet.try2$2.try2$2()
            <-- am.englet.try2.main(java.lang.String[])
            --> java.lang.Object.Object() *
am.englet.bsh
    Management
        --> java.lang.Object *
        Management()
            --> java.lang.Object.Object() *
        adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            --> am.englet.Invokable
            --> am.englet.MethodsStorage
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            --> am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            --> am.englet.bsh.MethodInvokable.MethodInvokable(bsh.BshMethod)
            --> bsh.BshMethod *
            --> java.lang.String *
        adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            --> am.englet.MethodsStorage
            --> am.englet.SingletonPool
            --> am.englet.SingletonPool.getSingleton(java.lang.Class)
            --> am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            --> am.englet.bsh.Management.class$0
            --> am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            --> bsh.BshMethod *
            --> bsh.BshMethod[] *
            --> bsh.Interpreter *
            --> bsh.Interpreter.source(java.lang.String) *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        class$0
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            --> java.lang.Class *
        putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            --> am.englet.MethodsStorage
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            --> bsh.BshMethod *
            --> bsh.BshMethod.getName() *
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.System.out *
            --> java.util.ArrayList *
            --> java.util.Collections.list(java.util.Enumeration) *
            --> java.util.Enumeration *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.get(java.lang.Object) *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.StringTokenizer.StringTokenizer(java.lang.String) *
    MethodInvokable
        --> am.englet.Invokable
        --> java.lang.Object *
        MethodInvokable(bsh.BshMethod)
            <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
            --> am.englet.bsh.MethodInvokable.method
            <-- am.englet.bsh.MethodInvokableMetadata.invokable()
            --> bsh.BshMethod *
            --> java.lang.Object.Object() *
        class$0
            <-- am.englet.bsh.MethodInvokable.targetType()
            --> java.lang.Class *
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.bsh.MethodInvokable.method
            --> bsh.BshMethod *
            --> bsh.BshMethod.invoke(java.lang.Object[], bsh.Interpreter) *
            --> bsh.EvalError *
            --> bsh.EvalError.getMessage() *
            --> bsh.EvalError.getScriptStackTrace() *
            --> bsh.Interpreter *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Throwable *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.InvocationTargetException.InvocationTargetException(java.lang.Throwable, java.lang.String) *
        method
            <-- am.englet.bsh.MethodInvokable.MethodInvokable(bsh.BshMethod)
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.bsh.MethodInvokable.parameterTypes()
            <-- am.englet.bsh.MethodInvokable.returnType()
            <-- am.englet.bsh.MethodInvokable.toString()
            --> bsh.BshMethod *
        parameterTypes()
            --> am.englet.bsh.MethodInvokable.method
            --> bsh.BshMethod *
            --> bsh.BshMethod.getParameterTypes() *
            --> java.lang.Class *
        returnType()
            --> am.englet.bsh.MethodInvokable.method
            --> bsh.BshMethod *
            --> bsh.BshMethod.getReturnType() *
            --> java.lang.Class *
        targetType()
            --> am.englet.bsh.MethodInvokable.class$0
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        toString()
            --> am.englet.bsh.MethodInvokable.method
            --> bsh.BshMethod *
            --> bsh.BshMethod.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    MethodInvokableMetadata
        --> am.englet.MethodsStorage$MethodRecord$InvokableMetadata
        --> java.lang.Object *
        MethodInvokableMetadata(bsh.BshMethod)
            --> am.englet.bsh.MethodInvokableMetadata.method
            --> bsh.BshMethod *
            --> java.lang.Object.Object() *
        class$0
            <-- am.englet.bsh.MethodInvokableMetadata.targetType()
            --> java.lang.Class *
        invokable()
            --> am.englet.Invokable
            --> am.englet.bsh.MethodInvokable.MethodInvokable(bsh.BshMethod)
            --> am.englet.bsh.MethodInvokableMetadata.method
            --> bsh.BshMethod *
        isStatic()
        method
            <-- am.englet.bsh.MethodInvokableMetadata.MethodInvokableMetadata(bsh.BshMethod)
            <-- am.englet.bsh.MethodInvokableMetadata.invokable()
            --> bsh.BshMethod *
        targetType()
            --> am.englet.bsh.MethodInvokableMetadata.class$0
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
am.englet.cast
    AbstractCaster
        --> am.englet.cast.Caster
        <-- am.englet.cast.PerfomerBasedAbstractCaster
        <-- am.englet.cast.SameObjectCaster
        --> java.lang.Object *
        AbstractCaster()
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> java.lang.Object.Object() *
        AbstractCaster(java.lang.Class, java.lang.Class)
            --> am.englet.cast.AbstractCaster.source
            --> am.englet.cast.AbstractCaster.target
            <-- am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        source
            <-- am.englet.cast.AbstractCaster.AbstractCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.AbstractCaster.source()
            --> java.lang.Class *
        source()
            --> am.englet.cast.AbstractCaster.source
            --> java.lang.Class *
        target
            <-- am.englet.cast.AbstractCaster.AbstractCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.AbstractCaster.target()
            --> java.lang.Class *
        target()
            --> am.englet.cast.AbstractCaster.target
            --> java.lang.Class *
    CastException
        --> java.lang.RuntimeException *
        CastException()
            --> java.lang.RuntimeException.RuntimeException() *
        CastException(java.lang.String)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            --> java.lang.RuntimeException.RuntimeException(java.lang.String) *
            --> java.lang.String *
        CastException(java.lang.String, java.lang.Throwable)
            <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
            --> java.lang.RuntimeException.RuntimeException(java.lang.String, java.lang.Throwable) *
            --> java.lang.String *
            --> java.lang.Throwable *
        CastException(java.lang.Throwable)
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.Throwable *
        serialVersionUID
    CastUtils
        --> java.lang.Object *
        CastUtils()
            --> java.lang.Object.Object() *
        add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterBank.add(am.englet.cast.Caster)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterBank.add(am.englet.cast.Caster)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.NULL
            --> am.englet.cast.CasterProvider.lookUpBySource(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.Collection.removeAll(java.util.Collection) *
            --> java.util.Collection.toArray(java.lang.Object[]) *
            --> java.util.HashSet.HashSet(java.util.Collection) *
            --> java.util.List *
        addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterProvider
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.NULL
            --> am.englet.cast.CasterProvider.lookUpByTarget(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.Collection.removeAll(java.util.Collection) *
            --> java.util.Collection.toArray(java.lang.Object[]) *
            --> java.util.HashSet.HashSet(java.util.Collection) *
            --> java.util.List *
        addByTarget(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterProvider
            --> java.lang.Class *
        addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterBank.add(am.englet.cast.Caster)
            --> am.englet.cast.CasterProvider
            --> java.lang.Class *
        chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            --> java.lang.Class *
        chain(java.lang.Class[], am.englet.cast.CasterProvider)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
    Caster
        <-- am.englet.CastingContextImpl1.add(am.englet.cast.Caster)
        <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.AbstractCaster
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterBank.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ChainCaster
        <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ChainCaster.c1
        <-- am.englet.cast.ChainCaster.c2
        <-- am.englet.cast.ChainCaster.cast(java.lang.Object)
        <-- am.englet.cast.ChainCaster.source()
        <-- am.englet.cast.ChainCaster.target()
        <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ForkCaster
        <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
        <-- am.englet.cast.ForkCaster.elseCaster
        <-- am.englet.cast.ForkCaster.ifCaster
        <-- am.englet.cast.ForkCaster.source()
        <-- am.englet.cast.ForkCaster.target()
        <-- am.englet.cast.PerfomerBasedAbstractCaster
        <-- am.englet.cast.SameObjectCaster
        <-- am.englet.cast.SameObjectCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.SameObjectCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster
        <-- am.englet.cast.ToStringCaster
        --> java.lang.Object *
        cast(java.lang.Object)
            <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
            <-- am.englet.cast.ChainCaster.cast(java.lang.Object)
            <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
            --> java.lang.Object *
        source()
            <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.source()
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.source()
            --> java.lang.Class *
        target()
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.target()
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.target()
            --> java.lang.Class *
    CasterBank
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterBankCasterProvider
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        --> java.lang.Object *
        add(am.englet.cast.Caster)
            <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
    CasterBankCasterProvider
        <-- am.englet.CastingContextImpl1
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.add(am.englet.cast.Caster)
        <-- am.englet.CastingContextImpl1.bank
        --> am.englet.cast.CasterBank
        <-- am.englet.cast.CasterBankCasterProviderImpl
        --> am.englet.cast.CasterProvider
        --> java.lang.Object *
        add(am.englet.cast.Caster) *
            <-- am.englet.CastingContextImpl1.add(am.englet.cast.Caster)
    CasterBankCasterProviderImpl
        --> am.englet.cast.CasterBankCasterProvider
        --> java.lang.Object *
        CasterBankCasterProviderImpl()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> am.englet.cast.CasterBankCasterProviderImpl.backIndex
            --> am.englet.cast.CasterBankCasterProviderImpl.casterTargets
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        NULL *
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        add(am.englet.cast.Caster)
            --> am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.Caster.target()
            --> am.englet.cast.CasterBankCasterProviderImpl.backIndex
            --> am.englet.cast.CasterBankCasterProviderImpl.class$1
            --> am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Collection *
            --> java.util.Collection.add(java.lang.Object) *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        backIndex
            <-- am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
            --> java.util.Map *
        casterTargets
            <-- am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
            --> java.util.Map *
        class$0
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            --> java.lang.Class *
        ensuredCastersTo(java.lang.Class)
            --> am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            --> am.englet.cast.CasterBankCasterProviderImpl.casterTargets
            --> am.englet.cast.CasterBankCasterProviderImpl.class$0
            <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Map *
        getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        lookUpBySource(java.lang.Class)
            --> am.englet.cast.CasterBankCasterProviderImpl.NULL *
            --> am.englet.cast.CasterBankCasterProviderImpl.backIndex
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Collection *
            --> java.util.Collection.toArray(java.lang.Object[]) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        lookUpByTarget(java.lang.Class)
            --> am.englet.cast.CasterBankCasterProviderImpl.NULL *
            --> am.englet.cast.CasterBankCasterProviderImpl.casterTargets
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.toArray(java.lang.Object[]) *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            --> java.lang.Object *
    CasterProvider
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterBankCasterProvider
        <-- am.englet.cast.CasterProvidersBank
        <-- am.englet.cast.CasterProvidersBank.add(am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterProvidersPool.add(am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.ConstructorBasedCasterProvider
        <-- am.englet.cast.SameObjectCasterProvider
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.prov
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        --> java.lang.Object *
        NULL
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CasterProvider.static {}
            --> java.lang.Class *
        getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
            <-- am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            --> java.lang.Class *
        lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            --> java.lang.Class *
        static {}
            --> am.englet.cast.CasterProvider.NULL
            --> java.lang.Class *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
            --> java.lang.Object *
    CasterProvidersBank
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.lookUpBySource(java.lang.Class)
        <-- am.englet.CastingContextImpl1.lookUpByTarget(java.lang.Class)
        <-- am.englet.CastingContextImpl1.provPool
        <-- am.englet.CastingContextImpl1.wrapToImplementor(java.lang.Object)
        --> am.englet.cast.CasterProvider
        <-- am.englet.cast.CasterProvidersPool
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        --> java.lang.Object *
        add(am.englet.cast.CasterProvider)
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> am.englet.cast.CasterProvider
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        getImplementor(java.lang.Class, java.lang.Class) *
            <-- am.englet.CastingContextImpl1.getImplementor(java.lang.Class, java.lang.Class)
        lookUpBySource(java.lang.Class) *
            <-- am.englet.CastingContextImpl1.lookUpBySource(java.lang.Class)
        lookUpByTarget(java.lang.Class) *
            <-- am.englet.CastingContextImpl1.lookUpByTarget(java.lang.Class)
        wrapToImplementor(java.lang.Object) *
            <-- am.englet.CastingContextImpl1.wrapToImplementor(java.lang.Object)
    CasterProvidersPool
        --> am.englet.cast.CasterProvidersBank
        --> java.lang.Object *
        CasterProvidersPool()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            --> am.englet.cast.CasterProvidersPool.providers
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Object.Object() *
            --> java.util.Vector *
            --> java.util.Vector.Vector() *
        NULL *
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        add(am.englet.cast.CasterProvider)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersPool.providers
            --> java.lang.Object *
            --> java.util.Vector *
            --> java.util.Vector.insertElementAt(java.lang.Object, int) *
        getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.CasterProvidersPool.providers
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Vector *
            --> java.util.Vector.iterator() *
        lookUpBySource(java.lang.Class)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.lookUpBySource(java.lang.Class)
            --> am.englet.cast.CasterProvidersPool.NULL *
            --> am.englet.cast.CasterProvidersPool.providers
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.HashSet.HashSet() *
            --> java.util.HashSet.addAll(java.util.Collection) *
            --> java.util.HashSet.toArray(java.lang.Object[]) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.Vector *
            --> java.util.Vector.iterator() *
        lookUpByTarget(java.lang.Class)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.lookUpByTarget(java.lang.Class)
            --> am.englet.cast.CasterProvidersPool.NULL *
            --> am.englet.cast.CasterProvidersPool.providers
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.HashSet.HashSet() *
            --> java.util.HashSet.addAll(java.util.Collection) *
            --> java.util.HashSet.toArray(java.lang.Object[]) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.Vector *
            --> java.util.Vector.iterator() *
        providers
            <-- am.englet.cast.CasterProvidersPool.CasterProvidersPool()
            <-- am.englet.cast.CasterProvidersPool.add(am.englet.cast.CasterProvider)
            <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
            --> java.util.Vector *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.wrapToImplementor(java.lang.Object)
            --> am.englet.cast.CasterProvidersPool.providers
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Vector *
            --> java.util.Vector.iterator() *
    ChainCaster
        --> am.englet.cast.Caster
        --> java.lang.Object *
        ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.Caster.target()
            --> am.englet.cast.ChainCaster.c1
            --> am.englet.cast.ChainCaster.c2
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.Object.Object() *
            --> java.lang.String *
        c1
            --> am.englet.cast.Caster
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.cast(java.lang.Object)
            <-- am.englet.cast.ChainCaster.source()
        c2
            --> am.englet.cast.Caster
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ChainCaster.cast(java.lang.Object)
            <-- am.englet.cast.ChainCaster.target()
        cast(java.lang.Object)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.cast(java.lang.Object)
            --> am.englet.cast.ChainCaster.c1
            --> am.englet.cast.ChainCaster.c2
            --> java.lang.Object *
        source()
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.ChainCaster.c1
            --> java.lang.Class *
        target()
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.target()
            --> am.englet.cast.ChainCaster.c2
            --> java.lang.Class *
    ClassCastChainFinder
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.finder
        <-- am.englet.cast.TargetToSourseClassCastChainFinder
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        --> java.lang.Object *
        findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            --> am.englet.cast.CasterProvider
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            --> java.lang.Class *
    ClassPool
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_processing_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.add_url(java.net.URL, am.englet.cast.ClassPool)
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        <-- am.englet.Management.asClass(am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.import_package(am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        --> am.englet.ServiceObject
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.Utils.deriveEnglet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool$1.this$0
        <-- am.englet.cast.StringToClassCaster.StringToClassCaster()
        <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster.classPool
        <-- am.englet.cast.StringToClassCaster.importPackages(java.lang.String[])
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.access$0(am.englet.wiring.PoolsBuilder)
        <-- am.englet.wiring.PoolsBuilder.classPool
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.wire()
        --> java.lang.Object *
        BASE_PKGS
            --> java.lang.String *
        ClassPool()
            <-- am.englet.Englet.Englet()
            --> am.englet.cast.ClassPool$classLoader
            --> am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader)
            --> am.englet.cast.ClassPool.classLoader
            --> am.englet.cast.ClassPool.classes
            --> am.englet.cast.ClassPool.impls
            --> am.englet.cast.ClassPool.importPackages(java.lang.String[])
            --> am.englet.cast.ClassPool.importedPackages
            <-- am.englet.cast.StringToClassCaster.StringToClassCaster()
            --> java.lang.Boolean.TYPE *
            --> java.lang.Byte.TYPE *
            --> java.lang.Character.TYPE *
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getSystemClassLoader() *
            --> java.lang.Double.TYPE *
            --> java.lang.Float.TYPE *
            --> java.lang.Integer.TYPE *
            --> java.lang.Long.TYPE *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Short.TYPE *
            --> java.lang.String *
            --> java.lang.String.replaceAll(java.lang.String, java.lang.String) *
            --> java.lang.String.split(java.lang.String) *
            --> java.lang.String.trim() *
            --> java.lang.Void.TYPE *
            --> java.net.URL *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        access$0(am.englet.cast.ClassPool)
            <-- am.englet.cast.ClassPool$1.nextValue()
            --> am.englet.cast.ClassPool.importedPackages
            --> java.util.Map *
        access$1(am.englet.cast.ClassPool, java.lang.String, java.lang.String, java.lang.String)
            <-- am.englet.cast.ClassPool$1.nextValue()
            --> am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        addImpl(java.lang.Class)
            --> am.englet.Utils.assignTargetsSet(java.lang.Class)
            --> am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        addURL(java.net.URL)
            <-- am.englet.Management.add_url(java.net.URL, am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool$classLoader
            --> am.englet.cast.ClassPool$classLoader.addURL(java.net.URL)
            --> am.englet.cast.ClassPool.class$2
            --> am.englet.cast.ClassPool.class$3
            --> am.englet.cast.ClassPool.classLoader
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getDeclaredMethod(java.lang.String, java.lang.Class[]) *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getSystemClassLoader() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.IllegalArgumentException *
            --> java.lang.IllegalArgumentException.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.NoSuchMethodException *
            --> java.lang.NoSuchMethodException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.SecurityException.printStackTrace() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.InvocationTargetException.printStackTrace() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
            --> java.lang.reflect.Method.isAccessible() *
            --> java.lang.reflect.Method.setAccessible(boolean) *
            --> java.net.URL *
            --> java.net.URLClassLoader *
        class$0
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            --> java.lang.Class *
        class$2
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            --> java.lang.Class *
        class$3
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            --> java.lang.Class *
        classLoader
            --> am.englet.cast.ClassPool$classLoader
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        classes
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.forName(java.lang.String)
            <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> java.util.Map *
        findClass(java.lang.String)
            --> am.englet.Utils.packageNameToPackagePath(java.lang.String)
            --> am.englet.Utils.simpleClassname(java.lang.String)
            <-- am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            --> am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.indexOf(int) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
        forName(java.lang.String)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            <-- am.englet.Management.asClass(am.englet.cast.ClassPool, java.lang.String)
            <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
            <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool.classes
            --> am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
            <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        foundClassesIterator(java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            --> am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            --> am.englet.cast.ClassPool.importedPackages
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Map *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        getImpl(java.lang.Class)
            --> am.englet.cast.ClassPool.impls
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        getResource(java.lang.String)
            --> am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
            --> am.englet.cast.ClassPool$classLoader
            --> am.englet.cast.ClassPool.class$1
            --> am.englet.cast.ClassPool.classLoader
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.net.URL *
        impls
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.getImpl(java.lang.Class)
            <-- am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
            --> java.util.Map *
        importAlias(java.lang.String, java.lang.String)
            --> am.englet.cast.ClassPool.classes
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        importPackage(java.lang.String)
            <-- am.englet.Management.import_package(am.englet.cast.ClassPool, java.lang.String)
            --> am.englet.Utils.packageNameToPackagePath(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackages(java.lang.String[])
            --> am.englet.cast.ClassPool.importedPackages
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        importPackages(java.lang.String[])
            <-- am.englet.cast.ClassPool.ClassPool()
            --> am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.cast.StringToClassCaster.importPackages(java.lang.String[])
            <-- am.englet.wiring.PoolsBuilder.doImports()
            --> java.lang.String *
        importedPackages
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.access$0(am.englet.cast.ClassPool)
            <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            --> java.util.Map *
        setImpl(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
            --> am.englet.cast.ClassPool.impls
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        tryResource(java.lang.String, java.lang.String, java.lang.String)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            --> am.englet.cast.ClassPool$classLoader
            <-- am.englet.cast.ClassPool.access$1(am.englet.cast.ClassPool, java.lang.String, java.lang.String, java.lang.String)
            --> am.englet.cast.ClassPool.classLoader
            --> am.englet.cast.ClassPool.classes
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            --> am.englet.cast.ClassPool.getResource(java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String, boolean, java.lang.ClassLoader) *
            --> java.lang.ClassLoader *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.err *
            --> java.lang.Throwable *
            --> java.net.URL *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
    ClassPool$1
        --> java.lang.Object *
        --> java.util.Iterator *
        ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool$1.nextValue
            --> am.englet.cast.ClassPool$1.this$0
            --> am.englet.cast.ClassPool$1.val$iterator
            --> am.englet.cast.ClassPool$1.val$name
            --> am.englet.cast.ClassPool$1.wasNext
            --> am.englet.cast.ClassPool.class$0
            <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Iterator *
        hasNext()
            --> am.englet.cast.ClassPool$1.nextValue
            --> am.englet.cast.ClassPool$1.provideNextValue1()
            --> am.englet.cast.ClassPool$1.wasNext
            --> java.lang.Class *
        next()
            --> am.englet.cast.ClassPool$1.nextValue
            --> am.englet.cast.ClassPool$1.provideNextValue1()
            --> am.englet.cast.ClassPool$1.wasNext
            --> java.lang.Class *
            --> java.lang.Object *
        nextValue
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool$1.hasNext()
            <-- am.englet.cast.ClassPool$1.next()
            <-- am.englet.cast.ClassPool$1.provideNextValue1()
            --> java.lang.Class *
        nextValue()
            --> am.englet.cast.ClassPool
            <-- am.englet.cast.ClassPool$1.provideNextValue1()
            --> am.englet.cast.ClassPool$1.this$0
            --> am.englet.cast.ClassPool$1.val$iterator
            --> am.englet.cast.ClassPool$1.val$name
            --> am.englet.cast.ClassPool.access$0(am.englet.cast.ClassPool)
            --> am.englet.cast.ClassPool.access$1(am.englet.cast.ClassPool, java.lang.String, java.lang.String, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        provideNextValue1()
            <-- am.englet.cast.ClassPool$1.hasNext()
            <-- am.englet.cast.ClassPool$1.next()
            --> am.englet.cast.ClassPool$1.nextValue
            --> am.englet.cast.ClassPool$1.nextValue()
            --> am.englet.cast.ClassPool$1.wasNext
            --> java.lang.Class *
        remove()
        this$0
            --> am.englet.cast.ClassPool
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool$1.nextValue()
        val$iterator
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool$1.nextValue()
            --> java.util.Iterator *
        val$name
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool$1.nextValue()
            --> java.lang.String *
        wasNext
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool$1.hasNext()
            <-- am.englet.cast.ClassPool$1.next()
            <-- am.englet.cast.ClassPool$1.provideNextValue1()
    ClassPool$classLoader
        <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.classLoader
        <-- am.englet.cast.ClassPool.getResource(java.lang.String)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        --> java.net.URLClassLoader *
        ClassPool$classLoader(java.net.URL[])
            --> java.net.URL *
            --> java.net.URLClassLoader.URLClassLoader(java.net.URL[]) *
        ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader)
            <-- am.englet.cast.ClassPool.ClassPool()
            --> java.lang.ClassLoader *
            --> java.net.URL *
            --> java.net.URLClassLoader.URLClassLoader(java.net.URL[], java.lang.ClassLoader) *
        ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
            --> java.lang.ClassLoader *
            --> java.net.URL *
            --> java.net.URLClassLoader.URLClassLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory) *
            --> java.net.URLStreamHandlerFactory *
        addURL(java.net.URL)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            --> java.net.URL *
            --> java.net.URLClassLoader.addURL(java.net.URL) *
        getResource(java.lang.String) *
            <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
    ConstructorBasedCaster
        --> am.englet.cast.PerfomerBasedAbstractCaster
        ConstructorBasedCaster(java.lang.reflect.Constructor)
            <-- am.englet.cast.ConstructorBasedCasterProvider.wrapToImplementor(java.lang.Object)
            --> am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Constructor *
        doCast(java.lang.Object)
            --> am.englet.cast.ConstructorBasedCaster.getCon()
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
            --> java.lang.reflect.InvocationTargetException *
        getCon()
            <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
            --> am.englet.cast.ConstructorBasedCaster.performer *
            <-- am.englet.cast.ConstructorBasedCaster.sourceClass()
            <-- am.englet.cast.ConstructorBasedCaster.targetClass()
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        performer *
            <-- am.englet.cast.ConstructorBasedCaster.getCon()
        sourceClass()
            --> am.englet.cast.ConstructorBasedCaster.getCon()
            --> java.lang.Class *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
        targetClass()
            --> am.englet.cast.ConstructorBasedCaster.getCon()
            --> java.lang.Class *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getDeclaringClass() *
    ConstructorBasedCasterProvider
        --> am.englet.cast.CasterProvider
        --> java.lang.Object *
        ConstructorBasedCasterProvider()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Object.Object() *
        NULL *
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
        getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.ConstructorBasedCasterProvider.wrapToImplementor(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.getConstructor(java.lang.Class[]) *
            --> java.lang.Class.getConstructors() *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
        lookUpBySource(java.lang.Class)
            --> am.englet.cast.ConstructorBasedCasterProvider.NULL *
            --> java.lang.Class *
        lookUpByTarget(java.lang.Class)
            --> am.englet.cast.ConstructorBasedCasterProvider.NULL *
            --> am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Collection *
            --> java.util.Collection.toArray(java.lang.Object[]) *
        lookUpCollectionByTarget(java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getConstructors() *
            --> java.lang.Object *
            --> java.lang.SecurityException *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
            --> java.util.Collection *
            --> java.util.Collection.add(java.lang.Object) *
            --> java.util.HashSet.HashSet() *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            --> am.englet.cast.ConstructorBasedCaster.ConstructorBasedCaster(java.lang.reflect.Constructor)
            <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
    ForkCaster
        --> am.englet.cast.Caster
        --> java.lang.Object *
        ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.Caster.target()
            --> am.englet.cast.ForkCaster.discriminator
            --> am.englet.cast.ForkCaster.elseCaster
            --> am.englet.cast.ForkCaster.ifCaster
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
        cast(java.lang.Object)
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.cast(java.lang.Object)
            --> am.englet.cast.ForkCaster.discriminator
            --> am.englet.cast.ForkCaster.elseCaster
            --> am.englet.cast.ForkCaster.ifCaster
            --> java.lang.Class *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.Object *
        discriminator
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
            --> java.lang.Class *
        elseCaster
            --> am.englet.cast.Caster
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
            <-- am.englet.cast.ForkCaster.source()
            <-- am.englet.cast.ForkCaster.target()
        ifCaster
            --> am.englet.cast.Caster
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
        source()
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.source()
            --> am.englet.cast.ForkCaster.elseCaster
            --> java.lang.Class *
        target()
            --> am.englet.cast.Caster
            --> am.englet.cast.Caster.target()
            --> am.englet.cast.ForkCaster.elseCaster
            --> java.lang.Class *
    InstanceMethodBasedCaster
        --> am.englet.cast.MethodBasedCaster
        InstanceMethodBasedCaster(java.lang.reflect.Method)
            --> am.englet.cast.MethodBasedCaster.MethodBasedCaster(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        doCast(java.lang.Object)
            --> am.englet.cast.InstanceMethodBasedCaster.method() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        method() *
            <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
            <-- am.englet.cast.InstanceMethodBasedCaster.sourceClass()
        sourceClass()
            --> am.englet.cast.InstanceMethodBasedCaster.method() *
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getDeclaringClass() *
    MethodBasedCaster
        <-- am.englet.cast.InstanceMethodBasedCaster
        --> am.englet.cast.PerfomerBasedAbstractCaster
        <-- am.englet.cast.StaticFactoryMethodBasedCaster
        MethodBasedCaster(java.lang.Object)
            <-- am.englet.cast.InstanceMethodBasedCaster.InstanceMethodBasedCaster(java.lang.reflect.Method)
            --> am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            <-- am.englet.cast.StaticFactoryMethodBasedCaster.StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
            --> java.lang.Object *
            --> java.lang.String *
        method()
            --> am.englet.cast.MethodBasedCaster.performer *
            <-- am.englet.cast.MethodBasedCaster.targetClass()
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        performer *
            <-- am.englet.cast.MethodBasedCaster.method()
        targetClass()
            --> am.englet.cast.MethodBasedCaster.method()
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
    PerfomerBasedAbstractCaster
        --> am.englet.cast.AbstractCaster
        --> am.englet.cast.Caster
        <-- am.englet.cast.ConstructorBasedCaster
        <-- am.englet.cast.MethodBasedCaster
        PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> am.englet.cast.AbstractCaster.AbstractCaster()
            <-- am.englet.cast.ConstructorBasedCaster.ConstructorBasedCaster(java.lang.reflect.Constructor)
            <-- am.englet.cast.MethodBasedCaster.MethodBasedCaster(java.lang.Object)
            --> am.englet.cast.PerfomerBasedAbstractCaster.message
            --> am.englet.cast.PerfomerBasedAbstractCaster.performer
            --> am.englet.cast.PerfomerBasedAbstractCaster.source *
            --> am.englet.cast.PerfomerBasedAbstractCaster.sourceClass()
            --> am.englet.cast.PerfomerBasedAbstractCaster.target *
            --> am.englet.cast.PerfomerBasedAbstractCaster.targetClass()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        cast(java.lang.Object)
            --> am.englet.cast.CastException.CastException(java.lang.String, java.lang.Throwable)
            --> am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
            --> am.englet.cast.PerfomerBasedAbstractCaster.message
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable *
        doCast(java.lang.Object)
            <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        message
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
            --> java.lang.String *
        performer
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> java.lang.Object *
        source *
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
        sourceClass()
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> java.lang.Class *
        target *
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
        targetClass()
            <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
            --> java.lang.Class *
    SameObjectCaster
        --> am.englet.cast.AbstractCaster
        --> am.englet.cast.Caster
        SameObjectCaster(java.lang.Class, java.lang.Class)
            --> am.englet.cast.AbstractCaster.AbstractCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.SameObjectCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.String *
        cast(java.lang.Object)
            --> am.englet.cast.SameObjectCaster.source *
            --> java.lang.Class *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.IllegalArgumentException.IllegalArgumentException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
        source *
            <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
    SameObjectCasterProvider
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.sameProv
        --> am.englet.ServiceObject
        --> am.englet.cast.CasterProvider
        <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
        <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.prov
        --> java.lang.Object *
        NULL *
            <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.SameObjectCasterProvider.lookUpByTarget(java.lang.Class)
        SameObjectCasterProvider()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            --> java.lang.Object.Object() *
        getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
        lookUpBySource(java.lang.Class)
            --> am.englet.Utils.assignTargetsSet(java.lang.Class)
            --> am.englet.cast.SameObjectCasterProvider.NULL *
            <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.Set *
            --> java.util.Set.toArray(java.lang.Object[]) *
        lookUpByTarget(java.lang.Class)
            --> am.englet.cast.SameObjectCasterProvider.NULL *
            --> java.lang.Class *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            --> java.lang.Object *
    StaticFactoryMethodBasedCaster
        --> am.englet.cast.MethodBasedCaster
        StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
            --> am.englet.cast.MethodBasedCaster.MethodBasedCaster(java.lang.Object)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.reflect.Method *
        doCast(java.lang.Object)
            --> am.englet.cast.StaticFactoryMethodBasedCaster.method() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object[]) *
        method() *
            <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
            <-- am.englet.cast.StaticFactoryMethodBasedCaster.sourceClass()
        sourceClass()
            --> am.englet.cast.StaticFactoryMethodBasedCaster.method() *
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
    StaticFactoryMethodBasedCasterProvider
        --> am.englet.cast.CasterProvider
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.this$0
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.this$0
        --> java.lang.Object *
        NULL *
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        StaticFactoryMethodBasedCasterProvider()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Object.Object() *
        class$0
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        getImplementor(java.lang.Class, java.lang.Class)
            --> am.englet.cast.Caster
            --> am.englet.cast.StaticFactoryMethodBasedCaster.StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.method(int, int) *
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$0
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
        lookUpBySource(java.lang.Class)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.NULL *
            --> java.lang.Class *
        lookUpByTarget(java.lang.Class)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.$(int, int) *
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.NULL *
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List *
            --> java.util.List.toArray(java.lang.Object[]) *
        wrapToImplementor(java.lang.Object)
            --> am.englet.cast.Caster
            --> am.englet.cast.StaticFactoryMethodBasedCaster.StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Modifier.isStatic(int) *
    StaticFactoryMethodBasedCasterProvider$1
        --> am.englet.$
        StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.this$0
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> java.lang.Class *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
        method(int, int) *
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        this$0
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
    StaticFactoryMethodBasedCasterProvider$2
        --> am.englet.$
        $(int, int) *
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.this$0
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$cls
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$res
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
            --> java.lang.Class *
            --> java.util.List *
        each(java.lang.reflect.Method)
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$cls
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$res
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$0
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        this$0
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
        val$cls
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            --> java.lang.Class *
        val$res
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            --> java.util.List *
    StringToClassCaster
        --> am.englet.cast.Caster
        --> java.lang.Object *
        StringToClassCaster()
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.ClassPool()
            --> am.englet.cast.StringToClassCaster.classPool
            --> java.lang.Object.Object() *
        cast(java.lang.Object)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.cast.StringToClassCaster.classPool
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        class$0
            <-- am.englet.cast.StringToClassCaster.source()
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.StringToClassCaster.target()
            --> java.lang.Class *
        classPool
            --> am.englet.cast.ClassPool
            <-- am.englet.cast.StringToClassCaster.StringToClassCaster()
            <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
            <-- am.englet.cast.StringToClassCaster.importPackages(java.lang.String[])
        importPackages(java.lang.String[])
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.importPackages(java.lang.String[])
            --> am.englet.cast.StringToClassCaster.classPool
            --> java.lang.String *
        source()
            --> am.englet.cast.StringToClassCaster.class$0
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        target()
            --> am.englet.cast.StringToClassCaster.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
    TargetToSourseClassCastChainFinder
        --> am.englet.cast.ClassCastChainFinder
        --> java.lang.Object *
        TargetToSourseClassCastChainFinder()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Object.Object() *
        findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isFailed()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.successChain()
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.Link.next()
            --> java.lang.Class *
            --> java.lang.Class[] *
            --> java.lang.Object *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.toArray(java.lang.Object[]) *
    TargetToSourseClassCastChainFinder$SearchStep
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        --> java.lang.Object *
        TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.prov
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
            --> java.lang.Class *
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
            --> java.util.Set *
        TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.prov
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashSet.HashSet() *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
        getChain(java.lang.Class)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.successChain()
            --> am.englet.link.FinalLink
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        isFailed()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> java.util.Map *
            --> java.util.Map.size() *
        isSuccessfull()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
        prov
            --> am.englet.cast.CasterProvider
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        result
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isFailed()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            --> java.util.Map *
        source
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.successChain()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            --> java.lang.Class *
        step()
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvider.lookUpByTarget(java.lang.Class)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.prov
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.link.FinalLink
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.add(java.lang.Object) *
            --> java.util.Set.iterator() *
        stop(java.util.Collection)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
            --> java.util.Collection *
            --> java.util.Set *
            --> java.util.Set.addAll(java.util.Collection) *
        stopClasses
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stop(java.util.Collection)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            --> java.util.Set *
        successChain()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.link.FinalLink
            --> java.lang.Class *
        tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            --> am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.util.Map *
            --> java.util.Map.clear() *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
            --> java.util.Set.contains(java.lang.Object) *
    TargetToSourseClassCastChainFinderTest
        --> junit.framework.TestCase *
        TargetToSourseClassCastChainFinderTest()
            --> junit.framework.TestCase.TestCase() *
        class$0
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$2
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$3
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$4
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$5
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$6
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        class$7
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.lang.Class *
        print(java.lang.Class[])
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.System.out *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.ClassCastChainFinder
            --> am.englet.cast.ClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            --> java.io.PrintStream *
            --> java.io.PrintStream.print(java.lang.String) *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
        test1()
            --> am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
            --> am.englet.cast.CasterBank
            --> am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            --> am.englet.cast.CasterProvider
            --> am.englet.cast.CasterProvidersBank
            --> am.englet.cast.CasterProvidersBank.add(am.englet.cast.CasterProvider)
            --> am.englet.cast.CasterProvidersPool.CasterProvidersPool()
            --> am.englet.cast.ClassCastChainFinder
            --> am.englet.cast.ConstructorBasedCasterProvider.ConstructorBasedCasterProvider()
            --> am.englet.cast.SameObjectCasterProvider.SameObjectCasterProvider()
            --> am.englet.cast.StaticFactoryMethodBasedCasterProvider.StaticFactoryMethodBasedCasterProvider()
            --> am.englet.cast.TargetToSourseClassCastChainFinder.TargetToSourseClassCastChainFinder()
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$0
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$1
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$2
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$3
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$4
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$5
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$6
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.class$7
            --> am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
    ToStringCaster
        --> am.englet.cast.Caster
        --> java.lang.Object *
        ToStringCaster()
            --> java.lang.Object.Object() *
        cast(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
        class$0
            <-- am.englet.cast.ToStringCaster.source()
            --> java.lang.Class *
        class$1
            <-- am.englet.cast.ToStringCaster.target()
            --> java.lang.Class *
        source()
            --> am.englet.cast.ToStringCaster.class$0
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        target()
            --> am.englet.cast.ToStringCaster.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
am.englet.dispatch
    DispatcherRecord
        <-- am.englet.MethodsStorage$MethodRecord
        --> java.lang.Object *
        getParameterTypes()
            --> java.lang.Class *
    Utils
        --> java.lang.Object *
        Utils()
            --> java.lang.Object.Object() *
        search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> am.englet.CastingContext
            --> am.englet.CastingContext.canCast(java.lang.Class, java.lang.Class)
            --> am.englet.CodeBlock
            <-- am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
            --> am.englet.MethodsStorage$MethodRecord
            --> am.englet.MethodsStorage$MethodRecord.getParameterTypes()
            --> am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            --> am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
            --> am.englet.dispatch.Utils$1.Utils$1(java.lang.Class[])
            --> am.englet.dispatch.Utils$2.Utils$2(int, java.lang.Class[])
            --> am.englet.dispatch.Utils$3.Utils$3(java.lang.Class[])
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.System.out *
    Utils$1
        --> am.englet.CodeBlock
        Utils$1(java.lang.Class[])
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.dispatch.Utils$1.val$what
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        result()
            --> am.englet.dispatch.Utils$1.val$what
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$what
            <-- am.englet.dispatch.Utils$1.Utils$1(java.lang.Class[])
            <-- am.englet.dispatch.Utils$1.result()
            --> java.lang.Class *
    Utils$2
        --> am.englet.CodeBlock
        Utils$2(int, java.lang.Class[])
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.dispatch.Utils$2.val$classes
            --> am.englet.dispatch.Utils$2.val$i1
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        result()
            --> am.englet.dispatch.Utils$2.val$classes
            --> am.englet.dispatch.Utils$2.val$i1
            --> java.lang.Class *
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$classes
            <-- am.englet.dispatch.Utils$2.Utils$2(int, java.lang.Class[])
            <-- am.englet.dispatch.Utils$2.result()
            --> java.lang.Class *
        val$i1
            <-- am.englet.dispatch.Utils$2.Utils$2(int, java.lang.Class[])
            <-- am.englet.dispatch.Utils$2.result()
    Utils$3
        --> am.englet.CodeBlock
        Utils$3(java.lang.Class[])
            --> am.englet.CodeBlock.CodeBlock()
            --> am.englet.dispatch.Utils$3.val$what
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            --> java.lang.Class *
        result()
            --> am.englet.dispatch.Utils$3.val$what
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        val$what
            <-- am.englet.dispatch.Utils$3.Utils$3(java.lang.Class[])
            <-- am.englet.dispatch.Utils$3.result()
            --> java.lang.Class *
am.englet.inputtokenizers
    Act
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        --> am.englet.stateengine.Act
        APPEND
        Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.inputtokenizers.Act.performer
            --> am.englet.inputtokenizers.Act.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
            --> am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
        PUSHBACK
        SKIP
        act()
            --> am.englet.inputtokenizers.Act.performer
            --> am.englet.inputtokenizers.Act.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.getReaderToTokenizerAdapter()
            --> am.englet.stateengine.Act.act()
            --> java.lang.Object *
        addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object) *
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        clone(java.lang.Object, java.lang.Object, java.lang.Object) *
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        event *
            <-- am.englet.inputtokenizers.Act.toString()
        getPerformers()
            --> am.englet.inputtokenizers.Act.performer
            <-- am.englet.inputtokenizers.Act.toString()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.length() *
            --> java.lang.StringBuffer.substring(int) *
        performer
            <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            <-- am.englet.inputtokenizers.Act.act()
            <-- am.englet.inputtokenizers.Act.getPerformers()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        readerTokenizerEngine
            <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            <-- am.englet.inputtokenizers.Act.act()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
        result *
            <-- am.englet.inputtokenizers.Act.toString()
        state *
            <-- am.englet.inputtokenizers.Act.toString()
        toString()
            --> am.englet.inputtokenizers.Act.event *
            --> am.englet.inputtokenizers.Act.getPerformers()
            --> am.englet.inputtokenizers.Act.result *
            --> am.englet.inputtokenizers.Act.state *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    BackAdapterBasedIterator
        --> java.lang.Object *
        --> java.util.Iterator *
        BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.backAdapter
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.nextTried
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.storage
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.strategy
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.needsStorage()
            --> am.englet.link.Storage
            --> am.englet.link.StorageImpl.StorageImpl()
            --> java.lang.Object.Object() *
        backAdapter
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
            --> am.englet.link.BackAdapter
        hasNext
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext()
        hasNext()
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.nextTried
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
        next()
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.backAdapter
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.nextTried
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.storage
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.strategy
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.Storage
            --> java.lang.IllegalStateException.IllegalStateException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
        nextTried
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        remove()
        storage
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
            --> am.englet.link.Storage
        strategy
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
            --> am.englet.link.BackUsageStrategy
        tryNext()
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.backAdapter
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.hasNext()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.storage
            --> am.englet.inputtokenizers.BackAdapterBasedIterator.strategy
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.Storage
    EngletParserReaderToTokenizerAdapter
        --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
        BIG
            --> java.lang.String *
        CONTINUATING
            --> java.lang.String *
        ESC
            --> java.lang.String *
        EVENTS
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.event(int)
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
            --> java.lang.String *
        EngletParserReaderToTokenizerAdapter()
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object) *
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.readerTokenizerEngine *
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
            --> am.englet.stateengine.Engine
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.FINISHED
            --> java.lang.Object *
        EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object) *
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.readerTokenizerEngine *
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.init(java.lang.Object) *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
            --> am.englet.stateengine.Engine
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.FINISHED
            --> java.io.PushbackReader.PushbackReader(java.io.Reader) *
            --> java.io.Reader *
            --> java.lang.Object *
        FACTORY
            --> am.englet.ServiceTokenizerFactory
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
        ORDINAL
            --> java.lang.String *
        Q1
            --> java.lang.String *
        Q2
            --> java.lang.String *
        SPEC
            --> java.lang.String *
        STARTING
            --> java.lang.String *
        WS
            --> java.lang.String *
        event(int)
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EVENTS
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.event(int)
            --> java.lang.String *
        readerTokenizerEngine *
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        static {}
            --> am.englet.EngletParserReaderTokenizerFactory.EngletParserReaderTokenizerFactory()
            --> am.englet.ServiceTokenizerFactory
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EVENTS
            --> am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.FACTORY
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.toCharArray() *
            --> java.util.Arrays.fill(java.lang.Object[], int, int, java.lang.Object) *
    ReaderToTokenizerAdapter
        <-- am.englet.inputtokenizers.Act.act()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$Performer.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.getReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.readerToTokenizerAdapter
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
        --> am.englet.link.TrivialBaseBackAdapterImpl
        BASIC
            --> java.lang.String *
        EOF
            --> java.lang.String *
        INITIAL
            --> java.lang.String *
        ReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl()
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
        ReaderToTokenizerAdapter(java.lang.Object)
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> java.io.PushbackReader.PushbackReader(java.io.Reader) *
            --> java.io.Reader *
            --> java.lang.Object *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
        append()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.current
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(char) *
        append(int)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(char) *
        append(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.Object *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.append(java.lang.Object) *
        back *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
        buf
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(int)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            --> java.lang.StringBuffer *
        class$0
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            --> java.lang.Class *
        current
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
        event(int)
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.event(int)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.event(int)
            --> java.lang.String *
        getBack()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.back *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
            --> java.io.PushbackReader *
            --> java.lang.Object *
        getNext()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.finished() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.length() *
            --> java.lang.StringBuffer.setLength(int) *
            --> java.lang.StringBuffer.toString() *
        getReaderTokenizerEngine()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        metadata
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            --> am.englet.link.AdapterMetadata
        metadata()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata
            --> am.englet.link.AdapterMetadata
            --> java.io.PushbackReader *
            --> java.lang.Object *
        next1()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.current
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.event(int)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.act(java.lang.Object) *
            --> java.lang.Object *
            --> java.lang.String *
        read()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
            --> java.io.IOException *
            --> java.io.IOException.printStackTrace() *
            --> java.io.PushbackReader *
            --> java.io.PushbackReader.read() *
        readerTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.setReaderTokenizerEngine(am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
        setReaderTokenizerEngine(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        static {}
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.class$0
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.class$1
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        tryToFillBuffer()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.finished() *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.init(java.lang.Object) *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.is(java.lang.Object) *
            --> java.lang.Object *
        unread()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.current
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.io.IOException *
            --> java.io.IOException.printStackTrace() *
            --> java.io.PushbackReader *
            --> java.io.PushbackReader.unread(int) *
    ReaderTokenizerEngine
        <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.Act.act()
        <-- am.englet.inputtokenizers.Act.readerTokenizerEngine
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getReaderTokenizerEngine()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.readerTokenizerEngine
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.setReaderTokenizerEngine(am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.this$0
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.this$0
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.this$0
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.this$0
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
        --> am.englet.stateengine.Engine
        --> java.lang.Cloneable *
        APPEND
            --> am.englet.inputtokenizers.Act
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        APPEND_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        DEFAULT *
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
        PUSHBACK
            --> am.englet.inputtokenizers.Act
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        PUSHBACK_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        ReaderTokenizerEngine()
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$1.ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$2.ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$3.ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
            --> am.englet.stateengine.Engine.Engine()
        ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$1.ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$2.ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$3.ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.stateengine.Engine.Engine()
        SKIP
            --> am.englet.inputtokenizers.Act
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        SKIP_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        act(java.lang.Object) *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
        add(am.englet.stateengine.Action) *
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        clone()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.DEFAULT *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.readerToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.state *
            --> java.lang.CloneNotSupportedException *
            --> java.lang.Object *
            --> java.lang.Object.clone() *
        finished() *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
        getReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.Act.act()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.readerToTokenizerAdapter
        init(java.lang.Object) *
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
        is(java.lang.Object) *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
        isList(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            --> am.englet.util.AbstractListSingleton
            --> java.lang.Object *
            --> java.util.List *
        newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.Object *
        newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            --> java.lang.Object *
        newAct(java.lang.Object)
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.Object)
            --> java.lang.Object *
        objectAppendPerformer(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.String)
            --> java.lang.Object *
        objectAppendPerformer(java.lang.String)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.String *
        readerToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.getReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        reportIllegalState(java.lang.Object)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.readerToTokenizerAdapter
            --> am.englet.stateengine.Engine.reportIllegalState(java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
        rule(java.util.List)
            --> am.englet.inputtokenizers.Act
            --> am.englet.inputtokenizers.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object) *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[] *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND_PERFORMER
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.add(am.englet.stateengine.Action) *
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.isList(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.stateengine.Act
            --> am.englet.stateengine.Action
            --> java.lang.Object *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.iterator() *
            --> java.util.List.size() *
            --> java.util.List.toArray(java.lang.Object[]) *
        rules *
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
        serialVersionUID
        setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.getReaderTokenizerEngine()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.setReaderTokenizerEngine(am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.readerToTokenizerAdapter
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
        state *
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
        toString()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.rules *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.Map *
    ReaderTokenizerEngine$1
        --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        --> java.lang.Object *
        ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$1.this$0
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.Object.Object() *
        perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
        this$0
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
        toString()
            --> java.lang.Object.hashCode() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.toString() *
    ReaderTokenizerEngine$2
        --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        --> java.lang.Object *
        ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$2.this$0
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.Object.Object() *
        perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.append()
        this$0
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
        toString()
            --> java.lang.Object.hashCode() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.toString() *
    ReaderTokenizerEngine$3
        --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        --> java.lang.Object *
        ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$3.this$0
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> java.lang.Object.Object() *
        perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
        this$0
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
        toString()
            --> java.lang.Object.hashCode() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.toString() *
    ReaderTokenizerEngine$4
        --> am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        --> java.lang.Object *
        ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$4.this$0
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$4.val$object
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.Object)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$4.val$object
            --> java.lang.Object *
        this$0
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
        toString()
            --> am.englet.inputtokenizers.ReaderTokenizerEngine$4.val$object
            --> java.lang.Object *
            --> java.lang.Object.hashCode() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        val$object
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            --> java.lang.Object *
    ReaderTokenizerEngine$Performer
        <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.Act.act()
        <-- am.englet.inputtokenizers.Act.getPerformers()
        <-- am.englet.inputtokenizers.Act.performer
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.APPEND_PERFORMER
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.PUSHBACK_PERFORMER
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.SKIP_PERFORMER
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.String)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        --> java.lang.Object *
        perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            <-- am.englet.inputtokenizers.Act.act()
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
    ReaderTokenizerEngine$Performer[] *
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
am.englet.inputtokenizers.custom
    ArrayBasedCharToEventConverterImpl
        --> am.englet.inputtokenizers.custom.CharToEventConverter
        --> java.lang.Object *
        ArrayBasedCharToEventConverterImpl(java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.defaultEvent
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.values
            --> java.lang.Object.Object() *
            --> java.lang.String *
        defaultEvent
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.ArrayBasedCharToEventConverterImpl(java.lang.String)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.event(char)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            --> java.lang.String *
        dump()
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.defaultEvent
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.start
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.values
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        event(char)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.defaultEvent
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.start
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.values
            --> java.lang.String *
        main(java.lang.String[])
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.ArrayBasedCharToEventConverterImpl(java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            --> java.io.PrintStream *
            --> java.lang.String *
            --> java.lang.System.out *
        set(char, char, java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.defaultEvent
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.setEvent(java.lang.CharSequence, java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.start
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.values
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.util.Arrays.fill(java.lang.Object[], int, int, java.lang.Object) *
            --> java.util.Arrays.fill(java.lang.Object[], java.lang.Object) *
        set(java.lang.CharSequence)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.toString() *
            --> java.lang.String *
        set(java.lang.CharSequence, java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence)
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.charAt(int) *
            --> java.lang.CharSequence.length() *
            --> java.lang.String *
        setEvent(java.lang.CharSequence, java.lang.String)
            --> am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            --> java.lang.CharSequence *
            --> java.lang.CharSequence.charAt(int) *
            --> java.lang.String *
        start
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.event(char)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
        values
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.ArrayBasedCharToEventConverterImpl(java.lang.String)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.event(char)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            --> java.lang.String *
    CharToEventConverter
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.charToEventConverter
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.event(int)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl
        --> java.lang.Object *
        event(char)
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.event(int)
            --> java.lang.String *
    CustomTokenizerAdapter
        --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
        CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            --> am.englet.inputtokenizers.ReaderTokenizerEngine
            --> am.englet.inputtokenizers.ReaderTokenizerEngine.setReaderToTokenizerAdapter(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.inputtokenizers.custom.CharToEventConverter
            --> am.englet.inputtokenizers.custom.CustomTokenizerAdapter.charToEventConverter
            --> am.englet.inputtokenizers.custom.CustomTokenizerAdapter.readerTokenizerEngine *
            --> java.io.Reader *
            --> java.lang.Object *
        charToEventConverter
            --> am.englet.inputtokenizers.custom.CharToEventConverter
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.event(int)
        event(int)
            --> am.englet.inputtokenizers.ReaderToTokenizerAdapter.event(int)
            --> am.englet.inputtokenizers.custom.CharToEventConverter
            --> am.englet.inputtokenizers.custom.CharToEventConverter.event(char)
            --> am.englet.inputtokenizers.custom.CustomTokenizerAdapter.charToEventConverter
            --> java.lang.String *
        readerTokenizerEngine *
            <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
    RangesBasedCharToEventConverterImpl
        --> am.englet.inputtokenizers.custom.CharToEventConverter
        --> java.lang.Object *
        RangesBasedCharToEventConverterImpl()
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.END_COMPARATOR
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.START_COMPARATOR
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.endMap
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.startMap
            --> java.lang.Object.Object() *
            --> java.util.Comparator *
            --> java.util.TreeMap *
            --> java.util.TreeMap.TreeMap(java.util.Comparator) *
        endMap
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
            --> java.util.TreeMap *
        event(char)
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.startMap
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.SortedMap *
            --> java.util.TreeMap *
            --> java.util.TreeMap.headMap(java.lang.Object) *
        startMap
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
            --> java.util.TreeMap *
    RangesBasedCharToEventConverterImpl$1
        --> java.lang.Object *
        --> java.util.Comparator *
        RangesBasedCharToEventConverterImpl$1()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.static {}
            --> java.lang.Object.Object() *
        compare(java.lang.Object, java.lang.Object)
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.from
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
            --> java.lang.Object *
    RangesBasedCharToEventConverterImpl$2
        --> java.lang.Object *
        --> java.util.Comparator *
        RangesBasedCharToEventConverterImpl$2()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.static {}
            --> java.lang.Object.Object() *
        compare(java.lang.Object, java.lang.Object)
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.to
            --> java.lang.Number *
            --> java.lang.Number.intValue() *
            --> java.lang.Object *
    RangesBasedCharToEventConverterImpl$Range
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.compare(java.lang.Object, java.lang.Object)
        --> java.lang.Object *
        END_COMPARATOR
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.static {}
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
            --> java.util.Comparator *
        RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.from
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.to
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.value
            --> java.lang.Object.Object() *
            --> java.lang.String *
        START_COMPARATOR
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.static {}
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
            --> java.util.Comparator *
        from
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.compare(java.lang.Object, java.lang.Object)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
        static {}
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.RangesBasedCharToEventConverterImpl$1()
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.RangesBasedCharToEventConverterImpl$2()
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.END_COMPARATOR
            --> am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.START_COMPARATOR
            --> java.util.Comparator *
        to
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.compare(java.lang.Object, java.lang.Object)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
        value
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
            --> java.lang.String *
am.englet.link
    AbstractLink
        <-- am.englet.link.BackedLink
        <-- am.englet.link.FactoryLink
        <-- am.englet.link.FinalLink
        --> am.englet.link.Link
        <-- am.englet.link.SliderLink
        <-- am.englet.link.backadapters.slider.ChainLink
        --> java.lang.Object *
        AbstractLink()
            --> am.englet.link.AbstractLink.rewindable
            <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            <-- am.englet.link.FactoryLink.FactoryLink(am.englet.link.LinkFactory)
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            <-- am.englet.link.SliderLink.SliderLink(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.ChainLink.ChainLink()
            --> java.lang.Object.Object() *
        rewindable
            <-- am.englet.link.AbstractLink.AbstractLink()
            <-- am.englet.link.AbstractLink.rewindable()
        rewindable()
            --> am.englet.link.AbstractLink.rewindable
    AdapterMetadata
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.backadapters.IteratorAdapter.metadata
        <-- am.englet.link.backadapters.IteratorAdapter.metadata()
        <-- am.englet.link.backadapters.IteratorAdapter.static {}
        <-- am.englet.link.backadapters.LineReaderAdapter.metadata
        <-- am.englet.link.backadapters.LineReaderAdapter.metadata()
        <-- am.englet.link.backadapters.LineReaderAdapter.static {}
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
        --> java.lang.Object *
        AdapterMetadata(java.lang.Class, java.lang.Class[])
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            --> am.englet.link.AdapterMetadata.backClass
            --> am.englet.link.AdapterMetadata.preferredStrategies
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.Collection *
            --> java.util.Collections.unmodifiableSet(java.util.Set) *
            --> java.util.HashSet.HashSet(java.util.Collection) *
            --> java.util.List *
            --> java.util.Set *
        backClass
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            --> java.lang.Class *
        preferredStrategies
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            --> java.util.Set *
    BackAdapter
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.Processing.slide(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Processing.slide(java.util.Collection)
        <-- am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.backAdapter
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
        <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.backAdapter
        <-- am.englet.link.BackedLink.content()
        <-- am.englet.link.BackedLink.next()
        <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
        <-- am.englet.link.NextItemProvider.backAdapter
        <-- am.englet.link.NextItemProvider.content()
        <-- am.englet.link.NextItemProvider.tryNext()
        <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.link.SimpleLinkFactory.backAdapter
        <-- am.englet.link.SimpleLinkFactory.instance()
        <-- am.englet.link.SimpleLinkFactory.meta()
        <-- am.englet.link.TrivialBaseBackAdapterImpl
        <-- am.englet.link.backadapters.CurrentOnceStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.CurrentOnceStrategy.preCheckNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.CurrentlessStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.EnhancedResultSetStrategy.getCurrent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.EnhancedResultSetStrategy.tryNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.IteratorStrategy.preCheckNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.LineReaderStrategy.preCheckNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.preCheckNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StoragelessStrategy.tryNext(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StoragelessStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        --> java.lang.Object *
        current()
            <-- am.englet.link.backadapters.CurrentOnceStrategy.getContent(am.englet.link.BackAdapter)
            <-- am.englet.link.backadapters.EnhancedResultSetStrategy.getCurrent(am.englet.link.BackAdapter)
            --> java.lang.Object *
        getNext()
            <-- am.englet.link.backadapters.CurrentlessStrategy.getContent(am.englet.link.BackAdapter)
            --> java.lang.Object *
        hasNext()
            <-- am.englet.link.backadapters.IteratorStrategy.preCheckNext(am.englet.link.BackAdapter)
        metadata()
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.SimpleLinkFactory.meta()
            --> java.lang.Object *
        setBack(java.lang.Object)
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            --> java.lang.Object *
        tryNext()
            <-- am.englet.link.backadapters.CurrentOnceStrategy.preCheckNext(am.englet.link.BackAdapter)
            <-- am.englet.link.backadapters.EnhancedResultSetStrategy.tryNext(am.englet.link.BackAdapter)
    BackAdapterFactory
        --> java.lang.Object *
        BackAdapterFactory()
            --> am.englet.link.BackAdapterFactory.adapterClasses
            --> am.englet.link.BackAdapterFactory.strategies
            --> java.lang.Object.Object() *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
        adapterClasses
            <-- am.englet.link.BackAdapterFactory.BackAdapterFactory()
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
            --> java.util.HashMap *
        adapterInstance(java.lang.Object)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.setBack(java.lang.Object)
            --> am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.newInstance() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
        addClass(java.lang.Class)
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.AdapterMetadata.backClass
            --> am.englet.link.AdapterMetadata.preferredStrategies
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.metadata()
            --> am.englet.link.BackAdapterFactory.adapterClasses
            --> am.englet.link.BackAdapterFactory.class$0
            --> am.englet.link.BackAdapterFactory.strategies
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Class.newInstance() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.ArrayList.ArrayList(java.util.Collection) *
            --> java.util.Collection *
            --> java.util.HashMap *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
        assignableClasses(java.lang.Class)
            --> am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            --> java.lang.Class *
            --> java.util.HashSet *
            --> java.util.HashSet.HashSet() *
            --> java.util.Set *
        class$0
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            --> java.lang.Class *
        class$1
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            --> java.lang.Class *
        fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
            --> am.englet.link.BackAdapterFactory.class$1
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.getInterfaces() *
            --> java.lang.Class.getSuperclass() *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashSet *
            --> java.util.HashSet.add(java.lang.Object) *
        getAdapterClass(java.lang.Class)
            --> am.englet.link.BackAdapterFactory.adapterClasses
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            --> am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.HashMap *
        getByAssignableClasses(java.lang.Class, java.util.HashMap)
            --> am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.HashMap *
            --> java.util.HashMap.get(java.lang.Object) *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        getUsageStrategy(java.lang.Class)
            --> am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            --> am.englet.link.BackAdapterFactory.strategies
            <-- am.englet.link.BackAdapterFactory.usageStrategyInstance(java.lang.Object)
            --> am.englet.link.BackUsageStrategy
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.HashMap *
        strategies
            <-- am.englet.link.BackAdapterFactory.BackAdapterFactory()
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
            --> java.util.HashMap *
        usageStrategyInstance(java.lang.Object)
            --> am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
            --> am.englet.link.BackUsageStrategy
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
    BackUsageStrategy
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.Processing.slide(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Processing.slide(java.util.Collection)
        <-- am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.strategy
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
        <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.usageStrategyInstance(java.lang.Object)
        <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.backUsageStrategy
        <-- am.englet.link.BackedLink.content()
        <-- am.englet.link.BackedLink.next()
        <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
        <-- am.englet.link.NextItemProvider.backUsageStrategy
        <-- am.englet.link.NextItemProvider.content()
        <-- am.englet.link.NextItemProvider.tryNext()
        <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.link.SimpleLinkFactory.backUsageStrategy
        <-- am.englet.link.SimpleLinkFactory.instance()
        <-- am.englet.link.backadapters.StorageNeedingStrategy
        <-- am.englet.link.backadapters.StoragelessStrategy
        --> java.lang.Object *
        getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            --> am.englet.link.BackAdapter
            <-- am.englet.link.BackedLink.content()
            <-- am.englet.link.NextItemProvider.content()
            --> am.englet.link.Storage
            --> java.lang.Object *
        needsStorage()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
        tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
            --> am.englet.link.BackAdapter
            <-- am.englet.link.BackedLink.next()
            <-- am.englet.link.NextItemProvider.tryNext()
            <-- am.englet.link.SimpleLinkFactory.instance()
            --> am.englet.link.Storage
    BackedLink
        --> am.englet.link.AbstractLink
        BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            --> am.englet.link.AbstractLink.AbstractLink()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackedLink.backAdapter
            --> am.englet.link.BackedLink.backUsageStrategy
            --> am.englet.link.BackedLink.storage
            <-- am.englet.link.SimpleLinkFactory.instance()
            --> am.englet.link.Storage
        backAdapter
            --> am.englet.link.BackAdapter
            <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            <-- am.englet.link.BackedLink.content()
            <-- am.englet.link.BackedLink.next()
        backUsageStrategy
            --> am.englet.link.BackUsageStrategy
            <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            <-- am.englet.link.BackedLink.content()
            <-- am.englet.link.BackedLink.next()
        content()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackedLink.backAdapter
            --> am.englet.link.BackedLink.backUsageStrategy
            --> am.englet.link.BackedLink.storage
            --> am.englet.link.Storage
            --> java.lang.Object *
        next()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackedLink.backAdapter
            --> am.englet.link.BackedLink.backUsageStrategy
            --> am.englet.link.BackedLink.storage
            --> am.englet.link.Link
            --> am.englet.link.Storage
        storage
            <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            <-- am.englet.link.BackedLink.content()
            <-- am.englet.link.BackedLink.next()
            --> am.englet.link.Storage
    Chain
        <-- am.englet.Management.chain(int, am.englet.DataStack)
        <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
        <-- am.englet.TestUtils0$2.tryNextContent()
        <-- am.englet.TestUtils0$2.val$each
        <-- am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(java.lang.Object, am.englet.link.Link)
        --> am.englet.link.FinalLink
        Chain(java.lang.Object)
            <-- am.englet.TestUtils0.times(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> java.lang.Object *
        Chain(java.lang.Object, am.englet.link.FinalLink)
            <-- am.englet.Management.chain(int, am.englet.DataStack)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Object *
    CompiledFinalLink
        --> am.englet.link.FinalLink
        CompiledFinalLink(java.lang.Object, am.englet.link.FinalLink, long)
            --> am.englet.link.CompiledFinalLink.offset
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Object *
        content *
            <-- am.englet.link.CompiledFinalLink.toString()
        next *
            <-- am.englet.link.CompiledFinalLink.toString()
        offset
            <-- am.englet.link.CompiledFinalLink.CompiledFinalLink(java.lang.Object, am.englet.link.FinalLink, long)
            <-- am.englet.link.CompiledFinalLink.toString()
        serialVersionUID
        toString()
            --> am.englet.link.CompiledFinalLink.content *
            --> am.englet.link.CompiledFinalLink.next *
            --> am.englet.link.CompiledFinalLink.offset
            --> am.englet.link.FinalLink
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(int) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    FactoryLink
        --> am.englet.link.AbstractLink
        FactoryLink(am.englet.link.LinkFactory)
            --> am.englet.link.AbstractLink.AbstractLink()
            --> am.englet.link.FactoryLink.linkFactory
            --> am.englet.link.LinkFactory
        content()
            --> am.englet.link.FactoryLink.linkFactory
            --> am.englet.link.LinkFactory
            --> am.englet.link.LinkFactory.meta()
            --> java.lang.Object *
        linkFactory
            <-- am.englet.link.FactoryLink.FactoryLink(am.englet.link.LinkFactory)
            <-- am.englet.link.FactoryLink.content()
            <-- am.englet.link.FactoryLink.next()
            --> am.englet.link.LinkFactory
        next()
            --> am.englet.link.FactoryLink.linkFactory
            --> am.englet.link.Link
            --> am.englet.link.LinkFactory
            --> am.englet.link.LinkFactory.instance()
    FinalLink
        <-- am.englet.Immediate.chain(am.englet.DataStack)
        <-- am.englet.Links$2.tryNextContent()
        <-- am.englet.Links$3.tryNextContent()
        <-- am.englet.Links.toChain(java.lang.Object[])
        <-- am.englet.Management.DEFRAMER_FINAL_LINK
        <-- am.englet.Management.chain(int, am.englet.DataStack)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        <-- am.englet.Management.static {}
        <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.TestUtils0.EXCL_FNAL_LINK
        <-- am.englet.TestUtils0.static {}
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
        <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.successChain()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.flt.main(java.lang.String[])
        --> am.englet.link.AbstractLink
        <-- am.englet.link.Chain
        <-- am.englet.link.Chain.Chain(java.lang.Object, am.englet.link.FinalLink)
        <-- am.englet.link.CompiledFinalLink
        <-- am.englet.link.CompiledFinalLink.CompiledFinalLink(java.lang.Object, am.englet.link.FinalLink, long)
        <-- am.englet.link.CompiledFinalLink.toString()
        <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
        <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink, am.englet.link.FinalLink$Serializable)
        --> am.englet.link.Link$Serializable
        <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
        <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.HeadSlider.content
        <-- am.englet.link.backadapters.slider.HeadSlider.content()
        <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        CLOSING_BRACKET_SYMBOL
            --> java.lang.String *
        FinalLink(java.lang.Object)
            <-- am.englet.Links$2.tryNextContent()
            <-- am.englet.Management.static {}
            <-- am.englet.TestUtils0$2.tryNextContent()
            <-- am.englet.TestUtils0.times(java.lang.Object, boolean)
            <-- am.englet.link.Chain.Chain(java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
            --> java.lang.Object *
        FinalLink(java.lang.Object, am.englet.link.FinalLink)
            <-- am.englet.Links$2.tryNextContent()
            <-- am.englet.Links.toChain(java.lang.Object[])
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.TestUtils0.static {}
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
            <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            <-- am.englet.flt.main(java.lang.String[])
            <-- am.englet.link.Chain.Chain(java.lang.Object, am.englet.link.FinalLink)
            <-- am.englet.link.CompiledFinalLink.CompiledFinalLink(java.lang.Object, am.englet.link.FinalLink, long)
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            <-- am.englet.link.FinalLink.prepend(java.lang.Object)
            --> am.englet.link.Link
            <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
            --> java.lang.Object *
        FinalLink(java.lang.Object, am.englet.link.Link)
            <-- am.englet.MultiplySliderImpl.restart()
            <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
            <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            <-- am.englet.Processing.reverse(am.englet.link.Link)
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0.directPlus(java.lang.Object, am.englet.link.Link)
            <-- am.englet.TestUtils0.plus(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.AbstractLink.AbstractLink()
            <-- am.englet.link.FinalLink$Serializable.readResolve()
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> am.englet.link.FinalLink.content
            --> am.englet.link.FinalLink.next
            --> am.englet.link.FinalLink.rewindable *
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.HeadSlider.content()
            <-- am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
            --> java.lang.Object *
        OPENING_BRACKET_SYMBOL
            --> java.lang.String *
        content
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            <-- am.englet.link.FinalLink.content()
            <-- am.englet.link.FinalLink.contentString()
            --> java.lang.Object *
        content()
            --> am.englet.link.FinalLink.content
            --> java.lang.Object *
        contentString()
            --> am.englet.link.FinalLink.content
            <-- am.englet.link.FinalLink.toString()
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        next
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            <-- am.englet.link.FinalLink.next()
            <-- am.englet.link.FinalLink.toString()
            --> am.englet.link.Link
        next()
            --> am.englet.link.FinalLink.next
            --> am.englet.link.Link
        prepend(java.lang.Object)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
            --> java.lang.Object *
        rewindable *
            <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
        serialVersionUID
        toString()
            --> am.englet.link.FinalLink.contentString()
            --> am.englet.link.FinalLink.next
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        writeReplace()
            --> am.englet.link.FinalLink$Serializable
            --> am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink, am.englet.link.FinalLink$Serializable)
            --> java.io.ObjectStreamException *
            --> java.lang.Object *
    FinalLink$Serializable
        <-- am.englet.link.FinalLink.writeReplace()
        --> java.io.Serializable *
        --> java.lang.Object *
        FinalLink$Serializable()
            --> java.lang.Object.Object() *
        FinalLink$Serializable(am.englet.link.FinalLink)
            --> am.englet.link.FinalLink
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink, am.englet.link.FinalLink$Serializable)
            --> am.englet.link.FinalLink$Serializable.content
            --> am.englet.link.FinalLink$Serializable.next
            --> am.englet.link.FinalLink.content
            --> am.englet.link.FinalLink.next
            --> am.englet.link.Link
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        FinalLink$Serializable(am.englet.link.FinalLink, am.englet.link.FinalLink$Serializable)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.FinalLink.writeReplace()
        content
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.FinalLink$Serializable.readResolve()
            --> java.lang.Object *
        next
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.FinalLink$Serializable.readResolve()
            --> am.englet.link.Link
        readResolve()
            --> am.englet.link.FinalLink$Serializable.content
            --> am.englet.link.FinalLink$Serializable.next
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> java.io.ObjectStreamException *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.RuntimeException.RuntimeException(java.lang.Throwable) *
            --> java.lang.Throwable *
        serialVersionUID
    InvokableTargetBackAdapterImpl
        --> am.englet.link.TrivialBaseBackAdapterImpl
        InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.close
            --> am.englet.link.InvokableTargetBackAdapterImpl.current
            --> am.englet.link.InvokableTargetBackAdapterImpl.getNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.hasNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.tryNext
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        InvokableTargetBackAdapterImpl(java.util.Map)
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.close
            --> am.englet.link.InvokableTargetBackAdapterImpl.current
            --> am.englet.link.InvokableTargetBackAdapterImpl.getNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.hasNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.tryNext
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl()
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        back *
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        close
            --> am.englet.Invokable
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        current
            --> am.englet.Invokable
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.current()
        current()
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.current
            --> am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            --> am.englet.link.TrivialBaseBackAdapterImpl.current()
            --> java.lang.Object *
        getNext
            --> am.englet.Invokable
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
        getNext()
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.close
            --> am.englet.link.InvokableTargetBackAdapterImpl.getNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.hasNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            --> am.englet.link.InvokableTargetBackAdapterImpl.tryNext
            --> am.englet.link.TrivialBaseBackAdapterImpl.getNext()
            --> java.lang.Object *
        hasNext
            --> am.englet.Invokable
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
        hasNext()
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.close
            --> am.englet.link.InvokableTargetBackAdapterImpl.hasNext
            --> am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            --> am.englet.link.TrivialBaseBackAdapterImpl.hasNext()
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Object *
        invoke(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.Invokable.targetType()
            --> am.englet.link.InvokableTargetBackAdapterImpl.back *
            <-- am.englet.link.InvokableTargetBackAdapterImpl.current()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
            --> java.lang.Class *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.IllegalArgumentException *
            --> java.lang.IllegalArgumentException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.InvocationTargetException.printStackTrace() *
        tryNext
            --> am.englet.Invokable
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        tryNext()
            --> am.englet.Invokable
            --> am.englet.link.InvokableTargetBackAdapterImpl.close
            --> am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            --> am.englet.link.InvokableTargetBackAdapterImpl.tryNext
            --> am.englet.link.TrivialBaseBackAdapterImpl.tryNext()
            --> java.lang.Boolean *
            --> java.lang.Boolean.booleanValue() *
            --> java.lang.Object *
    LazyLink
        --> am.englet.link.Link
        --> java.io.Serializable *
        --> java.lang.Object *
        LazyLink(am.englet.link.NextItemProvider)
            --> am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.link.LazyLink.next()
            --> am.englet.link.NextItemProvider
            --> am.englet.link.NextItemProvider.content()
            --> java.lang.Object *
        LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider)
            --> am.englet.link.LazyLink.content
            --> am.englet.link.LazyLink.next
            --> am.englet.link.LazyLink.nextItemProvider
            --> am.englet.link.NextItemProvider
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        content
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.link.LazyLink.content()
            --> java.lang.Object *
        content()
            --> am.englet.link.LazyLink.content
            --> java.lang.Object *
        next
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.link.LazyLink.next()
        next()
            --> am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider)
            --> am.englet.link.LazyLink.next
            --> am.englet.link.LazyLink.nextItemProvider
            --> am.englet.link.Link
            --> am.englet.link.NextItemProvider
            --> am.englet.link.NextItemProvider.tryNext()
        nextItemProvider
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.link.LazyLink.next()
            --> am.englet.link.NextItemProvider
        serialVersionUID
    Link
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.current(int)
        <-- am.englet.CallStackSliderImpl.ensureStarted()
        <-- am.englet.CallStackSliderImpl.go(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
        <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
        <-- am.englet.EngletBasedChecker.check(java.lang.Object)
        <-- am.englet.EngletBasedChecker.link
        <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
        <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.EngletBasedValueConverter.link
        <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
        <-- am.englet.Links$2.Links$2(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Links$2.l1
        <-- am.englet.Links$2.l2
        <-- am.englet.Links$2.tryNextContent()
        <-- am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
        <-- am.englet.Links$3.link
        <-- am.englet.Links$3.tryNextContent()
        <-- am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Links$4.linkA
        <-- am.englet.Links$4.tryNextContent()
        <-- am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$5.linkA
        <-- am.englet.Links$5.tryNextContent()
        <-- am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
        <-- am.englet.Links$6.linkA
        <-- am.englet.Links$6.tryNextContent()
        <-- am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
        <-- am.englet.Links$7.linkA
        <-- am.englet.Links$7.tryNextContent()
        <-- am.englet.Links$8.tryNextContent()
        <-- am.englet.Links$Calculate_Next_Based.next()
        <-- am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Links.div(am.englet.link.Link, int)
        <-- am.englet.Links.flat(am.englet.link.Link)
        <-- am.englet.Links.flat(am.englet.link.Link, int)
        <-- am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
        <-- am.englet.Links.plusz(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Links.recursiveAtomValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.recursiveValueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Links.toLazyChain(java.lang.String[])
        <-- am.englet.Links.valueConverterBased(am.englet.link.Link, am.englet.Links$ValueConverter)
        <-- am.englet.Management$3
        <-- am.englet.Management$3.Management$3(am.englet.link.Link)
        <-- am.englet.Management$3.content()
        <-- am.englet.Management$3.l1
        <-- am.englet.Management$3.next()
        <-- am.englet.Management$3.toString()
        <-- am.englet.Management$8
        <-- am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
        <-- am.englet.Management$8.content()
        <-- am.englet.Management$8.next()
        <-- am.englet.Management$8.val$l
        <-- am.englet.Management.append(am.englet.link.Link, int, am.englet.CommandSource)
        <-- am.englet.Management.direct(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
        <-- am.englet.Management.filter(am.englet.DataStack, am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Management.go(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.goFakeLing(am.englet.CommandSource, am.englet.link.Link)
        <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link)
        <-- am.englet.Management.ifgo(am.englet.CommandSource, boolean, am.englet.link.Link, int)
        <-- am.englet.Management.ngo(am.englet.link.Link, int, am.englet.CommandSource)
        <-- am.englet.Management.ntrec(int, am.englet.CommandSource)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Management.start(am.englet.Englet)
        <-- am.englet.Management.start(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startDirect(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
        <-- am.englet.Management.startfs(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.startns(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link, int)
        <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.MultiplySliderImpl.each
        <-- am.englet.MultiplySliderImpl.restart()
        <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
        <-- am.englet.Processing$1.curr
        <-- am.englet.Processing$1.tryNextContent()
        <-- am.englet.Processing$1.val$l
        <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
        <-- am.englet.Processing.as_list(am.englet.link.Link)
        <-- am.englet.Processing.copy(am.englet.link.Link)
        <-- am.englet.Processing.gotted(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
        <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.loop(am.englet.link.Link)
        <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
        <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
        <-- am.englet.Processing.reverse(am.englet.link.Link)
        <-- am.englet.Processing.slide(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Processing.slide(java.lang.Object[])
        <-- am.englet.Processing.slide(java.util.Collection)
        <-- am.englet.Processing.slide(java.util.Map)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0$10.val$each
        <-- am.englet.TestUtils0$11.tryNextContent()
        <-- am.englet.TestUtils0$12.step()
        <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
        <-- am.englet.TestUtils0$2.each1
        <-- am.englet.TestUtils0$2.through1
        <-- am.englet.TestUtils0$2.through2
        <-- am.englet.TestUtils0$2.tryNextContent()
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.access$0(java.util.regex.Matcher)
        <-- am.englet.TestUtils0.directPlus(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.div(am.englet.link.Link, int)
        <-- am.englet.TestUtils0.div(am.englet.link.Link, java.util.Map)
        <-- am.englet.TestUtils0.div(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.divL(java.io.InputStream)
        <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
        <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.forLink(int, int)
        <-- am.englet.TestUtils0.gt(am.englet.link.Link)
        <-- am.englet.TestUtils0.head(am.englet.link.Link)
        <-- am.englet.TestUtils0.isLink(java.lang.Object)
        <-- am.englet.TestUtils0.lt(am.englet.link.Link)
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.or(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.plus(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.plusz(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.tail(am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0.times(am.englet.link.Chain, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, boolean)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
        <-- am.englet.TestUtils0.times(boolean, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(boolean, java.lang.Object)
        <-- am.englet.TestUtils0.times(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(java.lang.Object, boolean)
        <-- am.englet.TestUtils0.times0(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.timesd(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.timesdd(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.xor(am.englet.link.Link)
        <-- am.englet.Utils$7.convert(java.lang.Object)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
        <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Utils.formatLink(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Utils.isLink(java.lang.Object)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.parameterized(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.link.AbstractLink
        <-- am.englet.link.BackedLink.next()
        <-- am.englet.link.CompiledFinalLink.toString()
        <-- am.englet.link.FactoryLink.next()
        <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
        <-- am.englet.link.FinalLink$Serializable.next
        <-- am.englet.link.FinalLink$Serializable.readResolve()
        <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
        <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
        <-- am.englet.link.FinalLink.next
        <-- am.englet.link.FinalLink.next()
        <-- am.englet.link.FinalLink.toString()
        <-- am.englet.link.LazyLink
        <-- am.englet.link.LazyLink.next()
        <-- am.englet.link.Link$Serializable
        <-- am.englet.link.LinkFactory.instance()
        <-- am.englet.link.SimpleLinkFactory.instance()
        <-- am.englet.link.SliderLink.SliderLink(am.englet.link.Link)
        <-- am.englet.link.SliderLink.content()
        <-- am.englet.link.SliderLink.link
        <-- am.englet.link.SliderLink.next()
        <-- am.englet.link.backadapters.CalStacklLevelLink.CalStacklLevelLink(am.englet.link.Link)
        <-- am.englet.link.backadapters.CalStacklLevelLink.base
        <-- am.englet.link.backadapters.CalStacklLevelLink.getBase()
        <-- am.englet.link.backadapters.CalStacklLevelLink.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.back
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.back()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider.append(am.englet.link.Link, int)
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider.current(int)
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider.go(am.englet.link.Link, int)
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider.start(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.BackHoldingLinkSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.back
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.back()
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.CallStackSlider.current(int)
        <-- am.englet.link.backadapters.slider.CallStackSlider.go(am.englet.link.Link, int)
        <-- am.englet.link.backadapters.slider.CallStackSlider.start(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.CallStacklLevelSlider.back()
        <-- am.englet.link.backadapters.slider.CallStacklLevelSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.ChainLink.content()
        <-- am.englet.link.backadapters.slider.ChainLink.next()
        <-- am.englet.link.backadapters.slider.ChainLink.peek()
        <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
        <-- am.englet.link.backadapters.slider.HeadSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.LinkSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.LinkSlider.link
        <-- am.englet.link.backadapters.slider.LinkSlider.tryNext()
        <-- am.englet.link.backadapters.slider.LoopSlider.LoopSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.LoopSlider.tryNext()
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.optionalTail
        --> java.lang.Object *
        content()
            <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            <-- am.englet.Links$2.tryNextContent()
            <-- am.englet.Links$3.tryNextContent()
            <-- am.englet.Links$4.tryNextContent()
            <-- am.englet.Links$5.tryNextContent()
            <-- am.englet.Links$6.tryNextContent()
            <-- am.englet.Links$7.tryNextContent()
            <-- am.englet.Links$8.tryNextContent()
            <-- am.englet.Management$3.content()
            <-- am.englet.Processing$1.tryNextContent()
            <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
            <-- am.englet.Processing.as_list(am.englet.link.Link)
            <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            <-- am.englet.Processing.reverse(am.englet.link.Link)
            <-- am.englet.TestUtils0$2.tryNextContent()
            <-- am.englet.TestUtils0.head(am.englet.link.Link)
            <-- am.englet.TestUtils0.lt(am.englet.link.Link)
            <-- am.englet.TestUtils0.tail(am.englet.link.Link)
            <-- am.englet.TestUtils0.xor(am.englet.link.Link)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.link.SliderLink.content()
            <-- am.englet.link.backadapters.slider.ChainLink.content()
            <-- am.englet.link.backadapters.slider.LinkSlider.content()
            --> java.lang.Object *
        next()
            <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
            <-- am.englet.Links$2.tryNextContent()
            <-- am.englet.Links$3.tryNextContent()
            <-- am.englet.Links$4.tryNextContent()
            <-- am.englet.Links$5.tryNextContent()
            <-- am.englet.Links$6.tryNextContent()
            <-- am.englet.Links$7.tryNextContent()
            <-- am.englet.Links$8.tryNextContent()
            <-- am.englet.Management$3.next()
            <-- am.englet.Processing$1.tryNextContent()
            <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
            <-- am.englet.Processing.as_list(am.englet.link.Link)
            <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
            <-- am.englet.Processing.reverse(am.englet.link.Link)
            <-- am.englet.TestUtils0$2.tryNextContent()
            <-- am.englet.TestUtils0.gt(am.englet.link.Link)
            <-- am.englet.TestUtils0.head(am.englet.link.Link)
            <-- am.englet.TestUtils0.tail(am.englet.link.Link)
            <-- am.englet.TestUtils0.xor(am.englet.link.Link)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.link.SliderLink.next()
            <-- am.englet.link.backadapters.slider.ChainLink.next()
            <-- am.englet.link.backadapters.slider.LinkSlider.tryNext()
    Link$Serializable
        <-- am.englet.Links$Calculate_Next_Based
        <-- am.englet.link.FinalLink
        --> am.englet.link.Link
        --> java.io.Serializable *
        --> java.lang.Object *
    LinkFactory
        <-- am.englet.link.FactoryLink.FactoryLink(am.englet.link.LinkFactory)
        <-- am.englet.link.FactoryLink.content()
        <-- am.englet.link.FactoryLink.linkFactory
        <-- am.englet.link.FactoryLink.next()
        <-- am.englet.link.SimpleLinkFactory
        --> java.lang.Object *
        instance()
            <-- am.englet.link.FactoryLink.next()
            --> am.englet.link.Link
        meta()
            <-- am.englet.link.FactoryLink.content()
            --> java.lang.Object *
    LinkUtils
        --> java.lang.Object *
        LinkUtils()
            --> java.lang.Object.Object() *
        ListAsFinalLinkChain(java.util.List)
            <-- am.englet.Immediate.chain(am.englet.DataStack)
            <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
    NextItemProvider
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider)
        <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
        <-- am.englet.link.LazyLink.next()
        <-- am.englet.link.LazyLink.nextItemProvider
        --> java.lang.Object *
        NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.needsStorage()
            --> am.englet.link.NextItemProvider.backAdapter
            --> am.englet.link.NextItemProvider.backUsageStrategy
            --> am.englet.link.NextItemProvider.storage
            --> am.englet.link.Storage
            --> am.englet.link.StorageImpl.StorageImpl()
            --> java.lang.Object.Object() *
        backAdapter
            --> am.englet.link.BackAdapter
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.link.NextItemProvider.content()
            <-- am.englet.link.NextItemProvider.tryNext()
        backUsageStrategy
            --> am.englet.link.BackUsageStrategy
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.link.NextItemProvider.content()
            <-- am.englet.link.NextItemProvider.tryNext()
        content()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider)
            --> am.englet.link.NextItemProvider.backAdapter
            --> am.englet.link.NextItemProvider.backUsageStrategy
            --> am.englet.link.NextItemProvider.storage
            --> am.englet.link.Storage
            --> java.lang.Object *
        storage
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.link.NextItemProvider.content()
            <-- am.englet.link.NextItemProvider.tryNext()
            --> am.englet.link.Storage
        tryNext()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            <-- am.englet.link.LazyLink.next()
            --> am.englet.link.NextItemProvider.backAdapter
            --> am.englet.link.NextItemProvider.backUsageStrategy
            --> am.englet.link.NextItemProvider.storage
            --> am.englet.link.Storage
    SimpleLinkFactory
        --> am.englet.link.LinkFactory
        --> java.lang.Object *
        SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.Processing.slide(java.util.Collection)
            <-- am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.SimpleLinkFactory.backAdapter
            --> am.englet.link.SimpleLinkFactory.backUsageStrategy
            --> am.englet.link.SimpleLinkFactory.storage
            --> am.englet.link.Storage
            --> am.englet.link.StorageImpl.StorageImpl()
            --> java.lang.Object.Object() *
        backAdapter
            --> am.englet.link.BackAdapter
            <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.SimpleLinkFactory.instance()
            <-- am.englet.link.SimpleLinkFactory.meta()
        backUsageStrategy
            --> am.englet.link.BackUsageStrategy
            <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.SimpleLinkFactory.instance()
        instance()
            <-- am.englet.Processing.slide(java.util.Collection)
            <-- am.englet.Utils.backAdapterBasedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackUsageStrategy
            --> am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
            --> am.englet.link.Link
            --> am.englet.link.SimpleLinkFactory.backAdapter
            --> am.englet.link.SimpleLinkFactory.backUsageStrategy
            --> am.englet.link.SimpleLinkFactory.storage
            --> am.englet.link.Storage
        meta()
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.metadata()
            --> am.englet.link.SimpleLinkFactory.backAdapter
            --> java.lang.Object *
        storage
            <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.SimpleLinkFactory.instance()
            --> am.englet.link.Storage
    SliderLink
        --> am.englet.link.AbstractLink
        <-- am.englet.link.backadapters.CalStacklLevelLink
        <-- am.englet.link.backadapters.slider.ChainLink.at(int)
        <-- am.englet.link.backadapters.slider.ChainLink.push(am.englet.link.SliderLink)
        SliderLink(am.englet.link.Link)
            --> am.englet.link.AbstractLink.AbstractLink()
            --> am.englet.link.Link
            --> am.englet.link.SliderLink.link
            <-- am.englet.link.backadapters.CalStacklLevelLink.CalStacklLevelLink(am.englet.link.Link)
        content()
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.SliderLink.link
            --> java.lang.Object *
        link
            --> am.englet.link.Link
            <-- am.englet.link.SliderLink.SliderLink(am.englet.link.Link)
            <-- am.englet.link.SliderLink.content()
            <-- am.englet.link.SliderLink.next()
        next()
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
            --> am.englet.link.SliderLink.link
    Storage
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.storage
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.tryNext()
        <-- am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.BackUsageStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.BackedLink(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.content()
        <-- am.englet.link.BackedLink.next()
        <-- am.englet.link.BackedLink.storage
        <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
        <-- am.englet.link.NextItemProvider.content()
        <-- am.englet.link.NextItemProvider.storage
        <-- am.englet.link.NextItemProvider.tryNext()
        <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
        <-- am.englet.link.SimpleLinkFactory.instance()
        <-- am.englet.link.SimpleLinkFactory.storage
        <-- am.englet.link.StorageImpl
        <-- am.englet.link.backadapters.CurrentOnceStrategy.postCheckNext(am.englet.link.Storage)
        <-- am.englet.link.backadapters.IteratorStrategy.postCheckNext(am.englet.link.Storage)
        <-- am.englet.link.backadapters.LineReaderStrategy.postCheckNext(am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.postCheckNext(am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StoragelessStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        --> java.lang.Object *
        NOTHING
            <-- am.englet.link.Storage.static {}
            --> java.util.List *
        restore()
            <-- am.englet.link.backadapters.LineReaderStrategy.postCheckNext(am.englet.link.Storage)
            <-- am.englet.link.backadapters.StorageNeedingStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> java.lang.Object *
        static {}
            --> am.englet.link.Storage$Nothing.Storage$Nothing()
            --> am.englet.link.Storage.NOTHING
            --> java.util.List *
        store(java.lang.Object)
            <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> java.lang.Object *
    Storage$Nothing
        --> java.util.AbstractList *
        Storage$Nothing()
            <-- am.englet.link.Storage.static {}
            --> java.util.AbstractList.AbstractList() *
        get(int)
            --> java.lang.ArrayIndexOutOfBoundsException.ArrayIndexOutOfBoundsException(int) *
            --> java.lang.Object *
        size()
    StorageImpl
        --> am.englet.link.Storage
        --> java.lang.Object *
        NOTHING *
            <-- am.englet.link.StorageImpl.StorageImpl()
            <-- am.englet.link.StorageImpl.restore()
        StorageImpl()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            --> am.englet.link.StorageImpl.NOTHING *
            --> am.englet.link.StorageImpl.object
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.List *
        object
            <-- am.englet.link.StorageImpl.StorageImpl()
            <-- am.englet.link.StorageImpl.restore()
            <-- am.englet.link.StorageImpl.store(java.lang.Object)
            --> java.lang.Object *
        restore()
            --> am.englet.link.StorageImpl.NOTHING *
            --> am.englet.link.StorageImpl.object
            --> java.lang.IllegalStateException.IllegalStateException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.util.List *
        store(java.lang.Object)
            --> am.englet.link.StorageImpl.object
            --> java.lang.Object *
    TrivialBaseBackAdapterImpl
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter
        --> am.englet.link.BackAdapter
        <-- am.englet.link.InvokableTargetBackAdapterImpl
        <-- am.englet.link.backadapters.IteratorAdapter
        <-- am.englet.link.backadapters.LineReaderAdapter
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter
        --> java.lang.Object *
        TrivialBaseBackAdapterImpl()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.link.backadapters.IteratorAdapter.IteratorAdapter()
            <-- am.englet.link.backadapters.LineReaderAdapter.LineReaderAdapter()
            --> java.lang.Object.Object() *
        TrivialBaseBackAdapterImpl(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            --> am.englet.link.TrivialBaseBackAdapterImpl.setBack(java.lang.Object)
            <-- am.englet.link.backadapters.IteratorAdapter.IteratorAdapter(java.util.Iterator)
            <-- am.englet.link.backadapters.LineReaderAdapter.LineReaderAdapter(java.io.BufferedReader)
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        back
            <-- am.englet.link.TrivialBaseBackAdapterImpl.setBack(java.lang.Object)
            --> java.lang.Object *
        current()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.current()
            --> java.lang.Object *
            --> java.lang.UnsupportedOperationException.UnsupportedOperationException() *
        getNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
            --> java.lang.Object *
            --> java.lang.UnsupportedOperationException.UnsupportedOperationException() *
        hasNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
            --> java.lang.UnsupportedOperationException.UnsupportedOperationException() *
        metadata()
            --> java.lang.Object *
        setBack(java.lang.Object)
            <-- am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> am.englet.link.TrivialBaseBackAdapterImpl.back
            --> java.lang.Object *
        tryNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
            --> java.lang.UnsupportedOperationException.UnsupportedOperationException() *
am.englet.link.backadapters
    CalStacklLevelLink
        --> am.englet.link.SliderLink
        CalStacklLevelLink(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.SliderLink.SliderLink(am.englet.link.Link)
            --> am.englet.link.backadapters.CalStacklLevelLink.base
        base
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.CalStacklLevelLink.CalStacklLevelLink(am.englet.link.Link)
            <-- am.englet.link.backadapters.CalStacklLevelLink.getBase()
        getBase()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.CalStacklLevelLink.base
        go(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.CalStacklLevelLink.link *
        link *
            <-- am.englet.link.backadapters.CalStacklLevelLink.go(am.englet.link.Link)
    CurrentOnceStrategy
        <-- am.englet.link.backadapters.ResultSetStrategy
        --> am.englet.link.backadapters.StorageNeedingStrategy
        CurrentOnceStrategy()
            <-- am.englet.link.backadapters.ResultSetStrategy.ResultSetStrategy()
            --> am.englet.link.backadapters.StorageNeedingStrategy.StorageNeedingStrategy()
        getContent(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.current()
            --> java.lang.Object *
        postCheckNext(am.englet.link.Storage)
            --> am.englet.link.Storage
        preCheckNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.tryNext()
    CurrentlessStrategy
        <-- am.englet.link.backadapters.IteratorStrategy
        <-- am.englet.link.backadapters.LineReaderStrategy
        --> am.englet.link.backadapters.StorageNeedingStrategy
        CurrentlessStrategy()
            <-- am.englet.link.backadapters.IteratorStrategy.IteratorStrategy()
            <-- am.englet.link.backadapters.LineReaderStrategy.LineReaderStrategy()
            --> am.englet.link.backadapters.StorageNeedingStrategy.StorageNeedingStrategy()
        getContent(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.getNext()
            --> java.lang.Object *
    EnhancedResultSetStrategy
        --> am.englet.link.backadapters.StoragelessStrategy
        EnhancedResultSetStrategy()
            <-- am.englet.link.backadapters.EnhancedResultSetStrategy.static {}
            --> am.englet.link.backadapters.StoragelessStrategy.StoragelessStrategy()
        INSTANCE
            <-- am.englet.link.backadapters.EnhancedResultSetStrategy.static {}
        getCurrent(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.current()
            --> java.lang.Object *
        static {}
            --> am.englet.link.backadapters.EnhancedResultSetStrategy.EnhancedResultSetStrategy()
            --> am.englet.link.backadapters.EnhancedResultSetStrategy.INSTANCE
        tryNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.tryNext()
    IteratorAdapter
        --> am.englet.link.TrivialBaseBackAdapterImpl
        IteratorAdapter()
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl()
        IteratorAdapter(java.util.Iterator)
            <-- am.englet.Processing.slide(java.util.Collection)
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> java.lang.Object *
            --> java.util.Iterator *
        back *
            <-- am.englet.link.backadapters.IteratorAdapter.getBack()
        class$0
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            --> java.lang.Class *
        getBack()
            --> am.englet.link.backadapters.IteratorAdapter.back *
            <-- am.englet.link.backadapters.IteratorAdapter.getNext()
            <-- am.englet.link.backadapters.IteratorAdapter.hasNext()
            <-- am.englet.link.backadapters.IteratorAdapter.metadata()
            --> java.lang.Object *
            --> java.util.Iterator *
        getNext()
            --> am.englet.link.backadapters.IteratorAdapter.getBack()
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.next() *
        hasNext()
            --> am.englet.link.backadapters.IteratorAdapter.getBack()
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
        metadata
            --> am.englet.link.AdapterMetadata
            <-- am.englet.link.backadapters.IteratorAdapter.metadata()
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
        metadata()
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.backadapters.IteratorAdapter.getBack()
            --> am.englet.link.backadapters.IteratorAdapter.metadata
            --> java.lang.Object *
            --> java.util.Iterator *
        static {}
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            --> am.englet.link.backadapters.IteratorAdapter.class$0
            --> am.englet.link.backadapters.IteratorAdapter.class$1
            --> am.englet.link.backadapters.IteratorAdapter.metadata
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
    IteratorStrategy
        <-- am.englet.Processing.slide(java.util.Collection)
        --> am.englet.link.backadapters.CurrentlessStrategy
        INSTANCE
            <-- am.englet.Processing.slide(java.util.Collection)
            <-- am.englet.link.backadapters.IteratorStrategy.static {}
        IteratorStrategy()
            --> am.englet.link.backadapters.CurrentlessStrategy.CurrentlessStrategy()
            <-- am.englet.link.backadapters.IteratorStrategy.static {}
        postCheckNext(am.englet.link.Storage)
            --> am.englet.link.Storage
        preCheckNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            --> am.englet.link.BackAdapter.hasNext()
        static {}
            --> am.englet.link.backadapters.IteratorStrategy.INSTANCE
            --> am.englet.link.backadapters.IteratorStrategy.IteratorStrategy()
    LineReaderAdapter
        --> am.englet.link.TrivialBaseBackAdapterImpl
        LineReaderAdapter()
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl()
        LineReaderAdapter(java.io.BufferedReader)
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> java.io.BufferedReader *
            --> java.lang.Object *
        back *
            <-- am.englet.link.backadapters.LineReaderAdapter.getBack()
        class$0
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            --> java.lang.Class *
        getBack()
            --> am.englet.link.backadapters.LineReaderAdapter.back *
            <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
            <-- am.englet.link.backadapters.LineReaderAdapter.metadata()
            --> java.io.BufferedReader *
            --> java.lang.Object *
        getNext()
            --> am.englet.link.backadapters.LineReaderAdapter.getBack()
            --> java.io.BufferedReader *
            --> java.io.BufferedReader.readLine() *
            --> java.io.IOException *
            --> java.lang.Object *
            --> java.lang.String *
        metadata
            --> am.englet.link.AdapterMetadata
            <-- am.englet.link.backadapters.LineReaderAdapter.metadata()
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
        metadata()
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.backadapters.LineReaderAdapter.getBack()
            --> am.englet.link.backadapters.LineReaderAdapter.metadata
            --> java.io.BufferedReader *
            --> java.lang.Object *
        static {}
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            --> am.englet.link.backadapters.LineReaderAdapter.class$0
            --> am.englet.link.backadapters.LineReaderAdapter.class$1
            --> am.englet.link.backadapters.LineReaderAdapter.metadata
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
    LineReaderStrategy
        --> am.englet.link.backadapters.CurrentlessStrategy
        LineReaderStrategy()
            <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            --> am.englet.link.backadapters.CurrentlessStrategy.CurrentlessStrategy()
        postCheckNext(am.englet.link.Storage)
            --> am.englet.link.Storage
            --> am.englet.link.Storage.restore()
            --> java.lang.Object *
        preCheckNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
    ResultSetStrategy
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
        --> am.englet.link.backadapters.CurrentOnceStrategy
        INSTANCE
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.ResultSetStrategy.static {}
        ResultSetStrategy()
            --> am.englet.link.backadapters.CurrentOnceStrategy.CurrentOnceStrategy()
            <-- am.englet.link.backadapters.ResultSetStrategy.static {}
        static {}
            --> am.englet.link.backadapters.ResultSetStrategy.INSTANCE
            --> am.englet.link.backadapters.ResultSetStrategy.ResultSetStrategy()
    StorageNeedingStrategy
        --> am.englet.link.BackUsageStrategy
        <-- am.englet.link.backadapters.CurrentOnceStrategy
        <-- am.englet.link.backadapters.CurrentlessStrategy
        --> java.lang.Object *
        StorageNeedingStrategy()
            <-- am.englet.link.backadapters.CurrentOnceStrategy.CurrentOnceStrategy()
            <-- am.englet.link.backadapters.CurrentlessStrategy.CurrentlessStrategy()
            --> java.lang.Object.Object() *
        getContent(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> java.lang.Object *
        getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackAdapter
            --> am.englet.link.Storage
            --> am.englet.link.Storage.restore()
            --> java.lang.Object *
        needsStorage()
        postCheckNext(am.englet.link.Storage)
            --> am.englet.link.Storage
            <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        preCheckNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackAdapter
            --> am.englet.link.Storage
            --> am.englet.link.Storage.store(java.lang.Object)
            --> am.englet.link.backadapters.StorageNeedingStrategy.getContent(am.englet.link.BackAdapter)
            --> am.englet.link.backadapters.StorageNeedingStrategy.postCheckNext(am.englet.link.Storage)
            --> am.englet.link.backadapters.StorageNeedingStrategy.preCheckNext(am.englet.link.BackAdapter)
            --> java.lang.Object *
    StoragelessStrategy
        --> am.englet.link.BackUsageStrategy
        <-- am.englet.link.backadapters.EnhancedResultSetStrategy
        --> java.lang.Object *
        StoragelessStrategy()
            <-- am.englet.link.backadapters.EnhancedResultSetStrategy.EnhancedResultSetStrategy()
            --> java.lang.Object.Object() *
        getCurrent(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> java.lang.Object *
        getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackAdapter
            --> am.englet.link.Storage
            --> am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter)
            --> java.lang.Object *
        needsStorage()
        tryNext(am.englet.link.BackAdapter)
            --> am.englet.link.BackAdapter
            <-- am.englet.link.backadapters.StoragelessStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
            --> am.englet.link.BackAdapter
            --> am.englet.link.Storage
            --> am.englet.link.backadapters.StoragelessStrategy.tryNext(am.englet.link.BackAdapter)
am.englet.link.backadapters.slider
    AppendableBackHoldingLinkSlider
        --> am.englet.link.backadapters.slider.AppendableSliderImpl
        --> am.englet.link.backadapters.slider.CallStacklLevelSlider
        AppendableBackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.back
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.slided
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
            --> java.util.LinkedList.LinkedList() *
            --> java.util.List *
        back
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.back()
        back()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.back
        content()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content0() *
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.fresh
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.slided
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        content0() *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
        fresh
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext00()
        go(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.go(am.englet.link.backadapters.slider.Slider) *
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.Slider
        go(am.englet.link.backadapters.slider.Slider) *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.go(am.englet.link.Link)
        slided
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
            --> java.util.List *
        sliders *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
        toString()
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.slided
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.util.List *
        tryNext()
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.sliders *
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext00()
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.isEmpty() *
            --> java.util.List.remove(int) *
        tryNext0() *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext00()
        tryNext00()
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.fresh
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
            --> am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext0() *
    AppendableCallStackSlider
        <-- am.englet.CallStackSliderImpl
        --> am.englet.link.backadapters.slider.AppendableSlider
        --> am.englet.link.backadapters.slider.CallStackSlider
        --> java.lang.Object *
        append(am.englet.link.Link, int)
            --> am.englet.link.Link
        content()
            --> java.lang.Object *
        current(int)
            --> am.englet.link.Link
        drop(int)
        go(am.englet.link.Link, int)
            --> am.englet.link.Link
        start(am.englet.link.Link)
            --> am.englet.link.Link
        tryNext()
    AppendableSlider
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        append(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.Slider
    AppendableSliderImpl
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider
        --> am.englet.link.backadapters.slider.AppendableSlider
        --> java.lang.Object *
        AppendableSliderImpl()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            --> java.lang.Object.Object() *
            --> java.util.LinkedList.LinkedList() *
            --> java.util.List *
        AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object.Object() *
            --> java.util.LinkedList.LinkedList() *
            --> java.util.List *
        append(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        content()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.content0()
            --> java.lang.Object *
        content0()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.first()
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> java.lang.Object *
        first()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content0()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext0()
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.get(int) *
        go(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.clear() *
        sliders
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.first()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
            --> java.util.List *
        tryNext()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext0()
            --> java.lang.Object *
            --> java.util.List *
            --> java.util.List.isEmpty() *
            --> java.util.List.remove(int) *
        tryNext0()
            --> am.englet.link.backadapters.slider.AppendableSliderImpl.first()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.tryNext()
    BackHoldingLinkSlider
        --> am.englet.link.backadapters.slider.CallStacklLevelSlider
        --> am.englet.link.backadapters.slider.LinkSlider
        <-- am.englet.link.backadapters.slider.LoopSlider
        BackHoldingLinkSlider(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.BackHoldingLinkSlider.back
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.LoopSlider.LoopSlider(am.englet.link.Link)
        back
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.BackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.back()
        back()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.BackHoldingLinkSlider.back
        go(am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
        tryNext() *
            <-- am.englet.link.backadapters.slider.LoopSlider.tryNext()
    CallStackSlider
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        current(int)
            --> am.englet.link.Link
        drop(int)
        go(am.englet.link.Link, int)
            --> am.englet.link.Link
        start(am.englet.link.Link)
            --> am.englet.link.Link
    CallStacklLevelSlider
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.at(int)
        <-- am.englet.CallStackSliderImpl.content()
        <-- am.englet.CallStackSliderImpl.current(int)
        <-- am.englet.CallStackSliderImpl.go(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.peek()
        <-- am.englet.CallStackSliderImpl.tryNext()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        back()
            <-- am.englet.CallStackSliderImpl.current(int)
            --> am.englet.link.Link
        content() *
            <-- am.englet.CallStackSliderImpl.content()
        go(am.englet.link.Link)
            <-- am.englet.CallStackSliderImpl.go(am.englet.link.Link, int)
            --> am.englet.link.Link
        tryNext() *
            <-- am.englet.CallStackSliderImpl.tryNext()
    ChainLink
        --> am.englet.link.AbstractLink
        ChainLink()
            --> am.englet.link.AbstractLink.AbstractLink()
            --> am.englet.link.backadapters.slider.ChainLink.links
            --> java.util.Stack *
            --> java.util.Stack.Stack() *
        at(int)
            --> am.englet.link.SliderLink
            --> am.englet.link.backadapters.slider.ChainLink.links
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.get(int) *
            --> java.util.Stack.size() *
        content()
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.backadapters.slider.ChainLink.peek()
            --> java.lang.Object *
        drop(int)
            --> am.englet.link.backadapters.slider.ChainLink.links
            --> java.util.Stack *
            --> java.util.Stack.setSize(int) *
            --> java.util.Stack.size() *
        links
            <-- am.englet.link.backadapters.slider.ChainLink.ChainLink()
            <-- am.englet.link.backadapters.slider.ChainLink.at(int)
            <-- am.englet.link.backadapters.slider.ChainLink.drop(int)
            <-- am.englet.link.backadapters.slider.ChainLink.next()
            <-- am.englet.link.backadapters.slider.ChainLink.peek()
            <-- am.englet.link.backadapters.slider.ChainLink.push(am.englet.link.SliderLink)
            --> java.util.Stack *
        next()
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
            --> am.englet.link.backadapters.slider.ChainLink.links
            --> am.englet.link.backadapters.slider.ChainLink.peek()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.pop() *
            --> java.util.Stack.size() *
        peek()
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.ChainLink.content()
            --> am.englet.link.backadapters.slider.ChainLink.links
            <-- am.englet.link.backadapters.slider.ChainLink.next()
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.peek() *
        push(am.englet.link.SliderLink)
            --> am.englet.link.SliderLink
            --> am.englet.link.backadapters.slider.ChainLink.links
            --> java.lang.Object *
            --> java.util.Stack *
            --> java.util.Stack.push(java.lang.Object) *
    ConcatSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        ConcatSlider(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.backadapters.slider.ConcatSlider.base
            --> am.englet.link.backadapters.slider.ConcatSlider.currentContent
            --> am.englet.link.backadapters.slider.ConcatSlider.sub
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        base
            <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        content()
            --> am.englet.link.backadapters.slider.ConcatSlider.currentContent
            --> java.lang.Object *
        currentContent
            <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.ConcatSlider.content()
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> java.lang.Object *
        sub
            <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tryNext()
            --> am.englet.Utils.isLink(java.lang.Object)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.ConcatSlider.base
            --> am.englet.link.backadapters.slider.ConcatSlider.currentContent
            --> am.englet.link.backadapters.slider.ConcatSlider.sub
            --> am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.SingletonSlider.SingletonSlider(java.lang.Object)
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> am.englet.link.backadapters.slider.Slider.tryNext()
            --> java.lang.Object *
    FilterSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
            <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
            --> am.englet.link.backadapters.slider.FilterSlider.c
            --> am.englet.link.backadapters.slider.FilterSlider.s
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.util.Checker
            --> java.lang.Object.Object() *
        c
            <-- am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            --> am.englet.util.Checker
        content
            <-- am.englet.link.backadapters.slider.FilterSlider.content()
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            --> java.lang.Object *
        content()
            --> am.englet.link.backadapters.slider.FilterSlider.content
            --> java.lang.Object *
        s
            <-- am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tryNext()
            --> am.englet.link.backadapters.slider.FilterSlider.c
            --> am.englet.link.backadapters.slider.FilterSlider.content
            --> am.englet.link.backadapters.slider.FilterSlider.s
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> am.englet.link.backadapters.slider.Slider.tryNext()
            --> am.englet.util.Checker
            --> am.englet.util.Checker.check(java.lang.Object)
            --> java.lang.Object *
    HeadSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.FinalLink
            --> am.englet.link.backadapters.slider.HeadSlider.content
            --> am.englet.link.backadapters.slider.HeadSlider.heads
            --> am.englet.link.backadapters.slider.HeadSlider.tails
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object.Object() *
        content
            --> am.englet.link.FinalLink
            <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.HeadSlider.content()
            <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
        content()
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.HeadSlider.content
            --> am.englet.link.backadapters.slider.HeadSlider.heads
            --> am.englet.link.backadapters.slider.HeadSlider.tails
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> java.lang.Object *
        heads
            <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.HeadSlider.content()
            <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tails
            <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.HeadSlider.content()
            <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tryNext()
            --> am.englet.link.FinalLink
            --> am.englet.link.backadapters.slider.HeadSlider.content
            --> am.englet.link.backadapters.slider.HeadSlider.heads
            --> am.englet.link.backadapters.slider.HeadSlider.tails
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.tryNext()
    InvocableBasedSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.SAME_OBJECT_RETURNING_INVOKABLE
            --> am.englet.Invokable.targetType()
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.i
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.isStatic
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.s
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.lang.Object.equals(java.lang.Object) *
        content
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            --> java.lang.Object *
        content()
            --> am.englet.Invokable
            --> am.englet.Invokable.NO_CLASSES
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.content
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.fresh
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.i
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.isStatic
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.s
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        fresh
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.tryNext()
        i
            --> am.englet.Invokable
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        isStatic
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        s
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        tryNext()
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.fresh
            --> am.englet.link.backadapters.slider.InvocableBasedSlider.s
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.tryNext()
    LinkSlider
        <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.MultiplySliderImpl.restart()
        <-- am.englet.MultiplySliderImpl.through
        <-- am.englet.MultiplySliderImpl.tryNext()
        <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        LinkSlider(am.englet.link.Link)
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
            <-- am.englet.MultiplySliderImpl.MultiplySliderImpl(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.go(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.BackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
            --> java.lang.Object.Object() *
        content()
            <-- am.englet.MultiplySliderImpl.restart()
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> am.englet.link.Link
            --> am.englet.link.Link.content()
            --> am.englet.link.backadapters.slider.LinkSlider.link
            --> java.lang.IllegalStateException.IllegalStateException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
        go(am.englet.link.Link)
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.BackHoldingLinkSlider.go(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            --> am.englet.link.backadapters.slider.LinkSlider.link
            --> java.lang.Object *
        link
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.LinkSlider.content()
            <-- am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.LinkSlider.tryNext()
        tryNext()
            <-- am.englet.MultiplySliderImpl.tryNext()
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            --> am.englet.link.Link
            --> am.englet.link.Link.next()
            --> am.englet.link.backadapters.slider.LinkSlider.link
    LinkSliderAdapter
        --> am.englet.link.TrivialBaseBackAdapterImpl
        LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
            --> am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
        back *
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
        class$0
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            --> java.lang.Class *
        current()
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> java.lang.Object *
        getSlider()
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.back *
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.current()
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata()
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.tryNext()
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
        metadata
            --> am.englet.link.AdapterMetadata
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata()
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
        metadata()
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.metadata
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object *
        static {}
            --> am.englet.link.AdapterMetadata
            --> am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.class$0
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.class$1
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.metadata
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        tryNext()
            --> am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.tryNext()
    LoopSlider
        --> am.englet.link.backadapters.slider.BackHoldingLinkSlider
        LoopSlider(am.englet.link.Link)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.BackHoldingLinkSlider.BackHoldingLinkSlider(am.englet.link.Link)
        back *
            <-- am.englet.link.backadapters.slider.LoopSlider.tryNext()
        go(am.englet.link.Link) *
            <-- am.englet.link.backadapters.slider.LoopSlider.tryNext()
        tryNext()
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.BackHoldingLinkSlider.tryNext() *
            --> am.englet.link.backadapters.slider.LoopSlider.back *
            --> am.englet.link.backadapters.slider.LoopSlider.go(am.englet.link.Link) *
    OptionallyEntailingSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
            <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.base
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.optionalTail
            --> am.englet.link.backadapters.slider.Slider
            --> java.lang.Object.Object() *
        base
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.tryNext()
            --> am.englet.link.backadapters.slider.Slider
        content()
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
            --> am.englet.link.Link
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.base
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.optionalTail
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.content()
            --> java.lang.Object *
        optionalTail
            --> am.englet.link.Link
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
        tryNext()
            --> am.englet.link.backadapters.slider.OptionallyEntailingSlider.base
            --> am.englet.link.backadapters.slider.Slider
            --> am.englet.link.backadapters.slider.Slider.tryNext()
    SingletonSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        SingletonSlider(java.lang.Object)
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            --> am.englet.link.backadapters.slider.SingletonSlider.content
            --> am.englet.link.backadapters.slider.SingletonSlider.exhausted
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        content
            <-- am.englet.link.backadapters.slider.SingletonSlider.SingletonSlider(java.lang.Object)
            <-- am.englet.link.backadapters.slider.SingletonSlider.content()
            --> java.lang.Object *
        content()
            --> am.englet.link.backadapters.slider.SingletonSlider.content
            --> am.englet.link.backadapters.slider.SingletonSlider.exhausted
            --> java.lang.Object *
        exhausted
            <-- am.englet.link.backadapters.slider.SingletonSlider.SingletonSlider(java.lang.Object)
            <-- am.englet.link.backadapters.slider.SingletonSlider.content()
            <-- am.englet.link.backadapters.slider.SingletonSlider.tryNext()
        tryNext()
            --> am.englet.link.backadapters.slider.SingletonSlider.exhausted
    Slider
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.Link, int)
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.Management.each(am.englet.CommandSource, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$12
        <-- am.englet.TestUtils0$FS1
        <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
        <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter, am.englet.TestUtils0$FS1)
        <-- am.englet.TestUtils0$FS1.s
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0$FS1.ts
        <-- am.englet.TestUtils0.div(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
        <-- am.englet.TestUtils0.times0(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.times1(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.Utils$5
        <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.sliderBasedLink(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
        <-- am.englet.Utils.splitSlider(java.lang.String, java.lang.String, int)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableSlider
        <-- am.englet.link.backadapters.slider.AppendableSlider.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content0()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.first()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext0()
        <-- am.englet.link.backadapters.slider.CallStackSlider
        <-- am.englet.link.backadapters.slider.CallStacklLevelSlider
        <-- am.englet.link.backadapters.slider.ConcatSlider
        <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.ConcatSlider.base
        <-- am.englet.link.backadapters.slider.ConcatSlider.sub
        <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
        <-- am.englet.link.backadapters.slider.FilterSlider
        <-- am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
        <-- am.englet.link.backadapters.slider.FilterSlider.s
        <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
        <-- am.englet.link.backadapters.slider.HeadSlider
        <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.HeadSlider.content()
        <-- am.englet.link.backadapters.slider.HeadSlider.heads
        <-- am.englet.link.backadapters.slider.HeadSlider.tails
        <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.s
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.tryNext()
        <-- am.englet.link.backadapters.slider.LinkSlider
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.current()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.tryNext()
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.base
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.tryNext()
        <-- am.englet.link.backadapters.slider.SingletonSlider
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider
        --> java.lang.Object *
        content()
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content0()
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            <-- am.englet.link.backadapters.slider.HeadSlider.content()
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.current()
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
            --> java.lang.Object *
        tryNext()
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext0()
            <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            <-- am.englet.link.backadapters.slider.HeadSlider.tryNext()
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.tryNext()
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.tryNext()
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.tryNext()
    UniqunessChecker
        --> am.englet.util.Checker
        --> java.lang.Object *
        UniqunessChecker()
            --> am.englet.link.backadapters.slider.UniqunessChecker.set
            --> java.lang.Object.Object() *
            --> java.util.HashSet.HashSet() *
            --> java.util.Set *
        check(java.lang.Object)
            --> am.englet.link.backadapters.slider.UniqunessChecker.set
            --> java.lang.Object *
            --> java.util.Set *
            --> java.util.Set.add(java.lang.Object) *
        set
            <-- am.englet.link.backadapters.slider.UniqunessChecker.UniqunessChecker()
            <-- am.englet.link.backadapters.slider.UniqunessChecker.check(java.lang.Object)
            --> java.util.Set *
am.englet.link.backadapters.slider.db
    BaseSimpleResultSetSlider
        --> am.englet.link.backadapters.slider.Slider
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.this$0
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.tryNext()
        --> java.lang.Object *
        BaseSimpleResultSetSlider(java.sql.ResultSet)
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.base
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.fieldCount
            --> java.lang.Object.Object() *
            --> java.sql.ResultSet *
            --> java.sql.ResultSet.getMetaData() *
            --> java.sql.ResultSetMetaData *
            --> java.sql.ResultSetMetaData.getColumnCount() *
            --> java.sql.SQLException *
            --> java.sql.SQLException.printStackTrace() *
        base
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.tryNext()
            --> java.sql.ResultSet *
        content()
            --> java.lang.Object *
        fieldCount
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.tryNext()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
        tryNext()
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.base
            --> java.sql.ResultSet *
            --> java.sql.ResultSet.next() *
            --> java.sql.SQLException *
            --> java.sql.SQLException.printStackTrace() *
    BaseSimpleResultSetSlider$RecordSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.fieldCounter
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.lastRead
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.this$0
            --> java.lang.Object.Object() *
        content()
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.data
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.fieldCounter
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.lastRead
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.this$0
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.base
            --> java.lang.Object *
            --> java.sql.ResultSet *
            --> java.sql.ResultSet.getObject(int) *
            --> java.sql.SQLException *
            --> java.sql.SQLException.printStackTrace() *
        data
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
            --> java.lang.Object *
        fieldCounter
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.tryNext()
        lastRead
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        this$0
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.tryNext()
        tryNext()
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.fieldCounter
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.this$0
            --> am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.fieldCount
    SimpleResultSetMetaDataSlider
        --> am.englet.link.backadapters.slider.Slider
        --> java.lang.Object *
        SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.base
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.colCount
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.counter
            --> java.lang.Object.Object() *
            --> java.sql.ResultSetMetaData *
            --> java.sql.ResultSetMetaData.getColumnCount() *
            --> java.sql.SQLException *
            --> java.sql.SQLException.printStackTrace() *
        base
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
            --> java.sql.ResultSetMetaData *
        colCount
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.tryNext()
        content()
            --> am.englet.link.FinalLink
            --> am.englet.link.FinalLink.FinalLink(java.lang.Object)
            --> am.englet.link.FinalLink.prepend(java.lang.Object)
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.base
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.counter
            --> java.lang.Integer.Integer(int) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.sql.ResultSetMetaData *
            --> java.sql.ResultSetMetaData.getColumnName(int) *
            --> java.sql.ResultSetMetaData.getColumnTypeName(int) *
            --> java.sql.ResultSetMetaData.getPrecision(int) *
            --> java.sql.ResultSetMetaData.getScale(int) *
            --> java.sql.SQLException *
            --> java.sql.SQLException.printStackTrace() *
        counter
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.tryNext()
        tryNext()
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.colCount
            --> am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.counter
am.englet.reflect
    AbstractSimpleInvokablePerformer
        <-- am.englet.reflect.SimpleInvokableGetter
        <-- am.englet.reflect.SimpleInvokableSetter
        --> java.lang.Object *
        AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.reflect.AbstractSimpleInvokablePerformer.args
            --> am.englet.reflect.AbstractSimpleInvokablePerformer.inv
            <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        args
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            --> java.lang.Object *
        inv
            --> am.englet.Invokable
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        toString()
            --> am.englet.Invokable
            --> am.englet.Utils.simpleClassname(java.lang.String)
            --> am.englet.reflect.AbstractSimpleInvokablePerformer.inv
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    MemberInvokable
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.ConstructorInvokable
        <-- am.englet.FieldGetInvokable
        <-- am.englet.FieldSetInvokable
        --> am.englet.Invokable
        <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.MethodInvokable
        <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        --> java.io.Serializable *
        --> java.lang.Object *
        MemberInvokable(java.lang.reflect.Member)
            <-- am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
            <-- am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            <-- am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
            <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
            --> am.englet.reflect.MemberInvokable.member
            --> java.lang.Object.Object() *
            --> java.lang.reflect.AccessibleObject *
            --> java.lang.reflect.AccessibleObject.setAccessible(boolean) *
            --> java.lang.reflect.Member *
        declaringType()
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> am.englet.reflect.MemberInvokable.member
            --> java.lang.Class *
            --> java.lang.reflect.Member *
            --> java.lang.reflect.Member.getDeclaringClass() *
        deprimitivise(java.lang.Class[])
            --> am.englet.Utils.deprimitivized(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
        extraToString()
            <-- am.englet.reflect.MemberInvokable.toString()
            --> java.lang.String *
        getMember()
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            --> am.englet.reflect.MemberInvokable.member
            --> java.lang.reflect.Member *
        invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            --> am.englet.reflect.MemberInvokable.member
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
        invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
            --> java.lang.reflect.Member *
        member
            <-- am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.declaringType()
            <-- am.englet.reflect.MemberInvokable.getMember()
            <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.reflect.MemberInvokable.name()
            <-- am.englet.reflect.MemberInvokable.parameterTypes()
            <-- am.englet.reflect.MemberInvokable.returnType()
            <-- am.englet.reflect.MemberInvokable.targetType()
            <-- am.englet.reflect.MemberInvokable.toString()
            --> java.lang.reflect.Member *
        name
            <-- am.englet.reflect.MemberInvokable.name()
            --> java.lang.String *
        name()
            --> am.englet.reflect.MemberInvokable.member
            --> am.englet.reflect.MemberInvokable.name
            --> am.englet.reflect.MemberInvokable.name(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.writeReplace()
            --> java.lang.String *
            --> java.lang.reflect.Member *
        name(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.name()
            --> java.lang.String *
            --> java.lang.reflect.Member *
        parameterTypes()
            <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> am.englet.reflect.MemberInvokable.member
            --> am.englet.reflect.MemberInvokable.parameterTypes(java.lang.reflect.Member)
            --> am.englet.reflect.MemberInvokable.pts
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.System.arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            --> java.lang.reflect.Member *
        parameterTypes(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.parameterTypes()
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        pts
            <-- am.englet.reflect.MemberInvokable.parameterTypes()
            --> java.lang.Class *
        returnType
            <-- am.englet.reflect.MemberInvokable.returnType()
            --> java.lang.Class *
        returnType()
            --> am.englet.reflect.MemberInvokable.member
            --> am.englet.reflect.MemberInvokable.returnType
            --> am.englet.reflect.MemberInvokable.returnType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        returnType(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.returnType()
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        serialVersionUID
        targetType
            <-- am.englet.reflect.MemberInvokable.targetType()
            --> java.lang.Class *
        targetType()
            --> am.englet.reflect.MemberInvokable.member
            --> am.englet.reflect.MemberInvokable.targetType
            --> am.englet.reflect.MemberInvokable.targetType(java.lang.reflect.Member)
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        targetType(java.lang.reflect.Member)
            <-- am.englet.reflect.MemberInvokable.targetType()
            --> java.lang.Class *
            --> java.lang.reflect.Member *
        toString()
            --> am.englet.Utils.simpleClassname(java.lang.String)
            --> am.englet.reflect.MemberInvokable.extraToString()
            --> am.englet.reflect.MemberInvokable.member
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Member *
        type()
            <-- am.englet.reflect.MemberInvokable.writeReplace()
            --> java.lang.String *
        writeReplace()
            --> am.englet.InvokableSerializer$SerializeInvokableDescription
            --> am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
            --> am.englet.reflect.MemberInvokable.name()
            --> am.englet.reflect.MemberInvokable.type()
            --> java.lang.Object *
            --> java.lang.String *
    SimpleGetter
        <-- am.englet.reflect.SimpleInvokableGetter
        <-- am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
        <-- am.englet.reflect.SimpleProperty.get
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.gettable()
        <-- am.englet.reflect.SimpleProperty.toString()
        <-- am.englet.reflect.SimpleProperty.valueType()
        <-- am.englet.reflect.Utils$1
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        --> java.lang.Object *
        DO(java.lang.Object)
            <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        valueType()
            <-- am.englet.reflect.SimpleProperty.valueType()
            --> java.lang.Class *
    SimpleInvokableGetter
        --> am.englet.reflect.AbstractSimpleInvokablePerformer
        --> am.englet.reflect.SimpleGetter
        DO(java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.reflect.SimpleInvokableGetter.args *
            --> am.englet.reflect.SimpleInvokableGetter.inv *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        SimpleInvokableGetter(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.Invokable.NO_CLASSES
            --> am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object *
        SimpleInvokableGetter(am.englet.Invokable, java.lang.Object[])
            --> am.englet.Invokable
            --> am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
            --> java.lang.Object *
        args *
            <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        inv *
            <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
            <-- am.englet.reflect.SimpleInvokableGetter.valueType()
        valueType()
            --> am.englet.Invokable
            --> am.englet.Invokable.returnType()
            --> am.englet.reflect.SimpleInvokableGetter.inv *
            --> java.lang.Class *
    SimpleInvokableSetter
        --> am.englet.reflect.AbstractSimpleInvokablePerformer
        --> am.englet.reflect.SimpleSetter
        DO(java.lang.Object, java.lang.Object)
            --> am.englet.Invokable
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.reflect.SimpleInvokableSetter.args *
            --> am.englet.reflect.SimpleInvokableSetter.index
            --> am.englet.reflect.SimpleInvokableSetter.inv *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        SimpleInvokableSetter(am.englet.Invokable)
            --> am.englet.Invokable
            --> am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.Object *
        SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
            --> am.englet.Invokable
            --> am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable)
            --> am.englet.reflect.SimpleInvokableSetter.index
            --> java.lang.Object *
        args *
            <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        index
            <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
            <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
        inv *
            <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
            <-- am.englet.reflect.SimpleInvokableSetter.valueType()
        valueType()
            --> am.englet.Invokable
            --> am.englet.Invokable.parameterTypes()
            --> am.englet.reflect.SimpleInvokableSetter.inv *
            --> java.lang.Class *
    SimpleProperty
        <-- am.englet.reflect.SimplePropertyTest.setUp()
        <-- am.englet.reflect.SimplePropertyTest.simpleProperty
        <-- am.englet.reflect.SimplePropertyTest.simpleProperty1
        <-- am.englet.reflect.SimplePropertyTest.simpleProperty3
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        --> java.lang.Object *
        SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleProperty.get
            --> am.englet.reflect.SimpleProperty.set
            --> am.englet.reflect.SimpleSetter
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.Object.Object() *
        get
            --> am.englet.reflect.SimpleGetter
            <-- am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
            <-- am.englet.reflect.SimpleProperty.gettable()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.SimpleProperty.valueType()
        get(java.lang.Object)
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleGetter.DO(java.lang.Object)
            --> am.englet.reflect.SimpleProperty.get
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        gettable()
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleProperty.get
        instance(java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            --> java.lang.Class *
            --> java.lang.String *
        set
            <-- am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
            <-- am.englet.reflect.SimpleProperty.settable()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.SimpleProperty.valueType()
            --> am.englet.reflect.SimpleSetter
        set(java.lang.Object, java.lang.Object)
            --> am.englet.reflect.SimpleProperty.set
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            --> am.englet.reflect.SimpleSetter
            --> am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        settable()
            --> am.englet.reflect.SimpleProperty.set
            --> am.englet.reflect.SimpleSetter
        toString()
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleProperty.get
            --> am.englet.reflect.SimpleProperty.set
            --> am.englet.reflect.SimpleSetter
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        valueType()
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleGetter.valueType()
            --> am.englet.reflect.SimpleProperty.get
            --> am.englet.reflect.SimpleProperty.set
            --> am.englet.reflect.SimpleSetter
            --> am.englet.reflect.SimpleSetter.valueType()
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Void.TYPE *
    SimplePropertyTest
        --> junit.framework.TestCase *
        SimplePropertyTest()
            --> junit.framework.TestCase.TestCase() *
        class$0
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            --> java.lang.Class *
        class$1
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            --> java.lang.Class *
        setUp()
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimplePropertyTest.class$0
            --> am.englet.reflect.SimplePropertyTest.class$1
            --> am.englet.reflect.SimplePropertyTest.simpleProperty
            --> am.englet.reflect.SimplePropertyTest.simpleProperty1
            --> am.englet.reflect.SimplePropertyTest.simpleProperty3
            --> am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.Exception *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> junit.framework.TestCase.setUp() *
        simpleProperty
            --> am.englet.reflect.SimpleProperty
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        simpleProperty1
            --> am.englet.reflect.SimpleProperty
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
        simpleProperty3
            --> am.englet.reflect.SimpleProperty
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
        testGet()
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.get(java.lang.Object)
            --> am.englet.reflect.SimplePropertyTest.simpleProperty
            --> am.englet.reflect.SimplePropertyTest.simpleProperty1
            --> am.englet.reflect.SimplePropertyTest.simpleProperty3
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.String) *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.reflect.InvocationTargetException *
        testSet()
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.get(java.lang.Object)
            --> am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
            --> am.englet.reflect.SimplePropertyTest.simpleProperty1
            --> am.englet.reflect.SimplePropertyTest.simpleProperty3
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.String) *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.lang.reflect.InvocationTargetException *
        testSimpleProperty()
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimplePropertyTest.simpleProperty
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
    SimpleSetter
        <-- am.englet.reflect.SimpleInvokableSetter
        <-- am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
        <-- am.englet.reflect.SimpleProperty.set
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.settable()
        <-- am.englet.reflect.SimpleProperty.toString()
        <-- am.englet.reflect.SimpleProperty.valueType()
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        --> java.lang.Object *
        DO(java.lang.Object, java.lang.Object)
            <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        valueType()
            <-- am.englet.reflect.SimpleProperty.valueType()
            --> java.lang.Class *
    Utils
        --> java.lang.Object *
        Utils()
            --> java.lang.Object.Object() *
        class$0
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            --> java.lang.Class *
        class$1
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            --> java.lang.Class *
        getSimpleProperty(java.lang.Class, java.lang.String)
            --> am.englet.Invokable
            --> am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
            --> am.englet.Utils.toClassNameCase(java.lang.String)
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
            --> am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable)
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            <-- am.englet.reflect.SimpleProperty.instance(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            --> am.englet.reflect.SimpleSetter
            --> am.englet.reflect.Utils$1.Utils$1(java.lang.Class)
            --> am.englet.reflect.Utils$2.Utils$2(java.lang.Class)
            --> am.englet.reflect.Utils$2.method(java.lang.Class[], java.lang.String[]) *
            --> am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getReturnType() *
        lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> am.englet.$$Declared
            --> am.englet.$$Declared.field(int, int, java.lang.String[]) *
            --> am.englet.$.declared
            --> am.englet.$.field(int, int, java.lang.String[]) *
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils$5.Utils$5(java.lang.Class)
            <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.setAccessible(boolean) *
        lookUpGetterMethod(java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            --> am.englet.Utils.toClassNameCase(java.lang.String)
            --> am.englet.reflect.Utils$3.Utils$3(java.lang.Class)
            --> am.englet.reflect.Utils$3.method(int, int, java.lang.Class[], java.lang.String[]) *
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Method *
        lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup$4.provide()
            --> am.englet.Utils.toClassNameCase(java.lang.String)
            --> am.englet.reflect.Utils.class$0
            --> am.englet.reflect.Utils.class$1
            --> am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Method *
        lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils$4.method() *
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Method *
        tryFieldProperty(java.lang.Class, java.lang.String)
            --> am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
            --> am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
            --> am.englet.Invokable
            --> am.englet.reflect.SimpleGetter
            --> am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
            --> am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable)
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            --> am.englet.reflect.SimpleSetter
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> java.lang.Class *
            --> java.lang.String *
            --> java.lang.reflect.Field *
    Utils$1
        --> am.englet.reflect.SimpleGetter
        --> java.lang.Object *
        DO(java.lang.Object)
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalArgumentException *
            --> java.lang.InstantiationException *
            --> java.lang.Object *
            --> java.lang.reflect.InvocationTargetException *
        Utils$1(java.lang.Class)
            --> am.englet.reflect.Utils$1.cls1
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.Object.Object() *
        cls1
            <-- am.englet.reflect.Utils$1.Utils$1(java.lang.Class)
            <-- am.englet.reflect.Utils$1.valueType()
            --> java.lang.Class *
        valueType()
            --> am.englet.reflect.Utils$1.cls1
            --> java.lang.Class *
    Utils$2
        --> am.englet.$
        Utils$2(java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> java.lang.reflect.Method *
        method(java.lang.Class[], java.lang.String[]) *
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
    Utils$3
        --> am.englet.$
        Utils$3(java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            --> java.lang.Class *
        check(java.lang.reflect.Method)
            --> java.lang.reflect.Method *
        method(int, int, java.lang.Class[], java.lang.String[]) *
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
    Utils$4
        --> am.englet.$
        Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.reflect.Utils$4.val$anObject
            --> am.englet.reflect.Utils$4.val$argType
            <-- am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
            --> java.lang.Class *
            --> java.lang.String *
        check(java.lang.reflect.Method)
            --> am.englet.reflect.Utils$4.val$anObject
            --> am.englet.reflect.Utils$4.val$argType
            --> java.lang.Class *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.reflect.Method *
            --> java.lang.reflect.Method.getModifiers() *
            --> java.lang.reflect.Method.getName() *
            --> java.lang.reflect.Method.getParameterTypes() *
            --> java.lang.reflect.Modifier.isStatic(int) *
        method() *
            <-- am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
        val$anObject
            <-- am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
            --> java.lang.String *
        val$argType
            <-- am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
            --> java.lang.Class *
    Utils$5
        --> am.englet.$
        Utils$5(java.lang.Class)
            --> am.englet.$.$(java.lang.Class)
            <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
            --> java.lang.Class *
        check(java.lang.reflect.Field)
            --> java.lang.reflect.Field *
am.englet.stateengine
    Act
        <-- am.englet.inputtokenizers.Act
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        --> am.englet.stateengine.Action
        --> java.lang.Cloneable *
        --> java.lang.Object *
        Act(java.lang.Object, java.lang.Object)
            <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
            --> am.englet.stateengine.Act.event
            --> am.englet.stateengine.Act.result
            --> am.englet.stateengine.Act.state
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        Act(java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Act.event
            --> am.englet.stateengine.Act.result
            --> am.englet.stateengine.Act.state
            --> java.lang.Object *
            --> java.lang.Object.Object() *
        act()
            <-- am.englet.inputtokenizers.Act.act()
            --> am.englet.stateengine.Act.result
            --> java.lang.Object *
        addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
            --> am.englet.stateengine.Engine
            --> java.lang.Object *
            --> java.lang.Object[] *
            --> java.lang.String *
            --> java.lang.String.split(java.lang.String) *
        addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
            <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Action
            --> am.englet.stateengine.Engine
            --> am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.lang.Object *
        clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
            --> am.englet.stateengine.Act.event
            --> am.englet.stateengine.Act.result
            <-- am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
            --> am.englet.stateengine.Act.state
            --> java.lang.CloneNotSupportedException *
            --> java.lang.CloneNotSupportedException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.clone() *
        event
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.event()
            <-- am.englet.stateengine.Act.toString()
            --> java.lang.Object *
        event()
            --> am.englet.stateengine.Act.event
            --> java.lang.Object *
        result
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.act()
            <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.toString()
            --> java.lang.Object *
        s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
            --> am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.s(java.lang.String)
            <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
        s(java.lang.String)
            --> am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
            --> am.englet.stateengine.Act[] *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.split(java.lang.String) *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List *
            --> java.util.List.toArray(java.lang.Object[]) *
        s(java.lang.String, java.lang.String)
            --> am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
            --> am.englet.stateengine.Act[] *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.split(java.lang.String) *
            --> java.util.ArrayList.ArrayList() *
            --> java.util.List *
            --> java.util.List.toArray(java.lang.Object[]) *
        state
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.state()
            <-- am.englet.stateengine.Act.toString()
            --> java.lang.Object *
        state()
            --> am.englet.stateengine.Act.state
            --> java.lang.Object *
        toString()
            --> am.englet.stateengine.Act.event
            --> am.englet.stateengine.Act.result
            --> am.englet.stateengine.Act.state
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    Act[] *
        <-- am.englet.stateengine.Act.s(java.lang.String)
        <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
    Action
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        <-- am.englet.stateengine.Act
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
        <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action[])
        --> java.lang.Object *
        act()
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            --> java.lang.Object *
        event()
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.lang.Object *
        state()
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.lang.Object *
    Engine
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
        --> java.io.Serializable *
        --> java.lang.Object *
        ALL
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
            --> java.lang.Object *
        DEFAULT
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.stateengine.Engine.Engine()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
            --> java.lang.Object *
        Engine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.ReaderTokenizerEngine(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.rules
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        FINISHED
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.stateengine.Engine.finished()
            <-- am.englet.stateengine.Engine.static {}
            --> java.lang.Object *
        act(java.lang.Object)
            --> am.englet.stateengine.Engine.ALL
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Engine.finished()
            --> am.englet.stateengine.Engine.reportIllegalState(java.lang.Object)
            --> am.englet.stateengine.Engine.state
            --> java.lang.IllegalStateException.IllegalStateException(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer() *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
        act0(java.lang.Object, java.lang.Object)
            --> am.englet.stateengine.Action
            --> am.englet.stateengine.Action.act()
            --> am.englet.stateengine.Engine.DEFAULT
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            --> am.englet.stateengine.Engine.rules
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        add(am.englet.stateengine.Action)
            <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
            --> am.englet.stateengine.Action
            --> am.englet.stateengine.Action.event()
            --> am.englet.stateengine.Action.state()
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action[])
            --> am.englet.stateengine.Engine.class$0
            --> am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
            --> am.englet.stateengine.Engine.intern(java.lang.Object)
            --> am.englet.stateengine.Engine.rules
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.Map *
        add(am.englet.stateengine.Action[])
            --> am.englet.stateengine.Action
            --> am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        class$0
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.lang.Class *
        class$1
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            --> java.lang.Class *
        container(java.lang.Object, java.util.Map, java.lang.Class)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Class.newInstance() *
            --> java.lang.IllegalAccessException *
            --> java.lang.IllegalAccessException.printStackTrace() *
            --> java.lang.InstantiationException *
            --> java.lang.InstantiationException.printStackTrace() *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        finished()
            --> am.englet.stateengine.Engine.FINISHED
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            --> am.englet.stateengine.Engine.is(java.lang.Object)
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
        getState()
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
        init(java.lang.Object)
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
        intern(java.lang.Object)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.intern() *
        is(java.lang.Object)
            <-- am.englet.stateengine.Engine.finished()
            --> am.englet.stateengine.Engine.state
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
        putDefault(java.util.Map, java.lang.Object)
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.class$1
            --> am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.ArrayList *
            --> java.util.ArrayList.add(java.lang.Object) *
            --> java.util.Map *
        reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            --> java.lang.Object *
        rules
            <-- am.englet.stateengine.Engine.Engine()
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            --> java.util.Map *
        serialVersionUID
        state
            <-- am.englet.stateengine.Engine.Engine()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.finished()
            <-- am.englet.stateengine.Engine.getState()
            <-- am.englet.stateengine.Engine.init(java.lang.Object)
            <-- am.englet.stateengine.Engine.is(java.lang.Object)
            --> java.lang.Object *
        static {}
            --> am.englet.stateengine.Engine$1.Engine$1(java.lang.Object)
            --> am.englet.stateengine.Engine$2.Engine$2(java.lang.Object)
            --> am.englet.stateengine.Engine$3.Engine$3(java.lang.Object)
            --> am.englet.stateengine.Engine.ALL
            --> am.englet.stateengine.Engine.DEFAULT
            --> am.englet.stateengine.Engine.FINISHED
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.intern() *
    Engine$1
        --> am.englet.util.AbstractListSingleton
        Engine$1(java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
            --> am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
            --> java.lang.Object *
        serialVersionUID
        toString()
            --> am.englet.util.AbstractListSingleton.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
    Engine$2
        --> am.englet.util.AbstractListSingleton
        Engine$2(java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
            --> am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
            --> java.lang.Object *
        serialVersionUID
    Engine$3
        --> am.englet.util.AbstractListSingleton
        Engine$3(java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
            --> am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
            --> java.lang.Object *
        serialVersionUID
am.englet.util
    AbstractListSingleton
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.isList(java.lang.Object)
        <-- am.englet.stateengine.Engine$1
        <-- am.englet.stateengine.Engine$2
        <-- am.englet.stateengine.Engine$3
        --> java.io.Serializable *
        --> java.util.AbstractList *
        AbstractListSingleton(java.lang.Object)
            <-- am.englet.stateengine.Engine$1.Engine$1(java.lang.Object)
            <-- am.englet.stateengine.Engine$2.Engine$2(java.lang.Object)
            <-- am.englet.stateengine.Engine$3.Engine$3(java.lang.Object)
            --> am.englet.util.AbstractListSingleton.content
            --> java.lang.Object *
            --> java.util.AbstractList.AbstractList() *
        content
            <-- am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
            <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
            <-- am.englet.util.AbstractListSingleton.get(int)
            --> java.lang.Object *
        equals(java.lang.Object)
            --> am.englet.util.AbstractListSingleton.content
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.equals(java.lang.Object) *
            --> java.lang.Object.getClass() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
        get(int)
            --> am.englet.util.AbstractListSingleton.content
            --> java.lang.ArrayIndexOutOfBoundsException.ArrayIndexOutOfBoundsException(int) *
            --> java.lang.Object *
        serialVersionUID
        size()
        toString() *
            <-- am.englet.stateengine.Engine$1.toString()
    Buffer
        --> java.lang.Object *
        Buffer(int)
            --> am.englet.util.Buffer.buf
            --> java.lang.Object.Object() *
        Buffer(java.lang.String, int)
            --> am.englet.util.Buffer.buf
            --> java.lang.Character.toUpperCase(char) *
            --> java.lang.Object.Object() *
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
            --> java.lang.String.length() *
        buf
            <-- am.englet.util.Buffer.Buffer(int)
            <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
            <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
            <-- am.englet.util.Buffer.size()
        pump(java.io.InputStream, java.io.OutputStream)
            --> am.englet.util.Buffer.buf
            <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.io.InputStream.read(byte[]) *
            --> java.io.OutputStream *
            --> java.io.OutputStream.write(byte[], int, int) *
        pumpAll(java.io.InputStream, java.io.OutputStream)
            --> am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
            --> java.io.IOException *
            --> java.io.InputStream *
            --> java.io.InputStream.close() *
            --> java.io.OutputStream *
            --> java.io.OutputStream.close() *
        size()
            --> am.englet.util.Buffer.buf
    Checker
        <-- am.englet.EngletBasedChecker
        <-- am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Links$4.tryNextContent()
        <-- am.englet.Links$4.val$checker
        <-- am.englet.Links.checkerBased(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.Management.filter(am.englet.DataStack, am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.TestUtils0$6
        <-- am.englet.TestUtils0$7
        <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.nonstaticInvokableBasedCkecker(am.englet.Invokable)
        <-- am.englet.TestUtils0.staticInvokableBasedCkecker(am.englet.Invokable)
        <-- am.englet.Utils.filterLink(am.englet.link.Link, am.englet.util.Checker)
        <-- am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
        <-- am.englet.link.backadapters.slider.FilterSlider.c
        <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
        <-- am.englet.link.backadapters.slider.UniqunessChecker
        --> java.lang.Object *
        check(java.lang.Object)
            <-- am.englet.Links$4.tryNextContent()
            <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
            --> java.lang.Object *
    MapPath
        --> java.lang.Object *
        MapPath(java.lang.String)
            --> am.englet.util.MapPath.MapPath(java.lang.String, char)
            --> java.lang.String *
            --> java.lang.String.charAt(int) *
        MapPath(java.lang.String, char)
            <-- am.englet.util.MapPath.MapPath(java.lang.String)
            --> am.englet.util.MapPath.path
            --> am.englet.util.MapPath.separator
            --> java.lang.Object.Object() *
            --> java.lang.String *
        from(java.lang.Object)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.util.MapPath.listFrom(java.lang.Object)
            <-- am.englet.util.MapPath.mapFrom(java.lang.Object)
            --> am.englet.util.MapPath.path
            --> am.englet.util.MapPath.separator
            --> java.io.PrintStream *
            --> java.io.PrintStream.println(java.lang.Object) *
            --> java.lang.Integer *
            --> java.lang.Integer.decode(java.lang.String) *
            --> java.lang.Integer.intValue() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.indexOf(int, int) *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.System.out *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        listFrom(java.lang.Object)
            --> am.englet.util.MapPath.from(java.lang.Object)
            --> java.lang.Object *
            --> java.util.List *
        mapFrom(java.lang.Object)
            --> am.englet.util.MapPath.from(java.lang.Object)
            --> java.lang.Object *
            --> java.util.Map *
        path
            <-- am.englet.util.MapPath.MapPath(java.lang.String, char)
            <-- am.englet.util.MapPath.from(java.lang.Object)
            --> java.lang.String *
        separator
            <-- am.englet.util.MapPath.MapPath(java.lang.String, char)
            <-- am.englet.util.MapPath.from(java.lang.Object)
am.englet.wiring
    BeanPool
        --> am.englet.ServiceObject
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.beanPool
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.wire()
        --> java.lang.Object *
        BeanPool()
            --> am.englet.wiring.BeanPool.map
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        get(java.lang.String)
            --> am.englet.wiring.BeanPool.map
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        has(java.lang.String)
            --> am.englet.wiring.BeanPool.map
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.containsKey(java.lang.Object) *
        map
            <-- am.englet.wiring.BeanPool.BeanPool()
            <-- am.englet.wiring.BeanPool.get(java.lang.String)
            <-- am.englet.wiring.BeanPool.has(java.lang.String)
            <-- am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
            --> java.util.Map *
        put(java.lang.String, java.lang.Object)
            --> am.englet.wiring.BeanPool.map
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
    Builder
        <-- am.englet.wiring.BuilderImpl
        <-- am.englet.wiring.BuilderImpl.BuilderImpl()
        <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
        <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
        <-- am.englet.wiring.FieldBuilderImpl.builder
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$1
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.builder
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        --> java.lang.Object *
        build(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            --> java.lang.Object *
    BuilderImpl
        --> am.englet.wiring.Builder
        <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.BuilderImpl$1.this$0
        --> java.lang.Object *
        BuilderImpl()
            --> am.englet.wiring.Builder
            --> am.englet.wiring.BuilderImpl.factory
            --> am.englet.wiring.BuilderImpl.fieldBuilder
            --> am.englet.wiring.BuilderImpl.nameResolver
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            --> am.englet.wiring.NameResolver
            --> am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver()
            --> java.lang.Object.Object() *
        build(java.lang.Object)
            --> am.englet.$$Declared
            --> am.englet.$$Declared.$(int, int) *
            --> am.englet.$.$(int, int) *
            --> am.englet.$.declared
            --> am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
        factory
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
            --> am.englet.wiring.Factory
        fieldBuilder
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
            --> am.englet.wiring.FieldBuilder
        nameResolver
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
            --> am.englet.wiring.NameResolver
        setNameResolverProperties(java.util.Properties)
            --> am.englet.wiring.Builder
            --> am.englet.wiring.BuilderImpl.factory
            --> am.englet.wiring.BuilderImpl.fieldBuilder
            --> am.englet.wiring.BuilderImpl.nameResolver
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            --> am.englet.wiring.NameResolver
            --> am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver(java.util.Properties)
            --> java.util.Properties *
    BuilderImpl$1
        --> am.englet.$
        BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.wiring.BuilderImpl
            --> am.englet.wiring.BuilderImpl$1.this$0
            --> am.englet.wiring.BuilderImpl$1.val$obj
            <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
        each(java.lang.reflect.Field)
            --> am.englet.wiring.BuilderImpl
            --> am.englet.wiring.BuilderImpl$1.this$0
            --> am.englet.wiring.BuilderImpl$1.val$obj
            --> am.englet.wiring.BuilderImpl.fieldBuilder
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.FieldBuilder.value(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
            --> java.lang.reflect.Field.set(java.lang.Object, java.lang.Object) *
        this$0
            --> am.englet.wiring.BuilderImpl
            <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        val$obj
            <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            --> java.lang.Object *
    Factory
        <-- am.englet.wiring.BuilderImpl.BuilderImpl()
        <-- am.englet.wiring.BuilderImpl.factory
        <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
        <-- am.englet.wiring.FactoryPoolImpl
        <-- am.englet.wiring.FactoryPoolImpl$1
        <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
        <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
        <-- am.englet.wiring.FactoryPoolImpl.defaultFactory
        <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
        <-- am.englet.wiring.FieldBuilderImpl.factory
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.SpecialFactory
        --> java.lang.Object *
        instance(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
        instance(java.lang.Class, java.lang.Object[])
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class, java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Object *
    FactoryPoolImpl
        --> am.englet.wiring.Factory
        <-- am.englet.wiring.FactoryPoolImpl$1.FactoryPoolImpl$1(am.englet.wiring.FactoryPoolImpl)
        <-- am.englet.wiring.FactoryPoolImpl$1.this$0
        --> java.lang.Object *
        FactoryPoolImpl()
            --> am.englet.cast.SameObjectCasterProvider
            --> am.englet.cast.SameObjectCasterProvider.SameObjectCasterProvider()
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FactoryPoolImpl$1.FactoryPoolImpl$1(am.englet.wiring.FactoryPoolImpl)
            --> am.englet.wiring.FactoryPoolImpl.defaultFactory
            --> am.englet.wiring.FactoryPoolImpl.factories
            --> am.englet.wiring.FactoryPoolImpl.prov
            --> am.englet.wiring.FactoryPoolImpl.singletons
            --> java.lang.Object.Object() *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        add(am.englet.wiring.SpecialFactory)
            --> am.englet.wiring.FactoryPoolImpl.factories
            --> am.englet.wiring.SpecialFactory
            --> am.englet.wiring.SpecialFactory.target()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        add(java.lang.Class, am.englet.wiring.Factory)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FactoryPoolImpl.factories
            <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        class$0
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            --> java.lang.Class *
        defaultFactory
            --> am.englet.wiring.Factory
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
        factories
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
            <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
            <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
            --> java.util.Map *
        factory(java.lang.Class)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FactoryPoolImpl.factories
            <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        findFactory(java.lang.Class)
            --> am.englet.cast.SameObjectCasterProvider
            --> am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
            --> am.englet.wiring.FactoryPoolImpl.defaultFactory
            --> am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class, java.lang.Object[])
            --> am.englet.wiring.FactoryPoolImpl.prov
            --> java.lang.Class *
        instance(java.lang.Class)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.Factory.instance(java.lang.Class)
            --> am.englet.wiring.FactoryPoolImpl.class$0
            --> am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
            --> am.englet.wiring.FactoryPoolImpl.singletons
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
        instance(java.lang.Class, java.lang.Object[])
            --> am.englet.wiring.Factory
            --> am.englet.wiring.Factory.instance(java.lang.Class, java.lang.Object[])
            --> am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
        prov
            --> am.englet.cast.SameObjectCasterProvider
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
        singletons
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            --> java.util.Map *
    FactoryPoolImpl$1
        --> am.englet.wiring.Factory
        --> java.lang.Object *
        FactoryPoolImpl$1(am.englet.wiring.FactoryPoolImpl)
            --> am.englet.wiring.FactoryPoolImpl
            --> am.englet.wiring.FactoryPoolImpl$1.this$0
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            --> java.lang.Object.Object() *
        instance(java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.getConstructors() *
            --> java.lang.Class.newInstance() *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
        instance(java.lang.Class, java.lang.Object[])
            --> java.lang.Class *
            --> java.lang.Class.getConstructors() *
            --> java.lang.Class.isInstance(java.lang.Object) *
            --> java.lang.Exception *
            --> java.lang.Object *
            --> java.lang.reflect.Constructor *
            --> java.lang.reflect.Constructor.getParameterTypes() *
            --> java.lang.reflect.Constructor.newInstance(java.lang.Object[]) *
        this$0
            --> am.englet.wiring.FactoryPoolImpl
            <-- am.englet.wiring.FactoryPoolImpl$1.FactoryPoolImpl$1(am.englet.wiring.FactoryPoolImpl)
    FieldBuilder
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.BuilderImpl.BuilderImpl()
        <-- am.englet.wiring.BuilderImpl.fieldBuilder
        <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
        <-- am.englet.wiring.FieldBuilderImpl
        <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
        <-- am.englet.wiring.PoolsBuilder$1.access$0(am.englet.wiring.PoolsBuilder$1)
        <-- am.englet.wiring.PoolsBuilder$1.fieldBuilder
        <-- am.englet.wiring.PoolsBuilder$2
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        --> java.lang.Object *
        value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
    FieldBuilderImpl
        --> am.englet.wiring.FieldBuilder
        --> java.lang.Object *
        FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            --> am.englet.wiring.Builder
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.FieldBuilderImpl.builder
            --> am.englet.wiring.FieldBuilderImpl.factory
            --> am.englet.wiring.FieldBuilderImpl.nameResolver
            --> am.englet.wiring.NameResolver
            --> java.lang.Object.Object() *
        builder
            --> am.englet.wiring.Builder
            <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        class$0
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
        classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassLoader *
            --> java.lang.ClassLoader.getResource(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.ClassNotFoundException.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.replaceAll(java.lang.String, java.lang.String) *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.net.URL *
        factory
            --> am.englet.wiring.Factory
            <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        nameResolver
            <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.NameResolver
        properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.substring(int) *
            --> java.lang.String.substring(int, int) *
            --> java.lang.String.toUpperCase() *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
        targetClass(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.Utils.ensuredClassLoader(java.lang.Class)
            --> am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            --> am.englet.wiring.FieldBuilderImpl.nameResolver
            --> am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.NameResolver
            --> am.englet.wiring.NameResolver.resolve(java.lang.String)
            --> java.lang.Class *
            --> java.lang.Class.getName() *
            --> java.lang.ClassLoader *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.String.valueOf(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(char) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.lang.reflect.Field.getType() *
        value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.Builder
            --> am.englet.wiring.Builder.build(java.lang.Object)
            --> am.englet.wiring.Factory
            --> am.englet.wiring.Factory.instance(java.lang.Class)
            --> am.englet.wiring.FieldBuilderImpl.builder
            --> am.englet.wiring.FieldBuilderImpl.class$0
            --> am.englet.wiring.FieldBuilderImpl.factory
            --> am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.Class.isAssignableFrom(java.lang.Class) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getDeclaringClass() *
            --> java.lang.reflect.Field.getType() *
    NameResolver
        <-- am.englet.wiring.BuilderImpl.BuilderImpl()
        <-- am.englet.wiring.BuilderImpl.nameResolver
        <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
        <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
        <-- am.englet.wiring.FieldBuilderImpl.nameResolver
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PropertiesBasedNameResolver
        --> java.lang.Object *
        resolve(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            --> java.lang.String *
    ObjectProvider
        --> java.lang.Object *
        provide(java.lang.Class, am.englet.wiring.ObjectProvider$Context)
            --> am.englet.wiring.ObjectProvider$Context
            --> java.lang.Class *
            --> java.lang.Object *
    ObjectProvider$Context
        <-- am.englet.wiring.ObjectProvider.provide(java.lang.Class, am.englet.wiring.ObjectProvider$Context)
        --> java.lang.Object *
    PoolsBuilder
        <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
        <-- am.englet.wiring.PoolsBuilder$1.access$1(am.englet.wiring.PoolsBuilder$1)
        <-- am.englet.wiring.PoolsBuilder$1.this$0
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        --> java.lang.Object *
        ARG_CLASSES
            <-- am.englet.wiring.PoolsBuilder.static {}
            <-- am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
        PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            --> am.englet.SingletonPool
            --> am.englet.cast.ClassPool
            --> am.englet.wiring.BeanPool
            --> am.englet.wiring.Builder
            --> am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            --> am.englet.wiring.PoolsBuilder.beanPool
            --> am.englet.wiring.PoolsBuilder.beans
            --> am.englet.wiring.PoolsBuilder.builder
            --> am.englet.wiring.PoolsBuilder.classPool
            --> am.englet.wiring.PoolsBuilder.createdObjects
            --> am.englet.wiring.PoolsBuilder.settings
            --> am.englet.wiring.PoolsBuilder.singletonPool
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.Collections.EMPTY_MAP *
            --> java.util.LinkedList.LinkedList() *
            --> java.util.List *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        access$0(am.englet.wiring.PoolsBuilder)
            --> am.englet.cast.ClassPool
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
            --> am.englet.wiring.PoolsBuilder.classPool
        access$1(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            --> am.englet.wiring.PoolsBuilder.build
            --> java.util.Map *
        beanPool
            --> am.englet.wiring.BeanPool
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.wire()
        beans
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            --> java.util.Map *
        build
            <-- am.englet.wiring.PoolsBuilder.access$1(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.util.Map *
        build()
            --> am.englet.wiring.PoolsBuilder.wire()
        builder
            --> am.englet.wiring.Builder
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        class$0
            <-- am.englet.wiring.PoolsBuilder.static {}
            --> java.lang.Class *
        class$1
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Class *
        class$2
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Class *
        class$3
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            --> java.lang.Class *
        classPool
            --> am.englet.cast.ClassPool
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.access$0(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.wire()
        createdObjects
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.util.List *
        doImports()
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
            --> am.englet.cast.ClassPool.importPackages(java.lang.String[])
            --> am.englet.wiring.PoolsBuilder.classPool
            --> am.englet.wiring.PoolsBuilder.settings
            --> am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.String[] *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.iterator() *
            --> java.util.List.size() *
            --> java.util.List.toArray(java.lang.Object[]) *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.get(java.lang.Object) *
        doWith(java.lang.Object, java.util.Map)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.get(java.lang.Object)
            --> am.englet.reflect.SimpleProperty.instance(java.lang.Class, java.lang.String)
            <-> am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
        fillAssignables()
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.addImpl(java.lang.Class)
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder.classPool
            --> am.englet.wiring.PoolsBuilder.settings
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.iterator() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        fillBeanPool()
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord.object
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord.settings
            --> am.englet.wiring.PoolsBuilder.beans
            --> am.englet.wiring.PoolsBuilder.createdObjects
            --> am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.get(int) *
            --> java.util.List.isEmpty() *
            --> java.util.List.remove(int) *
            --> java.util.Map *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        fillBuild(java.util.Map)
            --> am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            --> am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
            --> java.util.Map *
        fillByClassAndName(java.util.Map, java.util.HashMap)
            --> am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.class$3
            --> am.englet.wiring.PoolsBuilder.classPool
            <-- am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.Throwable.getMessage() *
            --> java.util.HashMap *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        fillByNameBlock(java.util.Map, java.util.HashMap)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.classPool
            <-- am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.HashMap *
            --> java.util.HashMap.HashMap() *
            --> java.util.HashMap.put(java.lang.Object, java.lang.Object) *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.entrySet() *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.put(java.lang.Object, java.lang.Object) *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        getObject(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            --> am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.util.Map$Entry *
        getObject(java.util.Map$Entry)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.classPool
            <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
        instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            --> am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.reflect.MemberInvokable
            --> am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.wiring.Builder
            --> am.englet.wiring.Builder.build(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.builder
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Arrays.asList(java.lang.Object[]) *
            --> java.util.List *
        instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.wiring.PoolsBuilder.classPool
            <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
        instance(java.util.Map)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.forName(java.lang.String)
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
            --> am.englet.wiring.PoolsBuilder.classPool
            --> am.englet.wiring.PoolsBuilder.createdObjects
            --> am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            --> am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.toString() *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Collections.EMPTY_LIST *
            --> java.util.Iterator *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.add(java.lang.Object) *
            --> java.util.List.get(int) *
            --> java.util.List.size() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map$Entry.getKey() *
            --> java.util.Map$Entry.getValue() *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        instantiateBean(java.lang.String)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.wiring.BeanPool
            --> am.englet.wiring.BeanPool.get(java.lang.String)
            --> am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.beanPool
            --> am.englet.wiring.PoolsBuilder.beans
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            --> am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.io.PrintStream *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.append(java.lang.String) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        settings
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.wire()
            --> java.util.Map *
        setupBean(java.lang.Object, java.util.Map)
            --> am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            --> am.englet.reflect.SimpleProperty
            --> am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
            --> am.englet.reflect.SimpleProperty.valueType()
            --> am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-> am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            --> am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
            --> java.io.PrintStream *
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.String *
            --> java.lang.String.equals(java.lang.Object) *
            --> java.lang.StringBuffer *
            --> java.lang.StringBuffer.StringBuffer(java.lang.String) *
            --> java.lang.StringBuffer.append(java.lang.Object) *
            --> java.lang.StringBuffer.toString() *
            --> java.lang.System.out *
            --> java.util.Iterator *
            --> java.util.Iterator.hasNext() *
            --> java.util.Iterator.next() *
            --> java.util.List *
            --> java.util.List.iterator() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
            --> java.util.Map.keySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        singletonPool
            --> am.englet.SingletonPool
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.wire()
        static {}
            --> am.englet.wiring.PoolsBuilder.ARG_CLASSES
            --> am.englet.wiring.PoolsBuilder.class$0
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
        toSingleEntry(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.lang.Object *
            --> java.util.Iterator *
            --> java.util.Iterator.next() *
            --> java.util.Map *
            --> java.util.Map$Entry *
            --> java.util.Map.entrySet() *
            --> java.util.Set *
            --> java.util.Set.iterator() *
        unstring(java.lang.Object, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder.ARG_CLASSES
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            --> am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            --> java.lang.Class *
            --> java.lang.Object *
        wire()
            --> am.englet.SingletonPool
            --> am.englet.SingletonPool.putSingleton(java.lang.Object, java.lang.Class)
            --> am.englet.cast.ClassPool
            --> am.englet.wiring.BeanPool
            --> am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
            --> am.englet.wiring.PoolsBuilder.beanPool
            --> am.englet.wiring.PoolsBuilder.build
            <-- am.englet.wiring.PoolsBuilder.build()
            --> am.englet.wiring.PoolsBuilder.class$1
            --> am.englet.wiring.PoolsBuilder.class$2
            --> am.englet.wiring.PoolsBuilder.classPool
            --> am.englet.wiring.PoolsBuilder.doImports()
            --> am.englet.wiring.PoolsBuilder.fillAssignables()
            --> am.englet.wiring.PoolsBuilder.fillBeanPool()
            --> am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
            --> am.englet.wiring.PoolsBuilder.settings
            --> am.englet.wiring.PoolsBuilder.singletonPool
            --> java.lang.Class *
            --> java.lang.Class.forName(java.lang.String) *
            --> java.lang.ClassNotFoundException *
            --> java.lang.NoClassDefFoundError.NoClassDefFoundError(java.lang.String) *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.Throwable.getMessage() *
            --> java.util.Collections.EMPTY_MAP *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
    PoolsBuilder$1
        --> am.englet.wiring.Builder
        <-- am.englet.wiring.PoolsBuilder$2.PoolsBuilder$2(am.englet.wiring.PoolsBuilder$1)
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.this$1
        <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$3.this$1
        --> java.lang.Object *
        PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.PoolsBuilder
            --> am.englet.wiring.PoolsBuilder$1.fieldBuilder
            --> am.englet.wiring.PoolsBuilder$1.this$0
            --> am.englet.wiring.PoolsBuilder$2.PoolsBuilder$2(am.englet.wiring.PoolsBuilder$1)
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            --> java.lang.Object.Object() *
        SKIP
        access$0(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.PoolsBuilder$1.fieldBuilder
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        access$1(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder
            --> am.englet.wiring.PoolsBuilder$1.this$0
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        build(java.lang.Object)
            --> am.englet.$$Declared
            --> am.englet.$$Declared.$(int, int) *
            --> am.englet.$.$(int, int) *
            --> am.englet.$.declared
            --> am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
        fieldBuilder
            --> am.englet.wiring.FieldBuilder
            <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder$1.access$0(am.englet.wiring.PoolsBuilder$1)
        this$0
            --> am.englet.wiring.PoolsBuilder
            <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder$1.access$1(am.englet.wiring.PoolsBuilder$1)
    PoolsBuilder$2
        --> am.englet.wiring.FieldBuilder
        --> java.lang.Object *
        PoolsBuilder$2(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder$1
            <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            --> am.englet.wiring.PoolsBuilder$2.this$1
            --> java.lang.Object.Object() *
        byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder
            --> am.englet.wiring.PoolsBuilder$1
            --> am.englet.wiring.PoolsBuilder$1.access$1(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$2.this$1
            <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder.access$1(am.englet.wiring.PoolsBuilder)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        byNameOrNameAndType(java.lang.reflect.Field)
            --> am.englet.wiring.PoolsBuilder
            --> am.englet.wiring.PoolsBuilder$1
            --> am.englet.wiring.PoolsBuilder$1.access$1(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$2.this$1
            <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder.access$1(am.englet.wiring.PoolsBuilder)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.String *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getName() *
            --> java.lang.reflect.Field.getType() *
            --> java.util.Map *
            --> java.util.Map.get(java.lang.Object) *
        byType(java.lang.reflect.Field)
            --> am.englet.cast.ClassPool
            --> am.englet.cast.ClassPool.getImpl(java.lang.Class)
            --> am.englet.wiring.PoolsBuilder
            --> am.englet.wiring.PoolsBuilder$1
            --> am.englet.wiring.PoolsBuilder$1.access$1(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$2.this$1
            <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder.access$0(am.englet.wiring.PoolsBuilder)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.getType() *
        instance(java.lang.Class)
            --> am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            --> am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
            --> am.englet.reflect.MemberInvokable
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
        this$1
            --> am.englet.wiring.PoolsBuilder$1
            <-- am.englet.wiring.PoolsBuilder$2.PoolsBuilder$2(am.englet.wiring.PoolsBuilder$1)
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            --> am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
            --> java.lang.Class *
            --> java.lang.Object *
            --> java.lang.reflect.Field *
    PoolsBuilder$3
        --> am.englet.$
        PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
            --> am.englet.$.$(java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$1
            <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
            --> am.englet.wiring.PoolsBuilder$3.this$1
            --> am.englet.wiring.PoolsBuilder$3.val$obj
            --> java.lang.Class *
            --> java.lang.Object *
        each(java.lang.reflect.Field)
            --> am.englet.wiring.FieldBuilder
            --> am.englet.wiring.FieldBuilder.value(java.lang.reflect.Field, java.lang.Class)
            --> am.englet.wiring.PoolsBuilder$1
            --> am.englet.wiring.PoolsBuilder$1.access$0(am.englet.wiring.PoolsBuilder$1)
            --> am.englet.wiring.PoolsBuilder$3.this$1
            --> am.englet.wiring.PoolsBuilder$3.val$obj
            --> java.lang.Class *
            --> java.lang.Exception *
            --> java.lang.Exception.printStackTrace() *
            --> java.lang.Object *
            --> java.lang.Object.getClass() *
            --> java.lang.reflect.Field *
            --> java.lang.reflect.Field.get(java.lang.Object) *
            --> java.lang.reflect.Field.set(java.lang.Object, java.lang.Object) *
        this$1
            --> am.englet.wiring.PoolsBuilder$1
            <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        val$obj
            <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
            --> java.lang.Object *
    PoolsBuilder$CreatedObjectRecord
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        --> java.lang.Object *
        PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord.object
            --> am.englet.wiring.PoolsBuilder$CreatedObjectRecord.settings
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            --> java.lang.Object *
            --> java.lang.Object.Object() *
            --> java.util.Map *
        object
            <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            --> java.lang.Object *
        settings
            <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            --> java.util.Map *
    PropertiesBasedNameResolver
        --> am.englet.wiring.NameResolver
        --> java.lang.Object *
        PropertiesBasedNameResolver()
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            --> am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver(java.util.Properties)
            --> java.util.Properties *
        PropertiesBasedNameResolver(java.util.Properties)
            <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
            <-- am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver()
            --> am.englet.wiring.PropertiesBasedNameResolver.properties
            --> java.lang.Object.Object() *
            --> java.util.Properties *
        getProperties()
            --> am.englet.wiring.PropertiesBasedNameResolver.properties
            --> java.util.Properties *
        properties
            <-- am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver(java.util.Properties)
            <-- am.englet.wiring.PropertiesBasedNameResolver.getProperties()
            <-- am.englet.wiring.PropertiesBasedNameResolver.resolve(java.lang.String)
            <-- am.englet.wiring.PropertiesBasedNameResolver.setProperties(java.util.Properties)
            --> java.util.Properties *
        resolve(java.lang.String)
            --> am.englet.wiring.PropertiesBasedNameResolver.properties
            --> java.lang.String *
            --> java.util.Properties *
            --> java.util.Properties.getProperty(java.lang.String) *
        setProperties(java.util.Properties)
            --> am.englet.wiring.PropertiesBasedNameResolver.properties
            --> java.util.Properties *
    SpecialFactory
        --> am.englet.wiring.Factory
        <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
        --> java.lang.Object *
        target()
            <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
            --> java.lang.Class *
    Utils
        --> java.lang.Object *
        Utils()
            --> java.lang.Object.Object() *
bsh *
    BshMethod *
        <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        <-- am.englet.bsh.MethodInvokable.MethodInvokable(bsh.BshMethod)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.bsh.MethodInvokable.method
        <-- am.englet.bsh.MethodInvokable.parameterTypes()
        <-- am.englet.bsh.MethodInvokable.returnType()
        <-- am.englet.bsh.MethodInvokable.toString()
        <-- am.englet.bsh.MethodInvokableMetadata.MethodInvokableMetadata(bsh.BshMethod)
        <-- am.englet.bsh.MethodInvokableMetadata.invokable()
        <-- am.englet.bsh.MethodInvokableMetadata.method
        getName() *
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        getParameterTypes() *
            <-- am.englet.bsh.MethodInvokable.parameterTypes()
        getReturnType() *
            <-- am.englet.bsh.MethodInvokable.returnType()
        invoke(java.lang.Object[], bsh.Interpreter) *
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        toString() *
            <-- am.englet.bsh.MethodInvokable.toString()
    BshMethod[] *
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
    EvalError *
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        getMessage() *
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        getScriptStackTrace() *
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
    Interpreter *
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        source(java.lang.String) *
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
java.awt *
    Toolkit *
        <-- am.englet.Utils.getClipboard()
        getDefaultToolkit() *
            <-- am.englet.Utils.getClipboard()
        getSystemClipboard() *
            <-- am.englet.Utils.getClipboard()
java.awt.datatransfer *
    Clipboard *
        <-- am.englet.Processing.toClip(java.lang.String)
        <-- am.englet.Utils.getClipString()
        <-- am.englet.Utils.getClipboard()
        getContents(java.lang.Object) *
            <-- am.englet.Utils.getClipString()
        setContents(java.awt.datatransfer.Transferable, java.awt.datatransfer.ClipboardOwner) *
            <-- am.englet.Processing.toClip(java.lang.String)
    ClipboardOwner *
        <-- am.englet.Processing.toClip(java.lang.String)
    DataFlavor *
        <-- am.englet.Utils.getClipString()
        stringFlavor *
            <-- am.englet.Utils.getClipString()
    StringSelection *
        StringSelection(java.lang.String) *
            <-- am.englet.Processing.toClip(java.lang.String)
    Transferable *
        <-- am.englet.Processing.toClip(java.lang.String)
        <-- am.englet.Utils.getClipString()
        getTransferData(java.awt.datatransfer.DataFlavor) *
            <-- am.englet.Utils.getClipString()
java.io *
    BufferedReader *
        <-- am.englet.TestUtils0$9.TestUtils0$9(java.io.BufferedReader)
        <-- am.englet.TestUtils0$9.tryNextContent()
        <-- am.englet.TestUtils0$9.val$bufferedInputStream
        <-- am.englet.TestUtils0.divL(java.io.InputStream)
        <-- am.englet.link.backadapters.LineReaderAdapter.LineReaderAdapter(java.io.BufferedReader)
        <-- am.englet.link.backadapters.LineReaderAdapter.getBack()
        <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
        <-- am.englet.link.backadapters.LineReaderAdapter.metadata()
        BufferedReader(java.io.Reader) *
            <-- am.englet.TestUtils0.divL(java.io.InputStream)
        readLine() *
            <-- am.englet.TestUtils0$9.tryNextContent()
            <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
    ByteArrayInputStream *
        ByteArrayInputStream(byte[]) *
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
    ByteArrayOutputStream *
        ByteArrayOutputStream() *
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        toString(java.lang.String) *
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
    File *
        <-- am.englet.Processing.fromFile(java.io.File)
        <-- am.englet.Processing.fromFile(java.lang.String)
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
        <-- am.englet.TestUtils0.gt(java.io.File)
        <-- am.englet.TestUtils0.lt(java.io.File)
        File(java.lang.String) *
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.Processing.fromFile(java.lang.String)
            <-- am.englet.Processing.fromFileo(java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
            <-- am.englet.flt.main(java.lang.String[])
        canRead() *
            <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
        exists() *
            <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
        getAbsolutePath() *
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.flt.main(java.lang.String[])
        length() *
            <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
    FileInputStream *
        FileInputStream(java.io.File) *
            <-- am.englet.Processing.fromFile(java.io.File)
            <-- am.englet.Processing.fromFileo(java.io.File)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.TestUtils0.gt(java.io.File)
        FileInputStream(java.lang.String) *
            <-- am.englet.flt.main(java.lang.String[])
        close() *
            <-- am.englet.Processing.fromFile(java.io.File)
            <-- am.englet.Processing.fromFileo(java.io.File)
    FileNotFoundException *
        <-- am.englet.Processing.fromFile(java.io.File)
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
        <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
        <-- am.englet.TestUtils0.gt(java.io.File)
        <-- am.englet.TestUtils0.lt(java.io.File)
        <-- am.englet.flt.main(java.lang.String[])
    FileOutputStream *
        <-- am.englet.TestUtils0.lt(java.io.File)
        FileOutputStream(java.io.File) *
            <-- am.englet.TestUtils0.lt(java.io.File)
        FileOutputStream(java.lang.String) *
            <-- am.englet.flt.main(java.lang.String[])
        FileOutputStream(java.lang.String, boolean) *
            <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
            <-- am.englet.Trace.open()
    FileReader *
        FileReader(java.lang.String) *
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
    IOException *
        <-- am.englet.Processing.fromFile(java.io.File)
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
        <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
        <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
        <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
        <-- am.englet.SimpleStringArrayEngletSettings.propsURLInput()
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.TestUtils0$9.tryNextContent()
        <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
        <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
        <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
        printStackTrace() *
            <-- am.englet.SingletonPool$util.sImpls()
            <-- am.englet.TestUtils0$9.tryNextContent()
            <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
    InputStream *
        <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
        <-- am.englet.Processing.fromFile(java.io.File)
        <-- am.englet.Processing.fromFile(java.lang.String)
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromUrl(java.lang.String)
        <-- am.englet.Processing.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.TestUtils0.divL(java.io.InputStream)
        <-- am.englet.TestUtils0.gt(java.io.File)
        <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
        available() *
            <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
        close() *
            <-- am.englet.SingletonPool$util.sImpls()
            <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
            <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
        read() *
            <-- am.englet.Processing.fromFile(java.lang.String)
        read(byte[]) *
            <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
            <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
        read(byte[], int, int) *
            <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
    InputStreamReader *
        InputStreamReader(java.io.InputStream) *
            <-- am.englet.TestUtils0.divL(java.io.InputStream)
    ObjectInputStream *
        ObjectInputStream(java.io.InputStream) *
            <-- am.englet.Processing.fromFileo(java.io.File)
            <-- am.englet.flt.main(java.lang.String[])
        readObject() *
            <-- am.englet.Processing.fromFileo(java.io.File)
            <-- am.englet.flt.main(java.lang.String[])
    ObjectOutputStream *
        ObjectOutputStream(java.io.OutputStream) *
            <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
            <-- am.englet.flt.main(java.lang.String[])
        close() *
            <-- am.englet.flt.main(java.lang.String[])
        flush() *
            <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
        writeObject(java.lang.Object) *
            <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
            <-- am.englet.flt.main(java.lang.String[])
    ObjectStreamException *
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.link.FinalLink$Serializable.readResolve()
        <-- am.englet.link.FinalLink.writeReplace()
    OutputStream *
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Processing.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
        <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
        <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
        <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.open()
        <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
        close() *
            <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
            <-- am.englet.util.Buffer.pumpAll(java.io.InputStream, java.io.OutputStream)
        flush() *
            <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
        write(byte[], int, int) *
            <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
            <-- am.englet.util.Buffer.pump(java.io.InputStream, java.io.OutputStream)
    PrintStream *
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.pop()
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.getArgument()
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.InvokableDescription.prepare()
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.dump(am.englet.MethodsStorage)
        <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.printstack(am.englet.DataStack)
        <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
        <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.TestUtils0$6.check(java.lang.Object)
        <-- am.englet.TestUtils0$7.check(java.lang.Object)
        <-- am.englet.Trace.close()
        <-- am.englet.Trace.objects(java.lang.Object[])
        <-- am.englet.Trace.open()
        <-- am.englet.Trace.ps
        <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
        <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        <-- am.englet.try1$try2.clone()
        <-- am.englet.try1$try2.try1$try2(am.englet.try1)
        <-- am.englet.try1.clone()
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.try1.try1()
        <-- am.englet.try2$A.p()
        <-- am.englet.util.MapPath.from(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- t.main(java.lang.String[])
        <-- t1.main(java.lang.String[])
        PrintStream(java.io.OutputStream) *
            <-- am.englet.Trace.open()
        checkError() *
            <-- am.englet.Trace.open()
        close() *
            <-- am.englet.Trace.close()
        flush() *
            <-- am.englet.Trace.objects(java.lang.Object[])
        print(java.lang.Object) *
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        print(java.lang.String) *
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Trace.open()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        println() *
            <-- am.englet.Trace.open()
            <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
        println(int) *
            <-- t.main(java.lang.String[])
            <-- t1.main(java.lang.String[])
        println(java.lang.Object) *
            <-- am.englet.LoopTest.test1()
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.dump(am.englet.MethodsStorage)
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
            <-- am.englet.flt.main(java.lang.String[])
            <-- am.englet.try1.main(java.lang.String[])
            <-- am.englet.try2$A.p()
            <-- am.englet.util.MapPath.from(java.lang.Object)
        println(java.lang.String) *
            <-- am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
    PushbackReader *
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
        PushbackReader(java.io.Reader) *
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
        read() *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.read()
        unread(int) *
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.unread()
    Reader *
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.TestUtils0.divL(java.io.InputStream)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
    Serializable *
        <-- am.englet.CompoundInvokable
        <-- am.englet.CompoundInvokable$ArgumentSource
        <-- am.englet.CompoundInvokable$InvokableWrapper
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription
        <-- am.englet.Links$NextContentProvider
        <-- am.englet.Links$ValueConverter
        <-- am.englet.MethodsStorage$Direct
        <-- am.englet.MethodsStorage$Getter
        <-- am.englet.MethodsStorage$Training
        <-- am.englet.MethodsStorage$Training$Invocation
        <-- am.englet.link.FinalLink$Serializable
        <-- am.englet.link.LazyLink
        <-- am.englet.link.Link$Serializable
        <-- am.englet.reflect.MemberInvokable
        <-- am.englet.stateengine.Engine
        <-- am.englet.util.AbstractListSingleton
    StringReader *
        StringReader(java.lang.String) *
            <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
java.lang *
    ArrayIndexOutOfBoundsException *
        <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        ArrayIndexOutOfBoundsException(int) *
            <-- am.englet.link.Storage$Nothing.get(int)
            <-- am.englet.util.AbstractListSingleton.get(int)
    Boolean *
        <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.toBoolean(java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        Boolean(boolean) *
            <-- am.englet.TestUtils0.isLink(java.lang.Object)
        FALSE *
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        TRUE *
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
        booleanValue() *
            <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.Utils.toBoolean(java.lang.Object)
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
            <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        equals(java.lang.Object) *
            <-- am.englet.TestUtils0$FS1.tryNext()
        valueOf(boolean) *
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        valueOf(java.lang.String) *
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
    Byte *
        Byte(byte) *
            <-- am.englet.SimpleCastingContext$3.cast(java.lang.Number)
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$.static {}
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
    CharSequence *
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.Processing.appendToFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.toCharSequence(java.lang.Object)
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        <-- am.englet.Utils.toCharSequence(java.lang.Object)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.setEvent(java.lang.CharSequence, java.lang.String)
        charAt(int) *
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.setEvent(java.lang.CharSequence, java.lang.String)
        length() *
            <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
        subSequence(int, int) *
            <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        toString() *
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence)
    Character *
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$.static {}
            <-- am.englet.Lookup.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
        isUpperCase(char) *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        toLowerCase(char) *
            <-- am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        toTitleCase(char) *
            <-- am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
        toUpperCase(char) *
            <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
    Class *
        <-- am.beans.reflect.ClassMap.ClassMap()
        <-- am.beans.reflect.ClassMap.class$0
        <-- am.beans.reflect.ClassMap.forName(java.lang.String)
        <-- am.beans.reflect.ClassMap.get(java.lang.String)
        <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
        <-- am.beans.reflect.Destringer.class$0
        <-- am.beans.reflect.Destringer.class$1
        <-- am.beans.reflect.Destringer.class$2
        <-- am.beans.reflect.Destringer.class$3
        <-- am.beans.reflect.Destringer.class$4
        <-- am.beans.reflect.Destringer.class$5
        <-- am.beans.reflect.Destringer.class$6
        <-- am.beans.reflect.Destringer.class$7
        <-- am.beans.reflect.Destringer.class$8
        <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.Destringer.static {}
        <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
        <-- am.beans.reflect.Property.dataType
        <-- am.beans.reflect.Property.of_class
        <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
        <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
        <-- am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$1.declaredMembers(java.lang.Class)
        <-- am.englet.$$1.members(java.lang.Class)
        <-- am.englet.$$1.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$2.declaredMembers(java.lang.Class)
        <-- am.englet.$$2.members(java.lang.Class)
        <-- am.englet.$$2.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$6.$$6(java.lang.Class)
        <-- am.englet.$$6.check(java.lang.reflect.Method)
        <-- am.englet.$$7.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$MethodPerformer.declaredMembers(java.lang.Class)
        <-- am.englet.$$MethodPerformer.members(java.lang.Class)
        <-- am.englet.$$MethodPerformer.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$Performer.declaredMembers(java.lang.Class)
        <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.members(java.lang.Class)
        <-- am.englet.$$Performer.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.check(java.lang.reflect.Constructor)
        <-- am.englet.$.check(java.lang.reflect.Field)
        <-- am.englet.$.check(java.lang.reflect.Method)
        <-- am.englet.$.class$0
        <-- am.englet.$.class$1
        <-- am.englet.$.class$10
        <-- am.englet.$.class$11
        <-- am.englet.$.class$12
        <-- am.englet.$.class$13
        <-- am.englet.$.class$14
        <-- am.englet.$.class$2
        <-- am.englet.$.class$3
        <-- am.englet.$.class$4
        <-- am.englet.$.class$5
        <-- am.englet.$.class$6
        <-- am.englet.$.class$7
        <-- am.englet.$.class$8
        <-- am.englet.$.class$9
        <-- am.englet.$.cls
        <-- am.englet.$.declaredMembers()
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
        <-- am.englet.$.members()
        <-- am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
        <-- am.englet.$.paramTypesEqual(java.lang.Class[], java.lang.Class[])
        <-- am.englet.$.paramTypesFit(java.lang.Class[], java.lang.Class[])
        <-- am.englet.$.static {}
        <-- am.englet.$Base.$()
        <-- am.englet.$Base.$(int, int)
        <-- am.englet.$Base.$(int, int, java.lang.Class[])
        <-- am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object)
        <-- am.englet.$Base.$(java.lang.Object, int, int)
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.String[])
        <-- am.englet.$Base.constructor(int, int, java.lang.Class[])
        <-- am.englet.$Base.constructor(java.lang.Class[])
        <-- am.englet.$Base.field(int, int, java.lang.Class)
        <-- am.englet.$Base.field(int, int, java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.Class)
        <-- am.englet.$Base.field(java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.method(int, int, java.lang.Class[])
        <-- am.englet.$Base.method(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(java.lang.Class[])
        <-- am.englet.$Base.method(java.lang.Class[], java.lang.String[])
        <-- am.englet.ArgumentProvider.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.ArgumentProvider.getNNextArgumentTypes(int)
        <-- am.englet.CastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContext.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.addTypeSubst(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CastingContextImpl1.class$0
        <-- am.englet.CastingContextImpl1.class$1
        <-- am.englet.CastingContextImpl1.class$2
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.lookUpBySource(java.lang.Class)
        <-- am.englet.CastingContextImpl1.lookUpByTarget(java.lang.Class)
        <-- am.englet.CompoundInvokable$1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CompoundInvokable$1.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.argTypes
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.parameterTypes
        <-- am.englet.CompoundInvokable.parameterTypes()
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.returnType()
        <-- am.englet.CompoundInvokable.targetType()
        <-- am.englet.CompoundInvokable.toString()
        <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
        <-- am.englet.ConstructorInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.DataStack.class$0
        <-- am.englet.DataStack.class$1
        <-- am.englet.DataStack.class$2
        <-- am.englet.DataStack.class$3
        <-- am.englet.DataStack.class$4
        <-- am.englet.DataStack.frame()
        <-- am.englet.DataStack.mustNotHave(java.lang.Object)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
        <-- am.englet.Englet.CLASSES
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.Englet.class$0
        <-- am.englet.Englet.class$1
        <-- am.englet.Englet.class$10
        <-- am.englet.Englet.class$11
        <-- am.englet.Englet.class$12
        <-- am.englet.Englet.class$13
        <-- am.englet.Englet.class$2
        <-- am.englet.Englet.class$3
        <-- am.englet.Englet.class$4
        <-- am.englet.Englet.class$5
        <-- am.englet.Englet.class$6
        <-- am.englet.Englet.class$7
        <-- am.englet.Englet.class$8
        <-- am.englet.Englet.class$9
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.Englet.getCastingContext()
        <-- am.englet.Englet.getMethods()
        <-- am.englet.Englet.getNNextArgumentTypes(int)
        <-- am.englet.Englet.getParserFactory()
        <-- am.englet.Englet.getRstack()
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.getSingleton(java.lang.Class)
        <-- am.englet.Englet.getStack()
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Englet.managementArgClasses
        <-- am.englet.Englet.managementArgClasses()
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.putSingleton(java.lang.Object)
        <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
        <-- am.englet.Englet.static {}
        <-- am.englet.FieldGetInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.Invokable$1.parameterTypes()
        <-- am.englet.Invokable$1.returnType()
        <-- am.englet.Invokable$1.targetType()
        <-- am.englet.Invokable.NO_CLASSES
        <-- am.englet.Invokable.parameterTypes()
        <-- am.englet.Invokable.returnType()
        <-- am.englet.Invokable.static {}
        <-- am.englet.Invokable.targetType()
        <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$2(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class)
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$3(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.Class[])
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.declaringType
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.parameterTypes
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.class$0
        <-- am.englet.InvokableSerializer.class$1
        <-- am.englet.InvokableSerializer.class$2
        <-- am.englet.InvokableSerializer.class$3
        <-- am.englet.InvokableSerializer.class$4
        <-- am.englet.InvokableSerializer.class$5
        <-- am.englet.InvokableSerializer.class$6
        <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
        <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
        <-- am.englet.Lookup$1.result()
        <-- am.englet.Lookup$1.val$ofWhat
        <-- am.englet.Lookup$1.val$types
        <-- am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$10.val$nNextArgumentTypes
        <-- am.englet.Lookup$11.Lookup$11(java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$11.val$cls0
        <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup$4.provide()
        <-- am.englet.Lookup$4.val$at
        <-- am.englet.Lookup$4.val$cls
        <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup$5.val$at
        <-- am.englet.Lookup$5.val$cls
        <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
        <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$6.val$nNextArgumentTypes
        <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
        <-- am.englet.Lookup$7.result()
        <-- am.englet.Lookup$7.val$types
        <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
        <-- am.englet.Lookup$8.base
        <-- am.englet.Lookup$8.base()
        <-- am.englet.Lookup$8.current
        <-- am.englet.Lookup$8.hasNext()
        <-- am.englet.Lookup$8.next()
        <-- am.englet.Lookup$8.nxt()
        <-- am.englet.Lookup$8.val$cls
        <-- am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$9.result()
        <-- am.englet.Lookup$9.val$cc
        <-- am.englet.Lookup.CLASSES
        <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
        <-- am.englet.Lookup.class$0
        <-- am.englet.Lookup.class$1
        <-- am.englet.Lookup.class$10
        <-- am.englet.Lookup.class$11
        <-- am.englet.Lookup.class$12
        <-- am.englet.Lookup.class$2
        <-- am.englet.Lookup.class$3
        <-- am.englet.Lookup.class$4
        <-- am.englet.Lookup.class$5
        <-- am.englet.Lookup.class$6
        <-- am.englet.Lookup.class$7
        <-- am.englet.Lookup.class$8
        <-- am.englet.Lookup.class$9
        <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.dp1(java.lang.Class, java.lang.Class, am.englet.Lookup$DataProvider[], boolean, boolean)
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
        <-- am.englet.Lookup.fitsClassName(java.lang.Class, boolean, java.lang.String)
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.isCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup.iter1(java.lang.Class)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
        <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
        <-- am.englet.Lookup.static {}
        <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
        <-- am.englet.LoopTest$2.LoopTest$2(am.englet.LoopTest, java.lang.Class)
        <-- am.englet.LoopTest$3.LoopTest$3(am.englet.LoopTest, java.lang.Class)
        <-- am.englet.LoopTest.class$0
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Main.class$0
        <-- am.englet.Main.class$1
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management$1.Management$1(java.lang.Class, java.lang.String)
        <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
        <-- am.englet.Management$4.Management$4(java.lang.Class, java.lang.String)
        <-- am.englet.Management$5.Management$5(java.lang.Class, java.lang.String)
        <-- am.englet.Management$6.Management$6(java.lang.Class, java.lang.String)
        <-- am.englet.Management$7.Management$7(java.lang.Class, java.lang.String)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        <-- am.englet.Management.asClass(am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.class$0
        <-- am.englet.Management.class$1
        <-- am.englet.Management.class$2
        <-- am.englet.Management.class$3
        <-- am.englet.Management.class$4
        <-- am.englet.Management.class$5
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
        <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
        <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.arrayClass(java.lang.Class)
        <-- am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
        <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.class$0
        <-- am.englet.MethodInvokable.class$1
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.extraToString()
        <-- am.englet.MethodInvokable.p0class
        <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.MethodInvokableMetadata.targetType()
        <-- am.englet.MethodsStorage$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.MethodsStorage$Cast.castClass
        <-- am.englet.MethodsStorage$Cast.toString()
        <-- am.englet.MethodsStorage$Dispatcher.get(java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.MethodsStorage$MethodRecord.argTypes
        <-- am.englet.MethodsStorage$MethodRecord.argTypes()
        <-- am.englet.MethodsStorage$MethodRecord.copy(java.lang.Class[])
        <-- am.englet.MethodsStorage$MethodRecord.getParameterTypes()
        <-- am.englet.MethodsStorage$MethodRecord.nonSingletonArgTypes
        <-- am.englet.MethodsStorage$MethodRecord.parameterTypes()
        <-- am.englet.MethodsStorage$MethodRecord.resultType
        <-- am.englet.MethodsStorage$MethodRecord.returnType()
        <-- am.englet.MethodsStorage$MethodRecord.targetType
        <-- am.englet.MethodsStorage$MethodRecord.targetType()
        <-- am.englet.MethodsStorage.class$0
        <-- am.englet.MethodsStorage.class$1
        <-- am.englet.MethodsStorage.class$2
        <-- am.englet.MethodsStorage.class$3
        <-- am.englet.MethodsStorage.class$4
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SimpleCastingContext.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.class$0
        <-- am.englet.SimpleCastingContext.class$1
        <-- am.englet.SimpleCastingContext.class$2
        <-- am.englet.SimpleCastingContext.class$3
        <-- am.englet.SimpleCastingContext.class$4
        <-- am.englet.SimpleCastingContext.class$5
        <-- am.englet.SimpleCastingContext.class$6
        <-- am.englet.SimpleCastingContext.class$7
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
        <-- am.englet.SimpleCastingContext.static {}
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.class$0
        <-- am.englet.SimpleStringArrayEngletSettings.class$1
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
        <-- am.englet.SingletonPool$Derivation.clasz
        <-- am.englet.SingletonPool$Derivation.toString()
        <-- am.englet.SingletonPool$util.access$1(java.lang.String)
        <-- am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.SingletonPool.findImplementation(java.lang.Class)
        <-- am.englet.SingletonPool.getSingleton(java.lang.Class)
        <-- am.englet.SingletonPool.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.class$0
        <-- am.englet.TestUtils0.class$1
        <-- am.englet.TestUtils0.class$2
        <-- am.englet.TestUtils0.class$3
        <-- am.englet.TestUtils0.class$4
        <-- am.englet.TestUtils0.class$5
        <-- am.englet.TestUtils0.class$6
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.TestUtils0.filterLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.procLink(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.objects(java.lang.Object[])
        <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
        <-- am.englet.Utils$1.result()
        <-- am.englet.Utils$1.val$valueClass
        <-- am.englet.Utils$2.Utils$2(java.lang.Class, java.lang.String)
        <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
        <-- am.englet.Utils$3.parameterTypes
        <-- am.englet.Utils$3.parameterTypes()
        <-- am.englet.Utils$3.returnType
        <-- am.englet.Utils$3.returnType()
        <-- am.englet.Utils$3.targetType()
        <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
        <-- am.englet.Utils$4.parameterTypes
        <-- am.englet.Utils$4.parameterTypes()
        <-- am.englet.Utils$4.returnType
        <-- am.englet.Utils$4.returnType()
        <-- am.englet.Utils$4.targetType()
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.val$ifc
        <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        <-- am.englet.Utils.class$0
        <-- am.englet.Utils.class$1
        <-- am.englet.Utils.class$10
        <-- am.englet.Utils.class$11
        <-- am.englet.Utils.class$12
        <-- am.englet.Utils.class$13
        <-- am.englet.Utils.class$14
        <-- am.englet.Utils.class$15
        <-- am.englet.Utils.class$2
        <-- am.englet.Utils.class$3
        <-- am.englet.Utils.class$4
        <-- am.englet.Utils.class$5
        <-- am.englet.Utils.class$6
        <-- am.englet.Utils.class$7
        <-- am.englet.Utils.class$8
        <-- am.englet.Utils.class$9
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.copy(java.lang.Object[])
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.deprimitivized(java.lang.Class)
        <-- am.englet.Utils.ensuredClassLoader(java.lang.Class)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        <-- am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.isPublic(java.lang.Class)
        <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpConstructor(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
        <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
        <-- am.englet.Utils.simpleName(java.lang.Class)
        <-- am.englet.Utils.static {}
        <-- am.englet.Utils.staticInvokable(am.englet.Invokable, int)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
        <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.Management.class$0
        <-- am.englet.bsh.MethodInvokable.class$0
        <-- am.englet.bsh.MethodInvokable.parameterTypes()
        <-- am.englet.bsh.MethodInvokable.returnType()
        <-- am.englet.bsh.MethodInvokable.targetType()
        <-- am.englet.bsh.MethodInvokableMetadata.class$0
        <-- am.englet.bsh.MethodInvokableMetadata.targetType()
        <-- am.englet.cast.AbstractCaster.AbstractCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.AbstractCaster.source
        <-- am.englet.cast.AbstractCaster.source()
        <-- am.englet.cast.AbstractCaster.target
        <-- am.englet.cast.AbstractCaster.target()
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.add(am.englet.cast.CasterBank, java.lang.Class[], java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addCastChain(am.englet.cast.CasterBank, java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class, am.englet.cast.Caster, am.englet.cast.CasterProvider)
        <-- am.englet.cast.CastUtils.chain(java.lang.Class[], am.englet.cast.CasterProvider)
        <-- am.englet.cast.Caster.source()
        <-- am.englet.cast.Caster.target()
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.class$0
        <-- am.englet.cast.CasterBankCasterProviderImpl.class$1
        <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvider.NULL
        <-- am.englet.cast.CasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvider.static {}
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ChainCaster.source()
        <-- am.englet.cast.ChainCaster.target()
        <-- am.englet.cast.ClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
        <-- am.englet.cast.ClassPool$1.hasNext()
        <-- am.englet.cast.ClassPool$1.next()
        <-- am.englet.cast.ClassPool$1.nextValue
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool$1.provideNextValue1()
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.access$1(am.englet.cast.ClassPool, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.class$0
        <-- am.englet.cast.ClassPool.class$1
        <-- am.englet.cast.ClassPool.class$2
        <-- am.englet.cast.ClassPool.class$3
        <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        <-- am.englet.cast.ClassPool.forName(java.lang.String)
        <-- am.englet.cast.ClassPool.getImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.getResource(java.lang.String)
        <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.ConstructorBasedCaster.sourceClass()
        <-- am.englet.cast.ConstructorBasedCaster.targetClass()
        <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
        <-- am.englet.cast.ForkCaster.discriminator
        <-- am.englet.cast.ForkCaster.source()
        <-- am.englet.cast.ForkCaster.target()
        <-- am.englet.cast.InstanceMethodBasedCaster.sourceClass()
        <-- am.englet.cast.MethodBasedCaster.targetClass()
        <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.sourceClass()
        <-- am.englet.cast.PerfomerBasedAbstractCaster.targetClass()
        <-- am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
        <-- am.englet.cast.SameObjectCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.SameObjectCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.sourceClass()
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.StaticFactoryMethodBasedCasterProvider$1(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.check(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$cls
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$0
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.class$1
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster.class$0
        <-- am.englet.cast.StringToClassCaster.class$1
        <-- am.englet.cast.StringToClassCaster.source()
        <-- am.englet.cast.StringToClassCaster.target()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.source
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.successChain()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$0
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$1
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$2
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$3
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$4
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$5
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$6
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.class$7
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        <-- am.englet.cast.ToStringCaster.class$0
        <-- am.englet.cast.ToStringCaster.class$1
        <-- am.englet.cast.ToStringCaster.source()
        <-- am.englet.cast.ToStringCaster.target()
        <-- am.englet.dispatch.DispatcherRecord.getParameterTypes()
        <-- am.englet.dispatch.Utils$1.Utils$1(java.lang.Class[])
        <-- am.englet.dispatch.Utils$1.result()
        <-- am.englet.dispatch.Utils$1.val$what
        <-- am.englet.dispatch.Utils$2.Utils$2(int, java.lang.Class[])
        <-- am.englet.dispatch.Utils$2.result()
        <-- am.englet.dispatch.Utils$2.val$classes
        <-- am.englet.dispatch.Utils$3.Utils$3(java.lang.Class[])
        <-- am.englet.dispatch.Utils$3.result()
        <-- am.englet.dispatch.Utils$3.val$what
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.class$0
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.class$1
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
        <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        <-- am.englet.link.AdapterMetadata.backClass
        <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.class$0
        <-- am.englet.link.BackAdapterFactory.class$1
        <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        <-- am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.usageStrategyInstance(java.lang.Object)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.link.backadapters.IteratorAdapter.class$0
        <-- am.englet.link.backadapters.IteratorAdapter.class$1
        <-- am.englet.link.backadapters.IteratorAdapter.static {}
        <-- am.englet.link.backadapters.LineReaderAdapter.class$0
        <-- am.englet.link.backadapters.LineReaderAdapter.class$1
        <-- am.englet.link.backadapters.LineReaderAdapter.static {}
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.class$0
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.class$1
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        <-- am.englet.reflect.MemberInvokable.declaringType()
        <-- am.englet.reflect.MemberInvokable.deprimitivise(java.lang.Class[])
        <-- am.englet.reflect.MemberInvokable.parameterTypes()
        <-- am.englet.reflect.MemberInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.pts
        <-- am.englet.reflect.MemberInvokable.returnType
        <-- am.englet.reflect.MemberInvokable.returnType()
        <-- am.englet.reflect.MemberInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.targetType
        <-- am.englet.reflect.MemberInvokable.targetType()
        <-- am.englet.reflect.MemberInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.toString()
        <-- am.englet.reflect.SimpleGetter.valueType()
        <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
        <-- am.englet.reflect.SimpleInvokableGetter.valueType()
        <-- am.englet.reflect.SimpleInvokableSetter.valueType()
        <-- am.englet.reflect.SimpleProperty.instance(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.SimpleProperty.valueType()
        <-- am.englet.reflect.SimplePropertyTest.class$0
        <-- am.englet.reflect.SimplePropertyTest.class$1
        <-- am.englet.reflect.SimplePropertyTest.setUp()
        <-- am.englet.reflect.SimpleSetter.valueType()
        <-- am.englet.reflect.Utils$1.Utils$1(java.lang.Class)
        <-- am.englet.reflect.Utils$1.cls1
        <-- am.englet.reflect.Utils$1.valueType()
        <-- am.englet.reflect.Utils$2.Utils$2(java.lang.Class)
        <-- am.englet.reflect.Utils$3.Utils$3(java.lang.Class)
        <-- am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils$4.val$argType
        <-- am.englet.reflect.Utils$5.Utils$5(java.lang.Class)
        <-- am.englet.reflect.Utils.class$0
        <-- am.englet.reflect.Utils.class$1
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.class$0
        <-- am.englet.stateengine.Engine.class$1
        <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.try2$A.p()
        <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
        <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
        <-- am.englet.wiring.Factory.instance(java.lang.Class)
        <-- am.englet.wiring.Factory.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
        <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
        <-- am.englet.wiring.FactoryPoolImpl.class$0
        <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.findFactory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FieldBuilder.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.class$0
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.ObjectProvider.provide(java.lang.Class, am.englet.wiring.ObjectProvider$Context)
        <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder.ARG_CLASSES
        <-- am.englet.wiring.PoolsBuilder.class$0
        <-- am.englet.wiring.PoolsBuilder.class$1
        <-- am.englet.wiring.PoolsBuilder.class$2
        <-- am.englet.wiring.PoolsBuilder.class$3
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.static {}
        <-- am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder.wire()
        <-- am.englet.wiring.SpecialFactory.target()
        forName(java.lang.String) *
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
            <-- am.englet.$$5.$$5()
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.Englet()
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.getCastingContext()
            <-- am.englet.Englet.getMethods()
            <-- am.englet.Englet.getParserFactory()
            <-- am.englet.Englet.getRstack()
            <-- am.englet.Englet.getStack()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.parse(java.lang.String)
            <-- am.englet.Englet.run()
            <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
            <-- am.englet.Englet.static {}
            <-- am.englet.Invokable$1.returnType()
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.static {}
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.LoopTest.test1()
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Management.runner(am.englet.DataStack)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.SingletonPool$util.sImpls()
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.static {}
            <-- am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.MethodInvokable.targetType()
            <-- am.englet.bsh.MethodInvokableMetadata.targetType()
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StringToClassCaster.source()
            <-- am.englet.cast.StringToClassCaster.target()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            <-- am.englet.cast.ToStringCaster.source()
            <-- am.englet.cast.ToStringCaster.target()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.static {}
            <-- am.englet.wiring.PoolsBuilder.wire()
        forName(java.lang.String, boolean, java.lang.ClassLoader) *
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        getClassLoader() *
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.ensuredClassLoader(java.lang.Class)
        getComponentType() *
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Utils.copy(java.lang.Object[])
        getConstructor(java.lang.Class[]) *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.lookUpConstructor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        getConstructors() *
            <-- am.englet.$$2.members(java.lang.Class)
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        getDeclaredConstructors() *
            <-- am.englet.$$2.declaredMembers(java.lang.Class)
        getDeclaredFields() *
            <-- am.englet.$$1.declaredMembers(java.lang.Class)
        getDeclaredMethod(java.lang.String, java.lang.Class[]) *
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        getDeclaredMethods() *
            <-- am.englet.$$MethodPerformer.declaredMembers(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.try2$A.p()
        getField(java.lang.String) *
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        getFields() *
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
            <-- am.englet.$$1.members(java.lang.Class)
        getInterfaces() *
            <-- am.englet.Lookup$8.nxt()
            <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        getMethod(java.lang.String, java.lang.Class[]) *
            <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
            <-- am.englet.Management.runner(am.englet.DataStack)
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        getMethods() *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
            <-- am.englet.$$MethodPerformer.members(java.lang.Class)
            <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
        getModifiers() *
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Utils.isPublic(java.lang.Class)
        getName() *
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.Englet.Englet()
            <-- am.englet.Lookup.fitsClassName(java.lang.Class, boolean, java.lang.String)
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.Utils$1.result()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.simpleName(java.lang.Class)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        getPackage() *
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        getResourceAsStream(java.lang.String) *
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SingletonPool$util.sImpls()
        getSuperclass() *
            <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        isArray() *
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        isAssignableFrom(java.lang.Class) *
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup$8.nxt()
            <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.SameObjectCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        isInstance(java.lang.Object) *
            <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.SimpleCastingContext.cast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
            <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        isInterface() *
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        isPrimitive() *
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Utils.deprimitivized(java.lang.Class)
        newInstance() *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
        toString() *
            <-- am.beans.reflect.ClassMap.ClassMap()
    ClassCastException *
        ClassCastException(java.lang.String) *
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
    ClassLoader *
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.ensuredClassLoader(java.lang.Class)
        <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader)
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        getResource(java.lang.String) *
            <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        getSystemClassLoader() *
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.ensuredClassLoader(java.lang.Class)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
    ClassNotFoundException *
        <-- am.beans.reflect.ClassMap.forName(java.lang.String)
        <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.Destringer.static {}
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$.check(java.lang.reflect.Constructor)
        <-- am.englet.$.check(java.lang.reflect.Field)
        <-- am.englet.$.check(java.lang.reflect.Method)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
        <-- am.englet.$.static {}
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.DataStack.mustNotHave(java.lang.Object)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.getCastingContext()
        <-- am.englet.Englet.getMethods()
        <-- am.englet.Englet.getParserFactory()
        <-- am.englet.Englet.getRstack()
        <-- am.englet.Englet.getStack()
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
        <-- am.englet.Englet.static {}
        <-- am.englet.Invokable$1.returnType()
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup$8.base()
        <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.static {}
        <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.static {}
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$util.access$1(java.lang.String)
        <-- am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.static {}
        <-- am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.MethodInvokable.targetType()
        <-- am.englet.bsh.MethodInvokableMetadata.targetType()
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
        <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.getResource(java.lang.String)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StringToClassCaster.source()
        <-- am.englet.cast.StringToClassCaster.target()
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        <-- am.englet.cast.ToStringCaster.source()
        <-- am.englet.cast.ToStringCaster.target()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        <-- am.englet.link.backadapters.IteratorAdapter.static {}
        <-- am.englet.link.backadapters.LineReaderAdapter.static {}
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
        <-- am.englet.reflect.SimplePropertyTest.setUp()
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.static {}
        <-- am.englet.wiring.PoolsBuilder.wire()
        printStackTrace() *
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
    Class[] *
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.parameterTypes()
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.Utils$3.parameterTypes()
        <-- am.englet.Utils$4.parameterTypes()
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
    CloneNotSupportedException *
        <-- am.englet.MethodsStorage$Training$Invocation.clone()
        <-- am.englet.MethodsStorage$Training.data()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
        <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.try1$try2.clone()
        <-- am.englet.try1.clone()
        printStackTrace() *
            <-- am.englet.MethodsStorage$Training.data()
            <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
    Cloneable *
        <-- am.englet.MethodsStorage$Training$Invocation
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine
        <-- am.englet.stateengine.Act
        <-- am.englet.try1
        <-- am.englet.try1$try2
    Comparable *
        <-- am.englet.TestUtils0.gt(java.lang.Comparable, java.lang.Comparable)
        <-- am.englet.TestUtils0.lt(java.lang.Comparable, java.lang.Comparable)
        <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
        compareTo(java.lang.Object) *
            <-- am.englet.TestUtils0.gt(java.lang.Comparable, java.lang.Comparable)
            <-- am.englet.TestUtils0.lt(java.lang.Comparable, java.lang.Comparable)
            <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
    Double *
        <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
        <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        Double(double) *
            <-- am.englet.SimpleCastingContext$6.cast(java.lang.Number)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        Double(java.lang.String) *
            <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$.static {}
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
        doubleValue() *
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        valueOf(java.lang.String) *
            <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
    Exception *
        <-- am.beans.reflect.ConstructorCaller.call()
        <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object[])
        <-- am.beans.reflect.Destringer$1.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.Destringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.FieldGetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldGetter.get(java.lang.Object)
        <-- am.beans.reflect.FieldGetter.get(java.lang.Object, int)
        <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.FieldSetter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Getter.get(java.lang.Object)
        <-- am.beans.reflect.Getter.get(java.lang.Object, int)
        <-- am.beans.reflect.MemberCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.MethodCaller.call()
        <-- am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.MethodCaller.call(java.lang.Object[])
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Property.get(java.lang.Object)
        <-- am.beans.reflect.Property.get(java.lang.Object, int)
        <-- am.beans.reflect.Property.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Property.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Setter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Setter.set(java.lang.Object, java.lang.Object)
        <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.EngletSettings.apply(am.englet.Englet)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Processing.appendToFile(byte[], java.lang.String)
        <-- am.englet.Processing.appendToFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.chr(int)
        <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
        <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.fromClip()
        <-- am.englet.Processing.fromFile(java.lang.String)
        <-- am.englet.Processing.fromUrl(java.lang.String)
        <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.toClip(java.lang.String)
        <-- am.englet.Processing.toFile(byte[], java.lang.String)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.TestUtils0$4.convert(java.lang.Object)
        <-- am.englet.TestUtils0$5.convert(java.lang.Object)
        <-- am.englet.TestUtils0$6.check(java.lang.Object)
        <-- am.englet.TestUtils0$7.check(java.lang.Object)
        <-- am.englet.TestUtils0$8.tryNextContent()
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Trace.open()
        <-- am.englet.Trace.toString(am.englet.Invokable)
        <-- am.englet.Utils.getClipString()
        <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
        <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$1(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.link.FinalLink$Serializable.readResolve()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        <-- am.englet.reflect.SimplePropertyTest.setUp()
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        printStackTrace() *
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.TestUtils0$4.convert(java.lang.Object)
            <-- am.englet.TestUtils0$5.convert(java.lang.Object)
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
            <-- am.englet.TestUtils0$8.tryNextContent()
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
    Float *
        <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        Float(float) *
            <-- am.englet.SimpleCastingContext$5.cast(java.lang.Number)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        Float(java.lang.String) *
            <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$.static {}
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
    IllegalAccessException *
        <-- am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Invokable$1.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.SimpleGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.Utils$1.DO(java.lang.Object)
        <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
        printStackTrace() *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
    IllegalArgumentException *
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Invokable$1.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.SimpleGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.Utils$1.DO(java.lang.Object)
        IllegalArgumentException(java.lang.String) *
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
        printStackTrace() *
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
    IllegalStateException *
        IllegalStateException(java.lang.String) *
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
            <-- am.englet.link.StorageImpl.restore()
            <-- am.englet.link.backadapters.slider.LinkSlider.content()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
    InstantiationException *
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Invokable$1.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.SimpleGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.Utils$1.DO(java.lang.Object)
        <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
        printStackTrace() *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
            <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
    Integer *
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.multiKey
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.InvokableDescription.access$0(am.englet.InvokableDescription, java.lang.Integer)
        <-- am.englet.InvokableDescription.getMultiKey()
        <-- am.englet.InvokableDescription.multiKey
        <-- am.englet.InvokableDescription.toString()
        <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.toInt(java.lang.Number)
        <-- am.englet.util.MapPath.from(java.lang.Object)
        Integer(int) *
            <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
            <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Lookup$1.result()
            <-- am.englet.Lookup$7.result()
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.SimpleCastingContext$1.cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext.toInt(java.lang.Number)
            <-- am.englet.TestUtils0$1.tryNextContent()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.correctValue(java.lang.Object)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
            <-- am.englet.dispatch.Utils$2.result()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        Integer(java.lang.String) *
            <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.englet.$.static {}
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
        decode(java.lang.String) *
            <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
            <-- am.englet.util.MapPath.from(java.lang.Object)
        intValue() *
            <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
            <-- am.englet.util.MapPath.from(java.lang.Object)
        toHexString(int) *
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        toString(int) *
            <-- am.englet.Trace.open()
        toString(int, int) *
            <-- am.englet.Trace.timeString(long)
    Long *
        <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.Utils.correctValue(java.lang.Object)
        Long(java.lang.String) *
            <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        Long(long) *
            <-- am.englet.SimpleCastingContext$2.cast(java.lang.Number)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.englet.$.static {}
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
        decode(java.lang.String) *
            <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        intValue() *
            <-- am.englet.Utils.correctValue(java.lang.Object)
        longValue() *
            <-- am.englet.Utils.correctValue(java.lang.Object)
    Math *
        max(int, int) *
            <-- am.englet.DataStack.doDeframe(int)
    NegativeArraySizeException *
        <-- am.englet.MethodInvokable.arrayClass(java.lang.Class)
    NoClassDefFoundError *
        NoClassDefFoundError(java.lang.String) *
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
            <-- am.englet.$$5.$$5()
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.Englet()
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.getCastingContext()
            <-- am.englet.Englet.getMethods()
            <-- am.englet.Englet.getParserFactory()
            <-- am.englet.Englet.getRstack()
            <-- am.englet.Englet.getStack()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.parse(java.lang.String)
            <-- am.englet.Englet.run()
            <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
            <-- am.englet.Englet.static {}
            <-- am.englet.Invokable$1.returnType()
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.static {}
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.LoopTest.test1()
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Management.runner(am.englet.DataStack)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
            <-- am.englet.SingletonPool$util.sImpls()
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.static {}
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.MethodInvokable.targetType()
            <-- am.englet.bsh.MethodInvokableMetadata.targetType()
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StringToClassCaster.source()
            <-- am.englet.cast.StringToClassCaster.target()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            <-- am.englet.cast.ToStringCaster.source()
            <-- am.englet.cast.ToStringCaster.target()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.static {}
            <-- am.englet.wiring.PoolsBuilder.wire()
    NoSuchFieldException *
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
    NoSuchMethodError *
        NoSuchMethodError(java.lang.String) *
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
    NoSuchMethodException *
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils.lookUpConstructor(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        getMessage() *
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        printStackTrace() *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
    Number *
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.SimpleCastingContext$1.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$2.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$3.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$4.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$5.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$6.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$7.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$8.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$NumberCaster.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.toInt(java.lang.Number)
        <-- am.englet.TestUtils0.gt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.lt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.minus(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils.correctValue(java.lang.Object)
        <-- am.englet.Utils.toBoolean(java.lang.Object)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.compare(java.lang.Object, java.lang.Object)
        byteValue() *
            <-- am.englet.SimpleCastingContext$3.cast(java.lang.Number)
        doubleValue() *
            <-- am.englet.SimpleCastingContext$6.cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext$8.cast(java.lang.Number)
        floatValue() *
            <-- am.englet.SimpleCastingContext$5.cast(java.lang.Number)
        intValue() *
            <-- am.englet.SimpleCastingContext$1.cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext.toInt(java.lang.Number)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            <-- am.englet.Utils.toBoolean(java.lang.Object)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.compare(java.lang.Object, java.lang.Object)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.compare(java.lang.Object, java.lang.Object)
        longValue() *
            <-- am.englet.SimpleCastingContext$2.cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext$7.cast(java.lang.Number)
        shortValue() *
            <-- am.englet.SimpleCastingContext$4.cast(java.lang.Number)
    NumberFormatException *
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
    Object *
        <-- am.beans.reflect.ClassInfo
        <-- am.beans.reflect.ClassMap$v
        <-- am.beans.reflect.ClassMap.ClassMap()
        <-- am.beans.reflect.ClassMap.forName(java.lang.String)
        <-- am.beans.reflect.ClassMap.get(java.lang.String)
        <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
        <-- am.beans.reflect.ConstructorCaller.call()
        <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object[])
        <-- am.beans.reflect.Destringer
        <-- am.beans.reflect.Destringer$1.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.Destringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.Destringer.toString()
        <-- am.beans.reflect.FieldGetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldGetter.get(java.lang.Object)
        <-- am.beans.reflect.FieldGetter.get(java.lang.Object, int)
        <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
        <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.FieldSetter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Getter
        <-- am.beans.reflect.Getter.get(java.lang.Object)
        <-- am.beans.reflect.Getter.get(java.lang.Object, int)
        <-- am.beans.reflect.MemberCaller
        <-- am.beans.reflect.MemberCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.MethodCaller.call()
        <-- am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.MethodCaller.call(java.lang.Object[])
        <-- am.beans.reflect.MethodCallerBasedGetter
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedGetter.get(java.lang.Object, int)
        <-- am.beans.reflect.MethodCallerBasedSetter
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.MethodCallerBasedSetter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Property
        <-- am.beans.reflect.Property.get(java.lang.Object)
        <-- am.beans.reflect.Property.get(java.lang.Object, int)
        <-- am.beans.reflect.Property.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Property.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Setter
        <-- am.beans.reflect.Setter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Setter.set(java.lang.Object, java.lang.Object)
        <-- am.beans.reflect.Utils
        <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
        <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
        <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
        <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
        <-- am.englet.$$$Performer
        <-- am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$3
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$6.check(java.lang.reflect.Method)
        <-- am.englet.$$7
        <-- am.englet.$$7.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$First$Performer
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$Performer
        <-- am.englet.$$Performer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$Performer.nameFits(java.lang.String[], java.lang.String)
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.check(java.lang.reflect.Constructor)
        <-- am.englet.$.check(java.lang.reflect.Field)
        <-- am.englet.$.check(java.lang.reflect.Method)
        <-- am.englet.$.each(java.lang.reflect.Constructor, java.lang.Object)
        <-- am.englet.$.each(java.lang.reflect.Field, java.lang.Object)
        <-- am.englet.$.each(java.lang.reflect.Method, java.lang.Object)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
        <-- am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
        <-- am.englet.$.paramTypesEqual(java.lang.Class[], java.lang.Class[])
        <-- am.englet.$.static {}
        <-- am.englet.$Base
        <-- am.englet.$Base.$()
        <-- am.englet.$Base.$(int, int)
        <-- am.englet.$Base.$(int, int, java.lang.Class[])
        <-- am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object)
        <-- am.englet.$Base.$(java.lang.Object, int, int)
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.String[])
        <-- am.englet.$Base.constructor()
        <-- am.englet.$Base.constructor(int, int)
        <-- am.englet.$Base.constructor(int, int, java.lang.Class[])
        <-- am.englet.$Base.constructor(java.lang.Class[])
        <-- am.englet.$Base.field()
        <-- am.englet.$Base.field(int, int)
        <-- am.englet.$Base.field(int, int, java.lang.Class)
        <-- am.englet.$Base.field(int, int, java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(int, int, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.Class)
        <-- am.englet.$Base.field(java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.String[])
        <-- am.englet.$Base.method()
        <-- am.englet.$Base.method(int, int)
        <-- am.englet.$Base.method(int, int, java.lang.Class[])
        <-- am.englet.$Base.method(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(int, int, java.lang.String[])
        <-- am.englet.$Base.method(java.lang.Class[])
        <-- am.englet.$Base.method(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(java.lang.String[])
        <-- am.englet.ArgumentProvider
        <-- am.englet.ArgumentProvider$ArgumentsAndTarget
        <-- am.englet.ArgumentProvider$ArgumentsAndTarget.arguments()
        <-- am.englet.ArgumentProvider$ArgumentsAndTarget.target()
        <-- am.englet.CallStackSliderImpl
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.CallStackSliderImpl.at(int)
        <-- am.englet.CallStackSliderImpl.content()
        <-- am.englet.CallStackSliderImpl.peek()
        <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
        <-- am.englet.CallStackSliderImpl.tryNext()
        <-- am.englet.CastingContext
        <-- am.englet.CastingContext.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CastingContextImpl1
        <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CastingContextImpl1.wrapToImplementor(java.lang.Object)
        <-- am.englet.CodeBlock
        <-- am.englet.CodeBlock.result()
        <-- am.englet.CodeBlock.toString()
        <-- am.englet.CommandSource.toString()
        <-- am.englet.CompoundInvokable
        <-- am.englet.CompoundInvokable$1
        <-- am.englet.CompoundInvokable$1.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.CompoundInvokable$1.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.CompoundInvokable$2.CompoundInvokable$2(am.englet.CompoundInvokable$InvokableWrapper, java.lang.Object[])
        <-- am.englet.CompoundInvokable$2.result()
        <-- am.englet.CompoundInvokable$2.val$args
        <-- am.englet.CompoundInvokable$ArgArrayArgSource
        <-- am.englet.CompoundInvokable$ArgArrayArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$ArgumentSource
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$CreationContext
        <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
        <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
        <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
        <-- am.englet.CompoundInvokable$DirectArgSource
        <-- am.englet.CompoundInvokable$DirectArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvocationData
        <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
        <-- am.englet.CompoundInvokable$InvocationData.args
        <-- am.englet.CompoundInvokable$InvokableWrapper
        <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CompoundInvokable$CreationContext, am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.CompoundInvokable.parameterTypes()
        <-- am.englet.CompoundInvokable.prepareArgumentSources(int, am.englet.CompoundInvokable$CreationContext, java.lang.Object[], java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.CompoundInvokable.toString()
        <-- am.englet.ConditionalValueConverter
        <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.Const
        <-- am.englet.Const$1
        <-- am.englet.Const.NO_RESULT
        <-- am.englet.Const.static {}
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.DataStack
        <-- am.englet.DataStack$StackFrame.getBased(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.has(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.peek()
        <-- am.englet.DataStack$StackFrame.pop()
        <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.set(java.lang.Object, java.lang.Object)
        <-- am.englet.DataStack$StackFrame.shadow(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.toString()
        <-- am.englet.DataStack.at(int)
        <-- am.englet.DataStack.at(int, int)
        <-- am.englet.DataStack.enlist()
        <-- am.englet.DataStack.frame()
        <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.frame(java.util.List)
        <-- am.englet.DataStack.get(java.lang.Object)
        <-- am.englet.DataStack.has(java.lang.Object)
        <-- am.englet.DataStack.last(int)
        <-- am.englet.DataStack.map(int)
        <-- am.englet.DataStack.mustNotHave(java.lang.Object)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.param()
        <-- am.englet.DataStack.param(int)
        <-- am.englet.DataStack.peek()
        <-- am.englet.DataStack.pop()
        <-- am.englet.DataStack.popReg(java.lang.Object)
        <-- am.englet.DataStack.push(java.lang.Object)
        <-- am.englet.DataStack.put(java.lang.Object, java.lang.Object)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
        <-- am.englet.DataStack.set(java.lang.Object, java.lang.Object)
        <-- am.englet.DataStack.st2()
        <-- am.englet.DataStack.stack()
        <-- am.englet.DataStack.toString()
        <-- am.englet.DataStack.top()
        <-- am.englet.Englet
        <-- am.englet.Englet$1
        <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
        <-- am.englet.Englet$1.arguments()
        <-- am.englet.Englet$1.clean()
        <-- am.englet.Englet$1.filledArgs0
        <-- am.englet.Englet$1.target()
        <-- am.englet.Englet$1.target0
        <-- am.englet.Englet$1.toString()
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.args
        <-- am.englet.Englet.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.Englet.cleanArgs(int)
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.getArgument()
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.getArgumentsAndTarget(java.lang.Class[], java.lang.Class)
        <-- am.englet.Englet.getCastingContext()
        <-- am.englet.Englet.getMethods()
        <-- am.englet.Englet.getParserFactory()
        <-- am.englet.Englet.getRstack()
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.getSingleton(java.lang.Class)
        <-- am.englet.Englet.getStack()
        <-- am.englet.Englet.handleResult(java.lang.Object)
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.putSingleton(java.lang.Object)
        <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
        <-- am.englet.EngletBasedChecker
        <-- am.englet.EngletBasedChecker.check(java.lang.Object)
        <-- am.englet.EngletBasedValueConverter
        <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.EngletSettings
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Immediate
        <-- am.englet.Immediate.chain(am.englet.DataStack)
        <-- am.englet.Immediate.perform(am.englet.DataStack, am.englet.MethodsStorage, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.popContent(am.englet.DataStack)
        <-- am.englet.Immediate.popContentObject(am.englet.DataStack)
        <-- am.englet.Invokable
        <-- am.englet.Invokable$1
        <-- am.englet.Invokable$1.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.InvokableBasedValueConverter
        <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.InvokableDescription
        <-- am.englet.InvokableDescription$PreparationContext
        <-- am.englet.InvokableDescription$PreparationContext$Counter
        <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.InvokableDescription.getSources()
        <-- am.englet.InvokableDescription.prepare()
        <-- am.englet.InvokableDescription.prepare(am.englet.InvokableDescription, am.englet.InvokableDescription$PreparationContext)
        <-- am.englet.InvokableDescription.sources
        <-- am.englet.InvokableDescription.toString()
        <-- am.englet.InvokableSerializer
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
        <-- am.englet.InvokableSerializer$3
        <-- am.englet.InvokableSerializer$4
        <-- am.englet.InvokableSerializer$5
        <-- am.englet.InvokableSerializer$MemberProvider
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.Links
        <-- am.englet.Links$1
        <-- am.englet.Links$1.convert(java.lang.Object)
        <-- am.englet.Links$2
        <-- am.englet.Links$2.tryNextContent()
        <-- am.englet.Links$3
        <-- am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
        <-- am.englet.Links$3.tryNextContent()
        <-- am.englet.Links$3.val$buv
        <-- am.englet.Links$4
        <-- am.englet.Links$4.tryNextContent()
        <-- am.englet.Links$5
        <-- am.englet.Links$5.tryNextContent()
        <-- am.englet.Links$6
        <-- am.englet.Links$6.convert(am.englet.Links$ValueConverter, java.lang.Object)
        <-- am.englet.Links$6.convert1(java.lang.Object, am.englet.Links$ValueConverter, am.englet.Links$ValueConverter)
        <-- am.englet.Links$6.tryNextContent()
        <-- am.englet.Links$7
        <-- am.englet.Links$7.convert(am.englet.Links$ValueConverter, java.lang.Object)
        <-- am.englet.Links$7.tryNextContent()
        <-- am.englet.Links$8
        <-- am.englet.Links$8.tryNextContent()
        <-- am.englet.Links$9
        <-- am.englet.Links$9.tryNextContent()
        <-- am.englet.Links$Calculate_Next_Based
        <-- am.englet.Links$NextContentProvider
        <-- am.englet.Links$NextContentProvider.tryNextContent()
        <-- am.englet.Links$TryNextContentBased.Links$TryNextContentBased(java.lang.Object, am.englet.Links$NextContentProvider)
        <-- am.englet.Links$TryNextContentBased.calculateNext()
        <-- am.englet.Links$TryNextContentBased.content
        <-- am.englet.Links$TryNextContentBased.content()
        <-- am.englet.Links$ValueConverter
        <-- am.englet.Links$ValueConverter.convert(java.lang.Object)
        <-- am.englet.Links.NULL
        <-- am.englet.Links.div(am.englet.link.Link, int)
        <-- am.englet.Links.flat(am.englet.link.Link, int)
        <-- am.englet.Links.nextContentProviderBased(am.englet.Links$NextContentProvider)
        <-- am.englet.Links.nullCorrect(java.lang.Object)
        <-- am.englet.Links.static {}
        <-- am.englet.Links.toChain(java.lang.Object[])
        <-- am.englet.Lookup
        <-- am.englet.Lookup$1.result()
        <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$12
        <-- am.englet.Lookup$12.nextElement()
        <-- am.englet.Lookup$2
        <-- am.englet.Lookup$2.provide()
        <-- am.englet.Lookup$3
        <-- am.englet.Lookup$3.provide()
        <-- am.englet.Lookup$4
        <-- am.englet.Lookup$4.provide()
        <-- am.englet.Lookup$5
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$7.result()
        <-- am.englet.Lookup$8
        <-- am.englet.Lookup$8.next()
        <-- am.englet.Lookup$9.result()
        <-- am.englet.Lookup$DataProvider
        <-- am.englet.Lookup$DataProvider.provide()
        <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.firstNotNull(am.englet.Lookup$DataProvider[])
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.static {}
        <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.LoopTest$1.each(java.lang.reflect.Field)
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Main
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management
        <-- am.englet.Management$1.check(java.lang.reflect.Method)
        <-- am.englet.Management$3
        <-- am.englet.Management$3.content()
        <-- am.englet.Management$8
        <-- am.englet.Management$8.content()
        <-- am.englet.Management.IF(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        <-- am.englet.Management.atX(am.englet.DataStack, int)
        <-- am.englet.Management.atXX(am.englet.DataStack, int, int)
        <-- am.englet.Management.chain(int, am.englet.DataStack)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.drop(am.englet.DataStack)
        <-- am.englet.Management.dump(am.englet.MethodsStorage)
        <-- am.englet.Management.dup(am.englet.DataStack)
        <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
        <-- am.englet.Management.excl(am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
        <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.get(java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.if_instead(java.lang.Object, boolean, am.englet.link.Link, am.englet.CommandSource, am.englet.DataStack)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.Management.lastT(am.englet.DataStack)
        <-- am.englet.Management.lastU(am.englet.DataStack)
        <-- am.englet.Management.lastV(am.englet.DataStack)
        <-- am.englet.Management.lastW(am.englet.DataStack)
        <-- am.englet.Management.lastX(am.englet.DataStack)
        <-- am.englet.Management.lastY(am.englet.DataStack)
        <-- am.englet.Management.lastZ(am.englet.DataStack)
        <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
        <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.printstack(am.englet.DataStack)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.replacement(java.util.HashMap, java.lang.String)
        <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, java.lang.Class)
        <-- am.englet.Management.setTopQiuet(am.englet.DataStack)
        <-- am.englet.Management.start(am.englet.Englet)
        <-- am.englet.Management.start1(am.englet.CommandSource, am.englet.DataStack, am.englet.link.Link)
        <-- am.englet.Management.startObject(am.englet.DataStack, am.englet.CommandSource, java.lang.Object)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.static {}
        <-- am.englet.Management.toAdapt(int, java.lang.reflect.Method)
        <-- am.englet.Management.yOut(java.lang.Object, java.lang.Object, am.englet.DataStack)
        <-- am.englet.MethodInvokable.arrayClass(java.lang.Class)
        <-- am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
        <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.extraToString()
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodInvokableMetadata
        <-- am.englet.MethodsStorage
        <-- am.englet.MethodsStorage$1
        <-- am.englet.MethodsStorage$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.MethodsStorage$Cast.toString()
        <-- am.englet.MethodsStorage$Direct
        <-- am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
        <-- am.englet.MethodsStorage$Direct.content
        <-- am.englet.MethodsStorage$Direct.getContent()
        <-- am.englet.MethodsStorage$Direct.toString()
        <-- am.englet.MethodsStorage$Dispatcher
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage$Dispatcher.toString()
        <-- am.englet.MethodsStorage$Getter
        <-- am.englet.MethodsStorage$MethodRecord
        <-- am.englet.MethodsStorage$MethodRecord$InvokableMetadata
        <-- am.englet.MethodsStorage$MethodRecord$Type
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.MethodsStorage$MethodRecord.copy(java.lang.Class[])
        <-- am.englet.MethodsStorage$MethodRecord.createInvocableImplInstance(java.lang.Object)
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage$MethodRecord.toString()
        <-- am.englet.MethodsStorage$Training
        <-- am.englet.MethodsStorage$Training$Invocation
        <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage$Training$Invocation.clone()
        <-- am.englet.MethodsStorage$Training.data()
        <-- am.englet.MethodsStorage$Training.direct(java.lang.Object)
        <-- am.englet.MethodsStorage$Training.retain()
        <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.handleDirect(java.lang.Object, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
        <-- am.englet.MethodsStorage.toString()
        <-- am.englet.MultiplySliderImpl.restart()
        <-- am.englet.Processing
        <-- am.englet.Processing$1
        <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
        <-- am.englet.Processing$1.tryNextContent()
        <-- am.englet.Processing$2.Processing$2(java.lang.Object)
        <-- am.englet.Processing$2.get(int)
        <-- am.englet.Processing$2.set(int, java.lang.Object)
        <-- am.englet.Processing$2.size()
        <-- am.englet.Processing$2.val$arr
        <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
        <-- am.englet.Processing.as_list(am.englet.link.Link)
        <-- am.englet.Processing.as_list(byte[])
        <-- am.englet.Processing.as_list(char[])
        <-- am.englet.Processing.fromFileo(java.io.File)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
        <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
        <-- am.englet.Processing.reverse(am.englet.link.Link)
        <-- am.englet.Processing.slide(java.lang.Object[])
        <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.Processing.wrap(java.lang.Object)
        <-- am.englet.ResultHandler
        <-- am.englet.ResultHandler.handleResult(java.lang.Object)
        <-- am.englet.ResultList
        <-- am.englet.ResultList.ResultList(java.lang.Object[])
        <-- am.englet.ResultList.ResultList(java.util.List)
        <-- am.englet.ResultList.ResultList(java.util.List, int)
        <-- am.englet.ResultList.appendTo(java.util.List)
        <-- am.englet.ResultList.content
        <-- am.englet.ResultList.content()
        <-- am.englet.ServiceObject
        <-- am.englet.ServiceTokenizerFactory
        <-- am.englet.SimpleCastingContext
        <-- am.englet.SimpleCastingContext$1
        <-- am.englet.SimpleCastingContext$1.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$2
        <-- am.englet.SimpleCastingContext$2.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$3
        <-- am.englet.SimpleCastingContext$3.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$4
        <-- am.englet.SimpleCastingContext$4.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$5
        <-- am.englet.SimpleCastingContext$5.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$6
        <-- am.englet.SimpleCastingContext$6.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$7
        <-- am.englet.SimpleCastingContext$7.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$8
        <-- am.englet.SimpleCastingContext$8.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext$NumberCaster
        <-- am.englet.SimpleCastingContext$NumberCaster.cast(java.lang.Number)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SimpleCastingContext.cast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
        <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
        <-- am.englet.SimpleCastingContext.toCharSequence(java.lang.Object)
        <-- am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
        <-- am.englet.SimpleStringArrayEngletSettings
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SingletonPool
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.SingletonPool$Derivation
        <-- am.englet.SingletonPool$Derivation.toString()
        <-- am.englet.SingletonPool$util
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool.findImplementation(java.lang.Class)
        <-- am.englet.SingletonPool.getSingleton(java.lang.Class)
        <-- am.englet.SingletonPool.putSingleton(java.lang.Object)
        <-- am.englet.SingletonPool.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.TestUtils0
        <-- am.englet.TestUtils0$1
        <-- am.englet.TestUtils0$1.tryNextContent()
        <-- am.englet.TestUtils0$10
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0$11
        <-- am.englet.TestUtils0$11.tryNextContent()
        <-- am.englet.TestUtils0$12
        <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
        <-- am.englet.TestUtils0$12.content
        <-- am.englet.TestUtils0$12.content()
        <-- am.englet.TestUtils0$12.step()
        <-- am.englet.TestUtils0$2
        <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
        <-- am.englet.TestUtils0$2.tryNextContent()
        <-- am.englet.TestUtils0$3
        <-- am.englet.TestUtils0$3.convert(java.lang.Object)
        <-- am.englet.TestUtils0$4
        <-- am.englet.TestUtils0$4.convert(java.lang.Object)
        <-- am.englet.TestUtils0$5
        <-- am.englet.TestUtils0$5.convert(java.lang.Object)
        <-- am.englet.TestUtils0$6
        <-- am.englet.TestUtils0$6.check(java.lang.Object)
        <-- am.englet.TestUtils0$7
        <-- am.englet.TestUtils0$7.check(java.lang.Object)
        <-- am.englet.TestUtils0$8
        <-- am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0$8.tryNextContent()
        <-- am.englet.TestUtils0$8.val$each
        <-- am.englet.TestUtils0$9
        <-- am.englet.TestUtils0$9.tryNextContent()
        <-- am.englet.TestUtils0$FS1
        <-- am.englet.TestUtils0$FS1.content
        <-- am.englet.TestUtils0$FS1.content()
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.BOOLEAN(java.lang.Object)
        <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        <-- am.englet.TestUtils0.direct(java.lang.Object)
        <-- am.englet.TestUtils0.directPlus(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.dp(java.lang.Object, int, java.util.List)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.lang.String, java.util.Map)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.Collection)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.TestUtils0.equals(java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.gt(java.lang.Comparable, java.lang.Comparable)
        <-- am.englet.TestUtils0.gt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.head(am.englet.link.Link)
        <-- am.englet.TestUtils0.iif(boolean, java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.iif(java.lang.Object, boolean, java.lang.Object)
        <-- am.englet.TestUtils0.isLink(java.lang.Object)
        <-- am.englet.TestUtils0.lt(am.englet.link.Link)
        <-- am.englet.TestUtils0.lt(java.lang.Comparable, java.lang.Comparable)
        <-- am.englet.TestUtils0.lt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.minus(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.minus(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.or(java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.plus(java.lang.Object)
        <-- am.englet.TestUtils0.plus(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
        <-- am.englet.TestUtils0.static {}
        <-- am.englet.TestUtils0.tail(am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.Invokable, java.lang.Object)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
        <-- am.englet.TestUtils0.times(boolean, java.lang.Object)
        <-- am.englet.TestUtils0.times(java.lang.Object)
        <-- am.englet.TestUtils0.times(java.lang.Object, am.englet.link.Link)
        <-- am.englet.TestUtils0.times(java.lang.Object, boolean)
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.xor(am.englet.link.Link)
        <-- am.englet.TokenizerFactory
        <-- am.englet.TokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.Trace
        <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.direct(java.lang.Object)
        <-- am.englet.Trace.directObject(java.lang.Object)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.hash(java.lang.Object)
        <-- am.englet.Trace.hexHash(java.lang.Object[])
        <-- am.englet.Trace.objects(java.lang.Object[])
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.timeString(long)
        <-- am.englet.Trace.toString(am.englet.Invokable)
        <-- am.englet.Trace.unfound(java.lang.Object)
        <-- am.englet.Trace.unfoundString(java.lang.String)
        <-- am.englet.Utils
        <-- am.englet.Utils$1.Utils$1(java.lang.Object, java.lang.Class, java.lang.Object)
        <-- am.englet.Utils$1.result()
        <-- am.englet.Utils$1.val$key
        <-- am.englet.Utils$1.val$res1
        <-- am.englet.Utils$3
        <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$3.parameterTypes()
        <-- am.englet.Utils$3.toString()
        <-- am.englet.Utils$4
        <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.parameterTypes()
        <-- am.englet.Utils$4.toString()
        <-- am.englet.Utils$5
        <-- am.englet.Utils$5.content()
        <-- am.englet.Utils$6
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$7
        <-- am.englet.Utils$7.convert(java.lang.Object)
        <-- am.englet.Utils$8
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils$9
        <-- am.englet.Utils$9.convert(java.lang.Object)
        <-- am.englet.Utils.STACK_IS_EMPTY
        <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
        <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
        <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        <-- am.englet.Utils.atStack(java.util.List, int)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.copy(java.lang.Object[])
        <-- am.englet.Utils.correctValue(java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object[])
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.deprimitivized(java.lang.Class)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        <-- am.englet.Utils.getClipString()
        <-- am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        <-- am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.isLink(java.lang.Object)
        <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.lazy(am.englet.link.Link)
        <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
        <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
        <-- am.englet.Utils.static {}
        <-- am.englet.Utils.toBoolean(java.lang.Object)
        <-- am.englet.Utils.toCharSequence(java.lang.Object)
        <-- am.englet.Utils.toClassNameCase(java.lang.String)
        <-- am.englet.Utils.toFieldNameCase(java.lang.String)
        <-- am.englet.Utils.toStringBuffer(java.lang.Object)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.VariablesStorage
        <-- am.englet.VariablesStorage.get(java.lang.Object)
        <-- am.englet.VariablesStorage.has(java.lang.Object)
        <-- am.englet.VariablesStorage.put(java.lang.Object, java.lang.Object)
        <-- am.englet.VariablesStorage.set(java.lang.Object, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings
        <-- am.englet.YAMLBasedEngletSettings$1
        <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$2
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$Performer
        <-- am.englet.YAMLBasedEngletSettings$Performer.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$1(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.bsh.Management
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        <-- am.englet.bsh.MethodInvokable
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.bsh.MethodInvokableMetadata
        <-- am.englet.cast.AbstractCaster
        <-- am.englet.cast.CastUtils
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.Caster
        <-- am.englet.cast.Caster.cast(java.lang.Object)
        <-- am.englet.cast.CasterBank
        <-- am.englet.cast.CasterBankCasterProvider
        <-- am.englet.cast.CasterBankCasterProviderImpl
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.CasterProvider
        <-- am.englet.cast.CasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.CasterProvidersBank
        <-- am.englet.cast.CasterProvidersPool
        <-- am.englet.cast.CasterProvidersPool.add(am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ChainCaster
        <-- am.englet.cast.ChainCaster.cast(java.lang.Object)
        <-- am.englet.cast.ClassCastChainFinder
        <-- am.englet.cast.ClassPool
        <-- am.englet.cast.ClassPool$1
        <-- am.englet.cast.ClassPool$1.next()
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        <-- am.englet.cast.ClassPool.forName(java.lang.String)
        <-- am.englet.cast.ClassPool.getImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
        <-- am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.ConstructorBasedCaster.ConstructorBasedCaster(java.lang.reflect.Constructor)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.ConstructorBasedCaster.getCon()
        <-- am.englet.cast.ConstructorBasedCasterProvider
        <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ForkCaster
        <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ForkCaster.cast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.InstanceMethodBasedCaster(java.lang.reflect.Method)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.MethodBasedCaster.MethodBasedCaster(java.lang.Object)
        <-- am.englet.cast.MethodBasedCaster.method()
        <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.performer
        <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
        <-- am.englet.cast.SameObjectCasterProvider
        <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.SameObjectCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster
        <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.ToStringCaster
        <-- am.englet.cast.ToStringCaster.cast(java.lang.Object)
        <-- am.englet.ct
        <-- am.englet.dispatch.DispatcherRecord
        <-- am.englet.dispatch.Utils
        <-- am.englet.dispatch.Utils$1.result()
        <-- am.englet.dispatch.Utils$2.result()
        <-- am.englet.dispatch.Utils$3.result()
        <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
        <-- am.englet.flt
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.inputtokenizers.Act.Act(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object, java.lang.Object, am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.Act.act()
        <-- am.englet.inputtokenizers.Act.getPerformers()
        <-- am.englet.inputtokenizers.Act.toString()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EngletParserReaderToTokenizerAdapter(java.io.Reader)
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getBack()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.metadata()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.tryToFillBuffer()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.perform(am.englet.inputtokenizers.ReaderToTokenizerAdapter)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.val$object
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$Performer
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.isList(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(am.englet.inputtokenizers.ReaderTokenizerEngine$Performer[])
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.newAct(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.String)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
        <-- am.englet.inputtokenizers.custom.CharToEventConverter
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.CustomTokenizerAdapter(java.io.Reader, am.englet.inputtokenizers.custom.CharToEventConverter, am.englet.inputtokenizers.ReaderTokenizerEngine)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.compare(java.lang.Object, java.lang.Object)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
        <-- am.englet.link.AbstractLink
        <-- am.englet.link.AdapterMetadata
        <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        <-- am.englet.link.BackAdapter
        <-- am.englet.link.BackAdapter.current()
        <-- am.englet.link.BackAdapter.getNext()
        <-- am.englet.link.BackAdapter.metadata()
        <-- am.englet.link.BackAdapter.setBack(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory
        <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        <-- am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.usageStrategyInstance(java.lang.Object)
        <-- am.englet.link.BackUsageStrategy
        <-- am.englet.link.BackUsageStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.BackedLink.content()
        <-- am.englet.link.Chain.Chain(java.lang.Object)
        <-- am.englet.link.Chain.Chain(java.lang.Object, am.englet.link.FinalLink)
        <-- am.englet.link.CompiledFinalLink.CompiledFinalLink(java.lang.Object, am.englet.link.FinalLink, long)
        <-- am.englet.link.CompiledFinalLink.toString()
        <-- am.englet.link.FactoryLink.content()
        <-- am.englet.link.FinalLink$Serializable
        <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
        <-- am.englet.link.FinalLink$Serializable.content
        <-- am.englet.link.FinalLink$Serializable.readResolve()
        <-- am.englet.link.FinalLink.FinalLink(java.lang.Object)
        <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.FinalLink)
        <-- am.englet.link.FinalLink.FinalLink(java.lang.Object, am.englet.link.Link)
        <-- am.englet.link.FinalLink.content
        <-- am.englet.link.FinalLink.content()
        <-- am.englet.link.FinalLink.contentString()
        <-- am.englet.link.FinalLink.prepend(java.lang.Object)
        <-- am.englet.link.FinalLink.toString()
        <-- am.englet.link.FinalLink.writeReplace()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.current()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.getNext()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.hasNext()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.tryNext()
        <-- am.englet.link.LazyLink
        <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider)
        <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
        <-- am.englet.link.LazyLink.content
        <-- am.englet.link.LazyLink.content()
        <-- am.englet.link.Link
        <-- am.englet.link.Link$Serializable
        <-- am.englet.link.Link.content()
        <-- am.englet.link.LinkFactory
        <-- am.englet.link.LinkFactory.meta()
        <-- am.englet.link.LinkUtils
        <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
        <-- am.englet.link.NextItemProvider
        <-- am.englet.link.NextItemProvider.content()
        <-- am.englet.link.SimpleLinkFactory
        <-- am.englet.link.SimpleLinkFactory.meta()
        <-- am.englet.link.SliderLink.content()
        <-- am.englet.link.Storage
        <-- am.englet.link.Storage$Nothing.get(int)
        <-- am.englet.link.Storage.restore()
        <-- am.englet.link.Storage.store(java.lang.Object)
        <-- am.englet.link.StorageImpl
        <-- am.englet.link.StorageImpl.StorageImpl()
        <-- am.englet.link.StorageImpl.object
        <-- am.englet.link.StorageImpl.restore()
        <-- am.englet.link.StorageImpl.store(java.lang.Object)
        <-- am.englet.link.TrivialBaseBackAdapterImpl
        <-- am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
        <-- am.englet.link.TrivialBaseBackAdapterImpl.back
        <-- am.englet.link.TrivialBaseBackAdapterImpl.current()
        <-- am.englet.link.TrivialBaseBackAdapterImpl.getNext()
        <-- am.englet.link.TrivialBaseBackAdapterImpl.metadata()
        <-- am.englet.link.TrivialBaseBackAdapterImpl.setBack(java.lang.Object)
        <-- am.englet.link.backadapters.CurrentOnceStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.CurrentlessStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.EnhancedResultSetStrategy.getCurrent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.IteratorAdapter.IteratorAdapter(java.util.Iterator)
        <-- am.englet.link.backadapters.IteratorAdapter.getBack()
        <-- am.englet.link.backadapters.IteratorAdapter.getNext()
        <-- am.englet.link.backadapters.IteratorAdapter.metadata()
        <-- am.englet.link.backadapters.LineReaderAdapter.LineReaderAdapter(java.io.BufferedReader)
        <-- am.englet.link.backadapters.LineReaderAdapter.getBack()
        <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
        <-- am.englet.link.backadapters.LineReaderAdapter.metadata()
        <-- am.englet.link.backadapters.LineReaderStrategy.postCheckNext(am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy
        <-- am.englet.link.backadapters.StorageNeedingStrategy.getContent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StorageNeedingStrategy.tryNext(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.StoragelessStrategy
        <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter)
        <-- am.englet.link.backadapters.StoragelessStrategy.getCurrent(am.englet.link.BackAdapter, am.englet.link.Storage)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider
        <-- am.englet.link.backadapters.slider.AppendableCallStackSlider.content()
        <-- am.englet.link.backadapters.slider.AppendableSlider
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.content0()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.first()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
        <-- am.englet.link.backadapters.slider.CallStackSlider
        <-- am.englet.link.backadapters.slider.CallStacklLevelSlider
        <-- am.englet.link.backadapters.slider.ChainLink.at(int)
        <-- am.englet.link.backadapters.slider.ChainLink.content()
        <-- am.englet.link.backadapters.slider.ChainLink.next()
        <-- am.englet.link.backadapters.slider.ChainLink.peek()
        <-- am.englet.link.backadapters.slider.ChainLink.push(am.englet.link.SliderLink)
        <-- am.englet.link.backadapters.slider.ConcatSlider
        <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.ConcatSlider.content()
        <-- am.englet.link.backadapters.slider.ConcatSlider.currentContent
        <-- am.englet.link.backadapters.slider.ConcatSlider.tryNext()
        <-- am.englet.link.backadapters.slider.FilterSlider
        <-- am.englet.link.backadapters.slider.FilterSlider.content
        <-- am.englet.link.backadapters.slider.FilterSlider.content()
        <-- am.englet.link.backadapters.slider.FilterSlider.tryNext()
        <-- am.englet.link.backadapters.slider.HeadSlider
        <-- am.englet.link.backadapters.slider.HeadSlider.content()
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content
        <-- am.englet.link.backadapters.slider.InvocableBasedSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSlider
        <-- am.englet.link.backadapters.slider.LinkSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSlider.go(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.LinkSliderAdapter(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.current()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.getSlider()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.metadata()
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider
        <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.content()
        <-- am.englet.link.backadapters.slider.SingletonSlider
        <-- am.englet.link.backadapters.slider.SingletonSlider.SingletonSlider(java.lang.Object)
        <-- am.englet.link.backadapters.slider.SingletonSlider.content
        <-- am.englet.link.backadapters.slider.SingletonSlider.content()
        <-- am.englet.link.backadapters.slider.Slider
        <-- am.englet.link.backadapters.slider.Slider.content()
        <-- am.englet.link.backadapters.slider.UniqunessChecker
        <-- am.englet.link.backadapters.slider.UniqunessChecker.check(java.lang.Object)
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.data
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.content()
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.args
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        <-- am.englet.reflect.MemberInvokable
        <-- am.englet.reflect.MemberInvokable.deprimitivise(java.lang.Class[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.parameterTypes()
        <-- am.englet.reflect.MemberInvokable.toString()
        <-- am.englet.reflect.MemberInvokable.writeReplace()
        <-- am.englet.reflect.SimpleGetter
        <-- am.englet.reflect.SimpleGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable)
        <-- am.englet.reflect.SimpleInvokableGetter.SimpleInvokableGetter(am.englet.Invokable, java.lang.Object[])
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable)
        <-- am.englet.reflect.SimpleInvokableSetter.SimpleInvokableSetter(am.englet.Invokable, java.lang.Object[], int)
        <-- am.englet.reflect.SimpleProperty
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.toString()
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        <-- am.englet.reflect.SimpleSetter
        <-- am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.Utils
        <-- am.englet.reflect.Utils$1
        <-- am.englet.reflect.Utils$1.DO(java.lang.Object)
        <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.stateengine.Act
        <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.act()
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object[], java.lang.Object[], java.lang.Object)
        <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.event
        <-- am.englet.stateengine.Act.event()
        <-- am.englet.stateengine.Act.result
        <-- am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
        <-- am.englet.stateengine.Act.s(java.lang.String)
        <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
        <-- am.englet.stateengine.Act.state
        <-- am.englet.stateengine.Act.state()
        <-- am.englet.stateengine.Act.toString()
        <-- am.englet.stateengine.Action
        <-- am.englet.stateengine.Action.act()
        <-- am.englet.stateengine.Action.event()
        <-- am.englet.stateengine.Action.state()
        <-- am.englet.stateengine.Engine
        <-- am.englet.stateengine.Engine$1.Engine$1(java.lang.Object)
        <-- am.englet.stateengine.Engine$2.Engine$2(java.lang.Object)
        <-- am.englet.stateengine.Engine$3.Engine$3(java.lang.Object)
        <-- am.englet.stateengine.Engine.ALL
        <-- am.englet.stateengine.Engine.DEFAULT
        <-- am.englet.stateengine.Engine.Engine()
        <-- am.englet.stateengine.Engine.FINISHED
        <-- am.englet.stateengine.Engine.act(java.lang.Object)
        <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
        <-- am.englet.stateengine.Engine.finished()
        <-- am.englet.stateengine.Engine.getState()
        <-- am.englet.stateengine.Engine.init(java.lang.Object)
        <-- am.englet.stateengine.Engine.intern(java.lang.Object)
        <-- am.englet.stateengine.Engine.is(java.lang.Object)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        <-- am.englet.stateengine.Engine.reportIllegalState(java.lang.Object)
        <-- am.englet.stateengine.Engine.state
        <-- am.englet.stateengine.Engine.static {}
        <-- am.englet.try1
        <-- am.englet.try1$try2
        <-- am.englet.try1$try2.clone()
        <-- am.englet.try1.clone()
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.try2
        <-- am.englet.try2$A
        <-- am.englet.try2$A.p()
        <-- am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
        <-- am.englet.util.AbstractListSingleton.content
        <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
        <-- am.englet.util.AbstractListSingleton.get(int)
        <-- am.englet.util.Buffer
        <-- am.englet.util.Checker
        <-- am.englet.util.Checker.check(java.lang.Object)
        <-- am.englet.util.MapPath
        <-- am.englet.util.MapPath.from(java.lang.Object)
        <-- am.englet.util.MapPath.listFrom(java.lang.Object)
        <-- am.englet.util.MapPath.mapFrom(java.lang.Object)
        <-- am.englet.wiring.BeanPool
        <-- am.englet.wiring.BeanPool.get(java.lang.String)
        <-- am.englet.wiring.BeanPool.has(java.lang.String)
        <-- am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
        <-- am.englet.wiring.Builder
        <-- am.englet.wiring.Builder.build(java.lang.Object)
        <-- am.englet.wiring.BuilderImpl
        <-- am.englet.wiring.BuilderImpl$1.BuilderImpl$1(am.englet.wiring.BuilderImpl, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.BuilderImpl$1.val$obj
        <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
        <-- am.englet.wiring.Factory
        <-- am.englet.wiring.Factory.instance(java.lang.Class)
        <-- am.englet.wiring.Factory.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FactoryPoolImpl
        <-- am.englet.wiring.FactoryPoolImpl$1
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
        <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
        <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class, java.lang.Object[])
        <-- am.englet.wiring.FieldBuilder
        <-- am.englet.wiring.FieldBuilder.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.NameResolver
        <-- am.englet.wiring.ObjectProvider
        <-- am.englet.wiring.ObjectProvider$Context
        <-- am.englet.wiring.ObjectProvider.provide(java.lang.Class, am.englet.wiring.ObjectProvider$Context)
        <-- am.englet.wiring.PoolsBuilder
        <-- am.englet.wiring.PoolsBuilder$1
        <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$2
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.instance(java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$3.PoolsBuilder$3(am.englet.wiring.PoolsBuilder$1, java.lang.Class, java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$3.val$obj
        <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord
        <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.object
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.unstring(java.lang.Object, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder.wire()
        <-- am.englet.wiring.PropertiesBasedNameResolver
        <-- am.englet.wiring.SpecialFactory
        <-- am.englet.wiring.Utils
        <-- t
        <-- t1
        Object() *
            <-- am.beans.reflect.ClassInfo.ClassInfo()
            <-- am.beans.reflect.ClassMap$v.ClassMap$v()
            <-- am.beans.reflect.Destringer.Destringer()
            <-- am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
            <-- am.beans.reflect.MethodCallerBasedGetter.MethodCallerBasedGetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller)
            <-- am.beans.reflect.MethodCallerBasedSetter.MethodCallerBasedSetter(am.beans.reflect.MethodCaller, int)
            <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
            <-- am.beans.reflect.Utils.Utils()
            <-- am.englet.$$3.$$3()
            <-- am.englet.$$4.$$4()
            <-- am.englet.$$7.$$7()
            <-- am.englet.$$First$Performer.$$First$Performer()
            <-- am.englet.$$Performer.$$Performer()
            <-- am.englet.$Base.$Base()
            <-- am.englet.CallStackSliderImpl.CallStackSliderImpl()
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.CodeBlock.CodeBlock()
            <-- am.englet.CompoundInvokable$1.CompoundInvokable$1(am.englet.CompoundInvokable$InvokableWrapper)
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.CompoundInvokable$ArgArrayArgSource(int)
            <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            <-- am.englet.CompoundInvokable$DirectArgSource.CompoundInvokable$DirectArgSource(am.englet.MethodsStorage$Direct)
            <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            <-- am.englet.CompoundInvokable$InvokableWrapper.CompoundInvokable$InvokableWrapper(am.englet.Invokable, am.englet.CompoundInvokable$ArgumentSource[], java.lang.Integer, int, am.englet.CastingContext)
            <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.CompoundInvokable$InvokableWrapperArgSource(am.englet.CompoundInvokable$InvokableWrapper)
            <-- am.englet.CompoundInvokable.CompoundInvokable()
            <-- am.englet.ConditionalValueConverter.ConditionalValueConverter(am.englet.Invokable, am.englet.Invokable)
            <-- am.englet.Const$1.Const$1()
            <-- am.englet.Const.Const()
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.Englet$1.Englet$1(am.englet.Englet, java.lang.Object[], java.lang.Object)
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.EngletBasedChecker.EngletBasedChecker(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletBasedValueConverter.EngletBasedValueConverter(am.englet.Englet, am.englet.link.Link)
            <-- am.englet.EngletParserReaderTokenizerFactory.EngletParserReaderTokenizerFactory()
            <-- am.englet.Immediate.Immediate()
            <-- am.englet.Invokable$1.Invokable$1()
            <-- am.englet.InvokableBasedValueConverter.InvokableBasedValueConverter(am.englet.Invokable)
            <-- am.englet.InvokableDescription$PreparationContext$Counter.InvokableDescription$PreparationContext$Counter()
            <-- am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
            <-- am.englet.InvokableDescription.InvokableDescription(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.InvokableSerializer$3.InvokableSerializer$3(am.englet.InvokableSerializer$2)
            <-- am.englet.InvokableSerializer$4.InvokableSerializer$4(am.englet.InvokableSerializer$2)
            <-- am.englet.InvokableSerializer$5.InvokableSerializer$5(am.englet.InvokableSerializer$2)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.InvokableSerializer$SerializeInvokableDescription()
            <-- am.englet.InvokableSerializer.InvokableSerializer()
            <-- am.englet.Links$1.Links$1()
            <-- am.englet.Links$2.Links$2(am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.Links$3.Links$3(am.englet.link.Link, java.lang.Object[])
            <-- am.englet.Links$4.Links$4(am.englet.link.Link, am.englet.util.Checker)
            <-- am.englet.Links$5.Links$5(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$6.Links$6(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$7.Links$7(am.englet.link.Link, am.englet.Links$ValueConverter)
            <-- am.englet.Links$8.Links$8(java.util.Stack, int)
            <-- am.englet.Links$9.Links$9(java.lang.String[])
            <-- am.englet.Links$Calculate_Next_Based.Links$Calculate_Next_Based()
            <-- am.englet.Links.Links()
            <-- am.englet.Links.static {}
            <-- am.englet.Lookup$12.Lookup$12(am.englet.Lookup$DataProvider[])
            <-- am.englet.Lookup$2.Lookup$2(java.lang.String)
            <-- am.englet.Lookup$3.Lookup$3(java.lang.String)
            <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.Lookup$5.Lookup$5(am.englet.Lookup$DataProvider[], java.lang.Class, boolean, boolean, java.lang.Class)
            <-- am.englet.Lookup$8.Lookup$8(java.lang.Class)
            <-- am.englet.Lookup.Lookup()
            <-- am.englet.Main.Main()
            <-- am.englet.Management$3.Management$3(am.englet.link.Link)
            <-- am.englet.Management$8.Management$8(am.englet.CommandSource, am.englet.link.Link)
            <-- am.englet.Management.Management()
            <-- am.englet.MethodInvokableMetadata.MethodInvokableMetadata(java.lang.reflect.Method)
            <-- am.englet.MethodsStorage$1.MethodsStorage$1(am.englet.MethodsStorage$Dispatcher)
            <-- am.englet.MethodsStorage$Direct.MethodsStorage$Direct(java.lang.Object)
            <-- am.englet.MethodsStorage$Dispatcher.MethodsStorage$Dispatcher()
            <-- am.englet.MethodsStorage$Getter.MethodsStorage$Getter(java.lang.String)
            <-- am.englet.MethodsStorage$MethodRecord$Type.MethodsStorage$MethodRecord$Type()
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.MethodsStorage$Training.MethodsStorage$Training()
            <-- am.englet.MethodsStorage.MethodsStorage()
            <-- am.englet.Processing$1.Processing$1(am.englet.link.Link)
            <-- am.englet.Processing.Processing()
            <-- am.englet.ResultList.ResultList(java.lang.Object[])
            <-- am.englet.ResultList.ResultList(java.util.List)
            <-- am.englet.ResultList.ResultList(java.util.List, int)
            <-- am.englet.SimpleCastingContext$1.SimpleCastingContext$1()
            <-- am.englet.SimpleCastingContext$2.SimpleCastingContext$2()
            <-- am.englet.SimpleCastingContext$3.SimpleCastingContext$3()
            <-- am.englet.SimpleCastingContext$4.SimpleCastingContext$4()
            <-- am.englet.SimpleCastingContext$5.SimpleCastingContext$5()
            <-- am.englet.SimpleCastingContext$6.SimpleCastingContext$6()
            <-- am.englet.SimpleCastingContext$7.SimpleCastingContext$7()
            <-- am.englet.SimpleCastingContext$8.SimpleCastingContext$8()
            <-- am.englet.SimpleCastingContext.SimpleCastingContext()
            <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
            <-- am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
            <-- am.englet.SingletonPool$util.SingletonPool$util()
            <-- am.englet.TestUtils0$1.TestUtils0$1(int, int)
            <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
            <-- am.englet.TestUtils0$11.TestUtils0$11(java.util.regex.Matcher)
            <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
            <-- am.englet.TestUtils0$2.TestUtils0$2(am.englet.link.Link, am.englet.link.Chain)
            <-- am.englet.TestUtils0$3.TestUtils0$3()
            <-- am.englet.TestUtils0$4.TestUtils0$4(am.englet.Invokable)
            <-- am.englet.TestUtils0$5.TestUtils0$5(am.englet.Invokable)
            <-- am.englet.TestUtils0$6.TestUtils0$6(am.englet.Invokable)
            <-- am.englet.TestUtils0$7.TestUtils0$7(am.englet.Invokable)
            <-- am.englet.TestUtils0$8.TestUtils0$8(am.englet.Invokable, java.lang.Object)
            <-- am.englet.TestUtils0$9.TestUtils0$9(java.io.BufferedReader)
            <-- am.englet.TestUtils0$FS1.TestUtils0$FS1(am.englet.link.backadapters.slider.Slider, am.englet.Links$ValueConverter)
            <-- am.englet.TestUtils0.TestUtils0()
            <-- am.englet.Trace.Trace()
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$7.Utils$7(am.englet.DataStack)
            <-- am.englet.Utils$8.Utils$8(am.englet.DataStack)
            <-- am.englet.Utils$9.Utils$9(java.util.Map)
            <-- am.englet.Utils.Utils()
            <-- am.englet.Utils.static {}
            <-- am.englet.YAMLBasedEngletSettings$1.YAMLBasedEngletSettings$1(am.englet.YAMLBasedEngletSettings)
            <-- am.englet.YAMLBasedEngletSettings$2.YAMLBasedEngletSettings$2(am.englet.YAMLBasedEngletSettings)
            <-- am.englet.YAMLBasedEngletSettings.YAMLBasedEngletSettings()
            <-- am.englet.bsh.Management.Management()
            <-- am.englet.bsh.MethodInvokable.MethodInvokable(bsh.BshMethod)
            <-- am.englet.bsh.MethodInvokableMetadata.MethodInvokableMetadata(bsh.BshMethod)
            <-- am.englet.cast.AbstractCaster.AbstractCaster()
            <-- am.englet.cast.AbstractCaster.AbstractCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CastUtils.CastUtils()
            <-- am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            <-- am.englet.cast.CasterProvidersPool.CasterProvidersPool()
            <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ConstructorBasedCasterProvider.ConstructorBasedCasterProvider()
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.SameObjectCasterProvider.SameObjectCasterProvider()
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.StaticFactoryMethodBasedCasterProvider()
            <-- am.englet.cast.StringToClassCaster.StringToClassCaster()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.TargetToSourseClassCastChainFinder()
            <-- am.englet.cast.ToStringCaster.ToStringCaster()
            <-- am.englet.ct.ct()
            <-- am.englet.dispatch.Utils.Utils()
            <-- am.englet.flt.flt()
            <-- am.englet.inputtokenizers.BackAdapterBasedIterator.BackAdapterBasedIterator(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.ReaderTokenizerEngine$1(am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.ReaderTokenizerEngine$2(am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.ReaderTokenizerEngine$3(am.englet.inputtokenizers.ReaderTokenizerEngine)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.ReaderTokenizerEngine$4(am.englet.inputtokenizers.ReaderTokenizerEngine, java.lang.Object)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.ArrayBasedCharToEventConverterImpl(java.lang.String)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1.RangesBasedCharToEventConverterImpl$1()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2.RangesBasedCharToEventConverterImpl$2()
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
            <-- am.englet.link.AbstractLink.AbstractLink()
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            <-- am.englet.link.BackAdapterFactory.BackAdapterFactory()
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable()
            <-- am.englet.link.FinalLink$Serializable.FinalLink$Serializable(am.englet.link.FinalLink)
            <-- am.englet.link.LazyLink.LazyLink(am.englet.link.NextItemProvider, java.lang.Object)
            <-- am.englet.link.LinkUtils.LinkUtils()
            <-- am.englet.link.NextItemProvider.NextItemProvider(am.englet.link.BackUsageStrategy, am.englet.link.BackAdapter)
            <-- am.englet.link.SimpleLinkFactory.SimpleLinkFactory(am.englet.link.BackAdapter, am.englet.link.BackUsageStrategy)
            <-- am.englet.link.StorageImpl.StorageImpl()
            <-- am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl()
            <-- am.englet.link.TrivialBaseBackAdapterImpl.TrivialBaseBackAdapterImpl(java.lang.Object)
            <-- am.englet.link.backadapters.StorageNeedingStrategy.StorageNeedingStrategy()
            <-- am.englet.link.backadapters.StoragelessStrategy.StoragelessStrategy()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.ConcatSlider.ConcatSlider(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.FilterSlider.FilterSlider(am.englet.link.backadapters.slider.Slider, am.englet.util.Checker)
            <-- am.englet.link.backadapters.slider.HeadSlider.HeadSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            <-- am.englet.link.backadapters.slider.LinkSlider.LinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.OptionallyEntailingSlider.OptionallyEntailingSlider(am.englet.link.backadapters.slider.Slider, am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.SingletonSlider.SingletonSlider(java.lang.Object)
            <-- am.englet.link.backadapters.slider.UniqunessChecker.UniqunessChecker()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.BaseSimpleResultSetSlider$RecordSlider(am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.AbstractSimpleInvokablePerformer(am.englet.Invokable, java.lang.Object[])
            <-- am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
            <-- am.englet.reflect.SimpleProperty.SimpleProperty(am.englet.reflect.SimpleGetter, am.englet.reflect.SimpleSetter)
            <-- am.englet.reflect.Utils$1.Utils$1(java.lang.Class)
            <-- am.englet.reflect.Utils.Utils()
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.Act(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.Engine()
            <-- am.englet.try1$try2.try1$try2(am.englet.try1)
            <-- am.englet.try1.try1()
            <-- am.englet.try2$A.try2$A()
            <-- am.englet.try2.try2()
            <-- am.englet.util.Buffer.Buffer(int)
            <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
            <-- am.englet.util.MapPath.MapPath(java.lang.String, char)
            <-- am.englet.wiring.BeanPool.BeanPool()
            <-- am.englet.wiring.BuilderImpl.BuilderImpl()
            <-- am.englet.wiring.FactoryPoolImpl$1.FactoryPoolImpl$1(am.englet.wiring.FactoryPoolImpl)
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.FieldBuilderImpl.FieldBuilderImpl(am.englet.wiring.Builder, am.englet.wiring.Factory, am.englet.wiring.NameResolver)
            <-- am.englet.wiring.PoolsBuilder$1.PoolsBuilder$1(am.englet.wiring.PoolsBuilder)
            <-- am.englet.wiring.PoolsBuilder$2.PoolsBuilder$2(am.englet.wiring.PoolsBuilder$1)
            <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver(java.util.Properties)
            <-- am.englet.wiring.Utils.Utils()
            <-- t.t()
            <-- t1.t1()
        clone() *
            <-- am.englet.MethodsStorage$Training$Invocation.clone()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.clone()
            <-- am.englet.stateengine.Act.clone(java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.try1$try2.clone()
            <-- am.englet.try1.clone()
        equals(java.lang.Object) *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            <-- am.englet.$$6.check(java.lang.reflect.Method)
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$.paramTypesCompare(java.lang.Class[], java.lang.Class[])
            <-- am.englet.$.paramTypesEqual(java.lang.Class[], java.lang.Class[])
            <-- am.englet.CompoundInvokable$1.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Management.IFeq(am.englet.DataStack, am.englet.CommandSource)
            <-- am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.TestUtils0.equals(java.lang.Object, java.lang.Object)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.StorageImpl.restore()
            <-- am.englet.link.backadapters.slider.InvocableBasedSlider.InvocableBasedSlider(am.englet.link.backadapters.slider.Slider, am.englet.Invokable)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.is(java.lang.Object)
            <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
        getClass() *
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            <-- am.englet.CastingContextImpl1.cast(java.lang.Class, java.lang.Object)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.putSingleton(java.lang.Object)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
            <-- am.englet.MethodInvokable.arrayClass(java.lang.Class)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.objects(java.lang.Object[])
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.copy(java.lang.Object[])
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            <-- am.englet.link.BackAdapterFactory.adapterInstance(java.lang.Object)
            <-- am.englet.link.BackAdapterFactory.usageStrategyInstance(java.lang.Object)
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.try1.main(java.lang.String[])
            <-- am.englet.try2$A.p()
            <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.BuilderImpl.build(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$1.build(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        hashCode() *
            <-- am.englet.Invokable$1.toString()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
        toString() *
            <-- am.beans.reflect.Destringer.toString()
            <-- am.englet.CodeBlock.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.Immediate.popContent(am.englet.DataStack)
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Management$3.toString()
            <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Management.replacement(java.util.HashMap, java.lang.String)
            <-- am.englet.MethodsStorage$Dispatcher.toString()
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.toCharSequence(java.lang.Object)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.Trace.toString(am.englet.Invokable)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.getClipString()
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Utils.toBoolean(java.lang.Object)
            <-- am.englet.Utils.toCharSequence(java.lang.Object)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.dispatch.Utils$3.result()
            <-- am.englet.link.FinalLink.contentString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
    Object[] *
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Trace.objects(java.lang.Object[])
        <-- am.englet.Utils.copy(java.lang.Object[])
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
    Package *
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        getName() *
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
    RuntimeException *
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.MethodsStorage$CommandNotFoundException
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.cast.CastException
        RuntimeException() *
            <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException()
            <-- am.englet.cast.CastException.CastException()
        RuntimeException(java.lang.String) *
            <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String)
            <-- am.englet.cast.CastException.CastException(java.lang.String)
        RuntimeException(java.lang.String, java.lang.Throwable) *
            <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String, java.lang.Throwable)
            <-- am.englet.cast.CastException.CastException(java.lang.String, java.lang.Throwable)
        RuntimeException(java.lang.Throwable) *
            <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
            <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.Throwable)
            <-- am.englet.cast.CastException.CastException(java.lang.Throwable)
            <-- am.englet.link.FinalLink$Serializable.readResolve()
    SecurityException *
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
        <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        printStackTrace() *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
    Short *
        Short(short) *
            <-- am.englet.SimpleCastingContext$4.cast(java.lang.Number)
        TYPE *
            <-- am.englet.$.static {}
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.Utils.static {}
            <-- am.englet.cast.ClassPool.ClassPool()
    String *
        <-- am.beans.reflect.ClassMap.ClassMap()
        <-- am.beans.reflect.ClassMap.forName(java.lang.String)
        <-- am.beans.reflect.ClassMap.get(java.lang.String)
        <-- am.beans.reflect.ClassMap.importClassName(java.lang.String)
        <-- am.beans.reflect.ClassMap.importClassName(java.lang.String, java.lang.String)
        <-- am.beans.reflect.Destringer$1.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.description()
        <-- am.beans.reflect.Destringer.dump()
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.Destringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.Destringer.static {}
        <-- am.beans.reflect.Destringer.toString()
        <-- am.beans.reflect.Property.Property(java.lang.String, java.lang.Class, java.lang.Class, am.beans.reflect.Getter, am.beans.reflect.Setter)
        <-- am.beans.reflect.Property.name
        <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
        <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
        <-- am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$5.$$5()
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.nameFits(java.lang.String[], java.lang.String)
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.check(java.lang.reflect.Constructor)
        <-- am.englet.$.check(java.lang.reflect.Field)
        <-- am.englet.$.check(java.lang.reflect.Method)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
        <-- am.englet.$.static {}
        <-- am.englet.$Base.$(int, int)
        <-- am.englet.$Base.$(int, int, java.lang.Class[])
        <-- am.englet.$Base.$(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object)
        <-- am.englet.$Base.$(java.lang.Object, int, int)
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, int, int, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.$(java.lang.Object, java.lang.String[])
        <-- am.englet.$Base.$(java.lang.String[])
        <-- am.englet.$Base.field(int, int, java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(int, int, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.String[])
        <-- am.englet.$Base.method(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(int, int, java.lang.String[])
        <-- am.englet.$Base.method(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(java.lang.String[])
        <-- am.englet.CastingContextImpl1.CastingContextImpl1()
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CodeBlock.toString()
        <-- am.englet.CommandSource.toString()
        <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
        <-- am.englet.CompoundInvokable$DirectArgSource.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.toString()
        <-- am.englet.CompoundInvokable.toString()
        <-- am.englet.ConstructorInvokable.name(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.type()
        <-- am.englet.DataStack$StackFrame.toString()
        <-- am.englet.DataStack.mustNotHave(java.lang.Object)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.pop()
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.DataStack.toString()
        <-- am.englet.Englet$1.toString()
        <-- am.englet.Englet.Englet()
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.getCastingContext()
        <-- am.englet.Englet.getMethods()
        <-- am.englet.Englet.getParserFactory()
        <-- am.englet.Englet.getRstack()
        <-- am.englet.Englet.getStack()
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Englet.parse(java.lang.String)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
        <-- am.englet.Englet.static {}
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.FieldGetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.type()
        <-- am.englet.FieldSetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.type()
        <-- am.englet.Immediate.METHOD_NAME_REPLACEMENTS
        <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.doublev(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.floatv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.integer(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.longv(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Immediate.popContent(am.englet.DataStack)
        <-- am.englet.Invokable$1.returnType()
        <-- am.englet.Invokable$1.toString()
        <-- am.englet.InvokableDescription.toString()
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$0(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.access$1(am.englet.InvokableSerializer$SerializeInvokableDescription, java.lang.String)
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.name
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.type
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.InvokableSerializer.describe(java.lang.String, java.lang.String, am.englet.reflect.MemberInvokable)
        <-- am.englet.Links$9.Links$9(java.lang.String[])
        <-- am.englet.Links$9.tryNextContent()
        <-- am.englet.Links$9.val$buv
        <-- am.englet.Links.toLazyChain(java.lang.String[])
        <-- am.englet.Lookup$1.Lookup$1(java.lang.Class, java.lang.String, java.lang.Class[], int, int)
        <-- am.englet.Lookup$1.result()
        <-- am.englet.Lookup$1.val$name
        <-- am.englet.Lookup$10.Lookup$10(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$10.val$command
        <-- am.englet.Lookup$2.Lookup$2(java.lang.String)
        <-- am.englet.Lookup$2.provide()
        <-- am.englet.Lookup$2.val$name
        <-- am.englet.Lookup$3.Lookup$3(java.lang.String)
        <-- am.englet.Lookup$3.provide()
        <-- am.englet.Lookup$3.val$command
        <-- am.englet.Lookup$4.Lookup$4(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup$4.provide()
        <-- am.englet.Lookup$4.val$name
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup$6.Lookup$6(java.lang.Class, java.lang.String, int, java.lang.Class[])
        <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$6.val$command
        <-- am.englet.Lookup$7.Lookup$7(java.lang.String, java.lang.Class[], int)
        <-- am.englet.Lookup$7.result()
        <-- am.englet.Lookup$7.val$underscoredToMemberName
        <-- am.englet.Lookup$8.base()
        <-- am.englet.Lookup$9.Lookup$9(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$9.result()
        <-- am.englet.Lookup$9.val$name
        <-- am.englet.Lookup.CR
        <-- am.englet.Lookup.access$0()
        <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
        <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
        <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
        <-- am.englet.Lookup.fitsClassName(java.lang.Class, boolean, java.lang.String)
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpCollections(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String)
        <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod2(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpNonStaticMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpSetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
        <-- am.englet.Lookup.static {}
        <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
        <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
        <-- am.englet.Lookup.underscoredToClassName(java.lang.String)
        <-- am.englet.Lookup.underscoredToMemberName(java.lang.String)
        <-- am.englet.LoopTest$2.check(java.lang.reflect.Method)
        <-- am.englet.LoopTest$3.check(java.lang.reflect.Method)
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management$1.Management$1(java.lang.Class, java.lang.String)
        <-- am.englet.Management$1.check(java.lang.reflect.Method)
        <-- am.englet.Management$1.val$mtdName
        <-- am.englet.Management$2.each(java.lang.reflect.Method)
        <-- am.englet.Management$3.toString()
        <-- am.englet.Management$4.Management$4(java.lang.Class, java.lang.String)
        <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
        <-- am.englet.Management$4.val$mask
        <-- am.englet.Management$5.Management$5(java.lang.Class, java.lang.String)
        <-- am.englet.Management$5.check(java.lang.reflect.Field)
        <-- am.englet.Management$5.val$mask
        <-- am.englet.Management$6.Management$6(java.lang.Class, java.lang.String)
        <-- am.englet.Management$6.check(java.lang.reflect.Field)
        <-- am.englet.Management$6.val$mask
        <-- am.englet.Management$7.Management$7(java.lang.Class, java.lang.String)
        <-- am.englet.Management$7.check(java.lang.reflect.Method)
        <-- am.englet.Management$7.val$mask
        <-- am.englet.Management.METHOD_NAME_REPLACEMENTS
        <-- am.englet.Management.access$1(java.util.HashMap, java.lang.String)
        <-- am.englet.Management.access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adapt_immediate_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Management.adapt_management_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
        <-- am.englet.Management.adapt_processing_class(java.lang.String, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Management.as(java.lang.Object, java.lang.Object, am.englet.cast.ClassPool, am.englet.CastingContext)
        <-- am.englet.Management.asClass(am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.do_adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
        <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.get(java.lang.String, am.englet.VariablesStorage)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.impl(am.englet.VariablesStorage, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.import_package(am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.invokable(am.englet.DataStack, java.lang.Object, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.Management.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.ServiceTokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.printstack(am.englet.DataStack)
        <-- am.englet.Management.processor(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.processor0(am.englet.MethodsStorage, am.englet.ArgumentProvider, java.lang.String, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
        <-- am.englet.Management.replacement(java.util.HashMap, java.lang.String)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.Management.service_object(am.englet.SingletonPool, am.englet.cast.ClassPool, java.lang.String)
        <-- am.englet.Management.static {}
        <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.extraToString()
        <-- am.englet.MethodInvokable.name(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.type()
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.MethodsStorage$Cast.toString()
        <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String)
        <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String, java.lang.Throwable)
        <-- am.englet.MethodsStorage$Direct.toString()
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage$Dispatcher.toString()
        <-- am.englet.MethodsStorage$Getter.MethodsStorage$Getter(java.lang.String)
        <-- am.englet.MethodsStorage$Getter.toString()
        <-- am.englet.MethodsStorage$Getter.varname
        <-- am.englet.MethodsStorage$Getter.varname()
        <-- am.englet.MethodsStorage$MethodRecord$Type.toString(int)
        <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage$MethodRecord.toString()
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.handleGetter(java.lang.Object, am.englet.ResultHandler, am.englet.VariablesStorage)
        <-- am.englet.MethodsStorage.handleNumberCandidate(java.lang.String, am.englet.ResultHandler)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.processor(java.lang.String, am.englet.ArgumentProvider)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
        <-- am.englet.MethodsStorage.toString()
        <-- am.englet.Processing.METHOD_NAME_REPLACEMENTS
        <-- am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
        <-- am.englet.Processing.appendToFile(byte[], java.lang.String)
        <-- am.englet.Processing.appendToFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.condReplace(java.lang.StringBuffer, java.lang.String, int, int)
        <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
        <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.fromClip()
        <-- am.englet.Processing.fromFile(java.lang.String)
        <-- am.englet.Processing.fromFileo(java.lang.String)
        <-- am.englet.Processing.fromUrl(java.lang.String)
        <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
        <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
        <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
        <-- am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
        <-- am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
        <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.toClip(java.lang.String)
        <-- am.englet.Processing.toFile(byte[], java.lang.String)
        <-- am.englet.Processing.toFile(byte[], java.lang.String, boolean)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String)
        <-- am.englet.Processing.toFile(java.lang.CharSequence, java.lang.String, boolean)
        <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
        <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
        <-- am.englet.Processing.toFileo(java.lang.Object, java.lang.String)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.static {}
        <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
        <-- am.englet.SimpleCastingContext.toCharSequence(java.lang.Object)
        <-- am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings()
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[])
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.util.Properties)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        <-- am.englet.SimpleStringArrayEngletSettings.args
        <-- am.englet.SimpleStringArrayEngletSettings.getPre()
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
        <-- am.englet.SimpleStringArrayEngletSettings.propsURLInput()
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.SingletonPool$Derivation.toString()
        <-- am.englet.SingletonPool$util.access$1(java.lang.String)
        <-- am.englet.SingletonPool$util.access$2(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.SingletonPool.DERIVED_FROM
        <-- am.englet.SingletonPool.SINGLETON_IMPLEMENTATIONS_PROPERTIES
        <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
        <-- am.englet.TestUtils0$12.step()
        <-- am.englet.TestUtils0$12.val$src
        <-- am.englet.TestUtils0$9.tryNextContent()
        <-- am.englet.TestUtils0$FS1.tryNext()
        <-- am.englet.TestUtils0.METHOD_NAME_REPLACEMENTS
        <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        <-- am.englet.TestUtils0.direct(java.lang.Object)
        <-- am.englet.TestUtils0.div(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.lang.String, java.util.Map)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
        <-- am.englet.TestUtils0.minus(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.static {}
        <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
        <-- am.englet.TestUtils0.times(am.englet.link.Link, java.lang.String)
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Trace.call(java.lang.String, java.lang.Object, java.lang.String, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.command(java.lang.String)
        <-- am.englet.Trace.constant(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.direct(java.lang.Object)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.fail(java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.hash(java.lang.Object)
        <-- am.englet.Trace.lastCommand
        <-- am.englet.Trace.objects(java.lang.Object[])
        <-- am.englet.Trace.open()
        <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], am.englet.Invokable)
        <-- am.englet.Trace.success(java.lang.Object, java.lang.Object, java.lang.Object[], java.lang.String, am.englet.Invokable)
        <-- am.englet.Trace.timeString(long)
        <-- am.englet.Trace.toHexString(int)
        <-- am.englet.Trace.toString(am.englet.Invokable)
        <-- am.englet.Trace.unfound(java.lang.Object)
        <-- am.englet.Trace.unfoundString(java.lang.String)
        <-- am.englet.Utils$1.result()
        <-- am.englet.Utils$2.Utils$2(java.lang.Class, java.lang.String)
        <-- am.englet.Utils$2.check(java.lang.reflect.Method)
        <-- am.englet.Utils$2.val$regex
        <-- am.englet.Utils$3.toString()
        <-- am.englet.Utils$4.toString()
        <-- am.englet.Utils$5.Utils$5(int, java.lang.String, java.lang.String, int)
        <-- am.englet.Utils$5.content()
        <-- am.englet.Utils$5.tryNext()
        <-- am.englet.Utils$5.val$of
        <-- am.englet.Utils$5.val$sample
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$7.convert(java.lang.Object)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils$9.convert(java.lang.Object)
        <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
        <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
        <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        <-- am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.getClipString()
        <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        <-- am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.outPrintln(java.io.PrintStream, java.lang.String)
        <-- am.englet.Utils.packageNameToPackagePath(java.lang.String)
        <-- am.englet.Utils.simpleClassname(java.lang.String)
        <-- am.englet.Utils.simpleName(java.lang.Class)
        <-- am.englet.Utils.splitLink(java.lang.String, java.lang.String, int)
        <-- am.englet.Utils.splitSlider(java.lang.String, java.lang.String, int)
        <-- am.englet.Utils.static {}
        <-- am.englet.Utils.toBoolean(java.lang.Object)
        <-- am.englet.Utils.toCharSequence(java.lang.Object)
        <-- am.englet.Utils.toClassNameCase(java.lang.String)
        <-- am.englet.Utils.toFieldNameCase(java.lang.String)
        <-- am.englet.Utils.toStringBuffer(java.lang.Object)
        <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
        <-- am.englet.YAMLBasedEngletSettings$1.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$2.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings$Performer.perform(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.access$0(am.englet.YAMLBasedEngletSettings, am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.adapt_method(am.englet.Englet, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.getClass(java.lang.String)
        <-- am.englet.YAMLBasedEngletSettings.parse(am.englet.Englet, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.bsh.Management.adaptMethod(am.englet.MethodsStorage, bsh.BshMethod, java.lang.String)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.bsh.MethodInvokable.targetType()
        <-- am.englet.bsh.MethodInvokable.toString()
        <-- am.englet.bsh.MethodInvokableMetadata.targetType()
        <-- am.englet.cast.CastException.CastException(java.lang.String)
        <-- am.englet.cast.CastException.CastException(java.lang.String, java.lang.Throwable)
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
        <-- am.englet.cast.ChainCaster.ChainCaster(am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool$1.val$name
        <-- am.englet.cast.ClassPool.BASE_PKGS
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.access$1(am.englet.cast.ClassPool, java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        <-- am.englet.cast.ClassPool.forName(java.lang.String)
        <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
        <-- am.englet.cast.ClassPool.getResource(java.lang.String)
        <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
        <-- am.englet.cast.ClassPool.importPackages(java.lang.String[])
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.ConstructorBasedCaster.ConstructorBasedCaster(java.lang.reflect.Constructor)
        <-- am.englet.cast.ForkCaster.ForkCaster(java.lang.Class, am.englet.cast.Caster, am.englet.cast.Caster)
        <-- am.englet.cast.MethodBasedCaster.MethodBasedCaster(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.PerfomerBasedAbstractCaster(java.lang.Object, java.lang.String)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.message
        <-- am.englet.cast.SameObjectCaster.SameObjectCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.SameObjectCaster.cast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StringToClassCaster.cast(java.lang.Object)
        <-- am.englet.cast.StringToClassCaster.importPackages(java.lang.String[])
        <-- am.englet.cast.StringToClassCaster.source()
        <-- am.englet.cast.StringToClassCaster.target()
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
        <-- am.englet.cast.ToStringCaster.cast(java.lang.Object)
        <-- am.englet.cast.ToStringCaster.source()
        <-- am.englet.cast.ToStringCaster.target()
        <-- am.englet.dispatch.Utils$3.result()
        <-- am.englet.flt.main(java.lang.String[])
        <-- am.englet.inputtokenizers.Act.getPerformers()
        <-- am.englet.inputtokenizers.Act.toString()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator.next()
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.BIG
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.CONTINUATING
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.ESC
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.EVENTS
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.ORDINAL
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.Q1
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.Q2
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.SPEC
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.STARTING
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.WS
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.event(int)
        <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.BASIC
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.EOF
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.INITIAL
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.event(int)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.next1()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.objectAppendPerformer(java.lang.String)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.ArrayBasedCharToEventConverterImpl(java.lang.String)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.defaultEvent
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.event(char)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(java.lang.CharSequence, java.lang.String)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.setEvent(java.lang.CharSequence, java.lang.String)
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.values
        <-- am.englet.inputtokenizers.custom.CharToEventConverter.event(char)
        <-- am.englet.inputtokenizers.custom.CustomTokenizerAdapter.event(int)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.RangesBasedCharToEventConverterImpl$Range(char, char, java.lang.String)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.value
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        <-- am.englet.link.CompiledFinalLink.toString()
        <-- am.englet.link.FinalLink.CLOSING_BRACKET_SYMBOL
        <-- am.englet.link.FinalLink.OPENING_BRACKET_SYMBOL
        <-- am.englet.link.FinalLink.contentString()
        <-- am.englet.link.FinalLink.toString()
        <-- am.englet.link.StorageImpl.restore()
        <-- am.englet.link.backadapters.IteratorAdapter.static {}
        <-- am.englet.link.backadapters.LineReaderAdapter.getNext()
        <-- am.englet.link.backadapters.LineReaderAdapter.static {}
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
        <-- am.englet.link.backadapters.slider.LinkSlider.content()
        <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        <-- am.englet.reflect.MemberInvokable.extraToString()
        <-- am.englet.reflect.MemberInvokable.name
        <-- am.englet.reflect.MemberInvokable.name()
        <-- am.englet.reflect.MemberInvokable.name(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.toString()
        <-- am.englet.reflect.MemberInvokable.type()
        <-- am.englet.reflect.MemberInvokable.writeReplace()
        <-- am.englet.reflect.SimpleProperty.instance(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.SimpleProperty.toString()
        <-- am.englet.reflect.SimplePropertyTest.setUp()
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        <-- am.englet.reflect.Utils$4.Utils$4(java.lang.Class, java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils$4.val$anObject
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
        <-- am.englet.stateengine.Act.s(java.lang.String)
        <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
        <-- am.englet.stateengine.Act.toString()
        <-- am.englet.stateengine.Engine$1.toString()
        <-- am.englet.stateengine.Engine.act(java.lang.Object)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.intern(java.lang.Object)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        <-- am.englet.stateengine.Engine.static {}
        <-- am.englet.try1$try2.clone()
        <-- am.englet.try1$try2.try1$try2(am.englet.try1)
        <-- am.englet.try1.clone()
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.try1.try1()
        <-- am.englet.try2.main(java.lang.String[])
        <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
        <-- am.englet.util.MapPath.MapPath(java.lang.String)
        <-- am.englet.util.MapPath.MapPath(java.lang.String, char)
        <-- am.englet.util.MapPath.from(java.lang.Object)
        <-- am.englet.util.MapPath.path
        <-- am.englet.wiring.BeanPool.get(java.lang.String)
        <-- am.englet.wiring.BeanPool.has(java.lang.String)
        <-- am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.NameResolver.resolve(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.String, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.static {}
        <-- am.englet.wiring.PoolsBuilder.wire()
        <-- am.englet.wiring.PropertiesBasedNameResolver.resolve(java.lang.String)
        <-- t.main(java.lang.String[])
        <-- t1.main(java.lang.String[])
        String(byte[], java.lang.String) *
            <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
        String(char[]) *
            <-- am.englet.Trace.toHexString(int)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        String(char[], int, int) *
            <-- am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
        charAt(int) *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.toBoolean(java.lang.Object)
            <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
            <-- am.englet.util.MapPath.MapPath(java.lang.String)
        endsWith(java.lang.String) *
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
        equals(java.lang.Object) *
            <-- am.englet.$$Performer.nameFits(java.lang.String[], java.lang.String)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management$1.check(java.lang.reflect.Method)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        equalsIgnoreCase(java.lang.String) *
            <-- am.englet.Utils.toBoolean(java.lang.Object)
        getBytes(java.lang.String) *
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
            <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
        indexOf(int) *
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        indexOf(int, int) *
            <-- am.englet.util.MapPath.from(java.lang.Object)
        indexOf(java.lang.String) *
            <-- am.englet.LoopTest$2.check(java.lang.reflect.Method)
            <-- am.englet.LoopTest$3.check(java.lang.reflect.Method)
            <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
            <-- am.englet.Management$5.check(java.lang.reflect.Field)
            <-- am.englet.Management$6.check(java.lang.reflect.Field)
            <-- am.englet.Management$7.check(java.lang.reflect.Method)
            <-- am.englet.TestUtils0.div(java.lang.String, java.lang.String)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
            <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        indexOf(java.lang.String, int) *
            <-- am.englet.Utils$5.tryNext()
            <-- am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
        intern() *
            <-- am.englet.Management.static {}
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.TestUtils0.static {}
            <-- am.englet.stateengine.Engine.intern(java.lang.Object)
            <-- am.englet.stateengine.Engine.static {}
        lastIndexOf(int) *
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String)
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.Utils.simpleClassname(java.lang.String)
            <-- am.englet.Utils.simpleName(java.lang.Class)
        lastIndexOf(java.lang.String, int) *
            <-- am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
        length() *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.MethodsStorage.lookup(java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
            <-- am.englet.Processing.fromFile(java.lang.String)
            <-- am.englet.Processing.part(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.partLink(java.lang.CharSequence, java.lang.String, int, int)
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            <-- am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
            <-- am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
            <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
            <-- am.englet.Processing.toFileClose(java.lang.String, java.io.OutputStream)
            <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.TestUtils0.div(java.lang.String, java.lang.String)
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.Utils.splitSlider(java.lang.String, java.lang.String, int)
            <-- am.englet.Utils.toBoolean(java.lang.Object)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.util.Buffer.Buffer(java.lang.String, int)
        matches(java.lang.String) *
            <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
            <-- am.englet.Management$5.check(java.lang.reflect.Field)
            <-- am.englet.Management$6.check(java.lang.reflect.Field)
            <-- am.englet.Management$7.check(java.lang.reflect.Method)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
        replaceAll(java.lang.String, java.lang.String) *
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.Utils.packageNameToPackagePath(java.lang.String)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        split(java.lang.String) *
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.stateengine.Act.addTo(am.englet.stateengine.Engine, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Act.s(java.lang.String)
            <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
        split(java.lang.String, int) *
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
        startsWith(java.lang.String) *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.fitsClassName(java.lang.Class, boolean, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
        substring(int) *
            <-- am.beans.reflect.ClassMap.importClassName(java.lang.String)
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            <-- am.englet.TestUtils0$12.step()
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.simpleClassname(java.lang.String)
            <-- am.englet.Utils.simpleName(java.lang.Class)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        substring(int, int) *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.TestUtils0$12.step()
            <-- am.englet.Utils$5.content()
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        toCharArray() *
            <-- am.englet.Lookup.underscoredToCamel(java.lang.String, boolean)
            <-- am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
        toLowerCase() *
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
        toUpperCase() *
            <-- am.englet.Lookup$3.provide()
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        trim() *
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.ClassPool.ClassPool()
        valueOf(java.lang.Object) *
            <-- am.beans.reflect.Destringer.toString()
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.Utils.toStringBuffer(java.lang.Object)
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.cast.ToStringCaster.cast(java.lang.Object)
            <-- am.englet.link.FinalLink.toString()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
    StringBuffer *
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
        <-- am.beans.reflect.Destringer.toString()
        <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
        <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
        <-- am.englet.CommandSource.toString()
        <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
        <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
        <-- am.englet.CompoundInvokable.toString()
        <-- am.englet.DataStack$StackFrame.toString()
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
        <-- am.englet.DataStack.toString()
        <-- am.englet.Englet$1.toString()
        <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
        <-- am.englet.Invokable$1.toString()
        <-- am.englet.InvokableDescription.toString()
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.Management$3.toString()
        <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.printstack(am.englet.DataStack)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.extraToString()
        <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
        <-- am.englet.MethodsStorage$Cast.toString()
        <-- am.englet.MethodsStorage$Direct.toString()
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage$Getter.toString()
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage$MethodRecord.toString()
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
        <-- am.englet.MethodsStorage.toString()
        <-- am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
        <-- am.englet.Processing.chr(int)
        <-- am.englet.Processing.condReplace(java.lang.StringBuffer, java.lang.String, int, int)
        <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
        <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.fromClip()
        <-- am.englet.Processing.fromFile(java.io.File)
        <-- am.englet.Processing.fromFile(java.lang.String)
        <-- am.englet.Processing.fromUrl(java.lang.String)
        <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.join(java.lang.StringBuffer, am.englet.link.Link, am.englet.VariablesStorage)
        <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
        <-- am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
        <-- am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
        <-- am.englet.Processing.resetToFalse(java.lang.StringBuffer, int)
        <-- am.englet.Processing.suckThru(java.io.File, java.io.InputStream)
        <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
        <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
        <-- am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        <-- am.englet.SingletonPool$Derivation.toString()
        <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
        <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
        <-- am.englet.Trace.open()
        <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
        <-- am.englet.Trace.timeString(long)
        <-- am.englet.Utils$2.check(java.lang.reflect.Method)
        <-- am.englet.Utils$3.toString()
        <-- am.englet.Utils$4.toString()
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
        <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
        <-- am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
        <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
        <-- am.englet.Utils.toClassNameCase(java.lang.String)
        <-- am.englet.Utils.toFieldNameCase(java.lang.String)
        <-- am.englet.Utils.toStringBuffer(java.lang.Object)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.bsh.MethodInvokable.toString()
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
        <-- am.englet.inputtokenizers.Act.getPerformers()
        <-- am.englet.inputtokenizers.Act.toString()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append()
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(int)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.buf
        <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
        <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
        <-- am.englet.link.CompiledFinalLink.toString()
        <-- am.englet.link.FinalLink.contentString()
        <-- am.englet.link.FinalLink.toString()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
        <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
        <-- am.englet.reflect.MemberInvokable.toString()
        <-- am.englet.reflect.SimpleProperty.toString()
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.stateengine.Act.toString()
        <-- am.englet.stateengine.Engine$1.toString()
        <-- am.englet.stateengine.Engine.act(java.lang.Object)
        <-- am.englet.try1.bb
        <-- am.englet.try1.main(java.lang.String[])
        <-- am.englet.try1.try1()
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        StringBuffer() *
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Processing.chr(int)
            <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
            <-- am.englet.Processing.fromFile(java.lang.String)
            <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
            <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            <-- am.englet.inputtokenizers.Act.getPerformers()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.ReaderToTokenizerAdapter(java.lang.Object)
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.try1.try1()
        StringBuffer(int) *
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
        StringBuffer(java.lang.String) *
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
            <-- am.beans.reflect.Destringer.toString()
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CommandSource.toString()
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.Invokable$1.toString()
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Management$3.toString()
            <-- am.englet.Management.printstack(am.englet.DataStack)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.extraToString()
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$Cast.toString()
            <-- am.englet.MethodsStorage$Direct.toString()
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$Getter.toString()
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            <-- am.englet.MethodsStorage.toString()
            <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
            <-- am.englet.Processing.fromClip()
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.toStringBuffer(java.lang.Object)
            <-- am.englet.SingletonPool$Derivation.toString()
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.open()
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
            <-- am.englet.Utils$3.toString()
            <-- am.englet.Utils$4.toString()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.Utils.toStringBuffer(java.lang.Object)
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.bsh.MethodInvokable.toString()
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.inputtokenizers.Act.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.link.FinalLink.contentString()
            <-- am.englet.link.FinalLink.toString()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Act.toString()
            <-- am.englet.stateengine.Engine$1.toString()
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        append(char) *
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Processing.appendCleanBytes(java.lang.StringBuffer, java.lang.String)
            <-- am.englet.Processing.chr(int)
            <-- am.englet.Processing.fromBytes(byte[], java.lang.String)
            <-- am.englet.Processing.fromFile(java.lang.String)
            <-- am.englet.Processing.toBytes(java.lang.String, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.suckThru(byte[], java.io.InputStream)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(int)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        append(int) *
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Invokable$1.toString()
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.try1.main(java.lang.String[])
        append(java.lang.Object) *
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CommandSource.toString()
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.printstack(am.englet.DataStack)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.extraToString()
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$Cast.toString()
            <-- am.englet.MethodsStorage$Direct.toString()
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            <-- am.englet.MethodsStorage.toString()
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.SingletonPool$Derivation.toString()
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
            <-- am.englet.Utils$3.toString()
            <-- am.englet.Utils$4.toString()
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            <-- am.englet.inputtokenizers.Act.getPerformers()
            <-- am.englet.inputtokenizers.Act.toString()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.append(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.link.FinalLink.contentString()
            <-- am.englet.link.FinalLink.toString()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
            <-- am.englet.stateengine.Act.toString()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        append(java.lang.String) *
            <-- am.beans.reflect.Destringer.toString()
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CommandSource.toString()
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Management$3.toString()
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.extraToString()
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$Cast.toString()
            <-- am.englet.MethodsStorage$Getter.toString()
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.MethodsStorage.toString()
            <-- am.englet.Processing.fromBytes(java.lang.String, java.lang.String)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.SingletonPool$Derivation.toString()
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.open()
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.bsh.MethodInvokable.toString()
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            <-- am.englet.inputtokenizers.Act.getPerformers()
            <-- am.englet.inputtokenizers.Act.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.link.FinalLink.contentString()
            <-- am.englet.link.FinalLink.toString()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Act.toString()
            <-- am.englet.stateengine.Engine$1.toString()
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        append(java.lang.StringBuffer) *
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        delete(int, int) *
            <-- am.englet.InvokableDescription.toString()
        indexOf(java.lang.String) *
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            <-- am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
        indexOf(java.lang.String, int) *
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            <-- am.englet.Utils.indexOf(java.lang.Object, java.lang.String, int)
        insert(int, char) *
            <-- am.englet.CompoundInvokable.toString()
        lastIndexOf(java.lang.String) *
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            <-- am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
        lastIndexOf(java.lang.String, int) *
            <-- am.englet.Utils.lastIndexOf(java.lang.Object, java.lang.String, int)
        length() *
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Processing.tryJoin(am.englet.link.Link, java.lang.StringBuffer, am.englet.VariablesStorage)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.inputtokenizers.Act.getPerformers()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        replace(int, int, java.lang.String) *
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.Processing.condReplace(java.lang.StringBuffer, java.lang.String, int, int)
            <-- am.englet.Processing.replace(java.lang.StringBuffer, java.lang.String, java.lang.String, int)
            <-- am.englet.Processing.replaceAllAggressivelyFromFinish(java.lang.StringBuffer, java.lang.String, java.lang.String)
            <-- am.englet.Processing.replaceAllAggressivelyFromStart(java.lang.StringBuffer, java.lang.String, java.lang.String)
        setLength(int) *
            <-- am.englet.Processing.resetToFalse(java.lang.StringBuffer, int)
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
        substring(int) *
            <-- am.englet.inputtokenizers.Act.getPerformers()
        toString() *
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
            <-- am.beans.reflect.Destringer.toString()
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
            <-- am.englet.CastingContextImpl1.findCaster(java.lang.Class, java.lang.Class)
            <-- am.englet.CommandSource.toString()
            <-- am.englet.CompoundInvokable$ArgArrayArgSource.toString()
            <-- am.englet.CompoundInvokable$InvokableWrapper.toString()
            <-- am.englet.CompoundInvokable.toString()
            <-- am.englet.DataStack$StackFrame.toString()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.DataStack.toString()
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.Invokable$1.toString()
            <-- am.englet.InvokableDescription.toString()
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Management$3.toString()
            <-- am.englet.Management.dupClone(java.lang.StringBuffer, am.englet.DataStack)
            <-- am.englet.Management.printstack(am.englet.DataStack)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.extraToString()
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$Cast.toString()
            <-- am.englet.MethodsStorage$Direct.toString()
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$Getter.toString()
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage$MethodRecord.toString()
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            <-- am.englet.MethodsStorage.toString()
            <-- am.englet.Processing.join(am.englet.link.Link, am.englet.VariablesStorage)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.SingletonPool$Derivation.toString()
            <-- am.englet.SingletonPool$util.getClass(java.lang.Class, java.lang.String)
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.got(java.lang.Object, java.lang.String)
            <-- am.englet.Trace.open()
            <-- am.englet.Trace.saveConvert(java.lang.String, boolean)
            <-- am.englet.Trace.timeString(long)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
            <-- am.englet.Utils$3.toString()
            <-- am.englet.Utils$4.toString()
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.camelCaseToUnderscored(java.lang.String)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.Utils.toClassNameCase(java.lang.String)
            <-- am.englet.Utils.toFieldNameCase(java.lang.String)
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.bsh.MethodInvokable.toString()
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            <-- am.englet.inputtokenizers.Act.toString()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.getNext()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$1.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$2.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$3.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine$4.toString()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.dump()
            <-- am.englet.link.CompiledFinalLink.toString()
            <-- am.englet.link.FinalLink.contentString()
            <-- am.englet.link.FinalLink.toString()
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
            <-- am.englet.reflect.AbstractSimpleInvokablePerformer.toString()
            <-- am.englet.reflect.MemberInvokable.toString()
            <-- am.englet.reflect.SimpleProperty.toString()
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Act.toString()
            <-- am.englet.stateengine.Engine$1.toString()
            <-- am.englet.stateengine.Engine.act(java.lang.Object)
            <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
            <-- am.englet.wiring.FieldBuilderImpl.properName(java.lang.String)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
    String[] *
        <-- am.englet.wiring.PoolsBuilder.doImports()
    System *
        arraycopy(java.lang.Object, int, java.lang.Object, int, int) *
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$MethodRecord.copy(java.lang.Class[])
            <-- am.englet.Utils$3.Utils$3(am.englet.Invokable)
            <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils$4.Utils$4(am.englet.Invokable)
            <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
            <-- am.englet.Utils.copy(java.lang.Object[])
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
            <-- am.englet.reflect.MemberInvokable.deprimitivise(java.lang.Class[])
            <-- am.englet.reflect.MemberInvokable.parameterTypes()
        currentTimeMillis() *
            <-- am.englet.Trace.open()
        err *
            <-- am.englet.Englet.dump(am.englet.CommandSource, am.englet.VariablesStorage)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Management.dump(am.englet.MethodsStorage)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.repInvokeStringFail(java.lang.Object)
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        getProperties() *
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
        getProperty(java.lang.String) *
            <-- am.englet.Lookup.static {}
            <-- am.englet.SimpleStringArrayEngletSettings.propsFile()
            <-- am.englet.SimpleStringArrayEngletSettings.propsURLInput()
        getProperty(java.lang.String, java.lang.String) *
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        identityHashCode(java.lang.Object) *
            <-- am.englet.MethodsStorage$Training$Invocation.MethodsStorage$Training$Invocation(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.Trace.hash(java.lang.Object)
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        in *
            <-- am.englet.Processing.fromFile(java.lang.String)
        out *
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.getArgument()
            <-- am.englet.EngletParserReaderTokenizerFactory.main(java.lang.String[])
            <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUp(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpCaster(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpGetter(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpSetter(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpStaticMethod(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.Class, java.lang.String)
            <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.lookupMethodNonBasic(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.tryToAdapt1(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class, java.lang.Class[], int)
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
            <-- am.englet.LoopTest.test1()
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
            <-- am.englet.Management.excl(am.englet.link.Link, am.englet.CommandSource)
            <-- am.englet.Management.excl(java.lang.Integer, am.englet.CommandSource)
            <-- am.englet.Management.excl(java.lang.Object, java.lang.String, am.englet.VariablesStorage)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.multiPut(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.peekVar(java.lang.Object, java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.printstack(am.englet.DataStack)
            <-- am.englet.Management.put2(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put3(java.lang.String, am.englet.DataStack)
            <-- am.englet.Management.put4(java.lang.String, am.englet.DataStack)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.Processing.toFileOpen(java.lang.String, boolean)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.TestUtils0$6.check(java.lang.Object)
            <-- am.englet.TestUtils0$7.check(java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, am.englet.CodeBlock)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Object, java.lang.Object, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.lazy(am.englet.link.Link)
            <-- am.englet.Utils.nthIndexOf(java.lang.Object, java.lang.String, int)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.printCheck(am.englet.cast.CasterProvidersBank, java.lang.Class, am.englet.cast.ClassCastChainFinder, java.lang.Class)
            <-- am.englet.dispatch.Utils.search(am.englet.MethodsStorage$MethodRecord[], java.lang.Class[], am.englet.CastingContext, boolean)
            <-- am.englet.flt.main(java.lang.String[])
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.reportIllegalState(java.lang.Object)
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.main(java.lang.String[])
            <-- am.englet.reflect.SimplePropertyTest.testGet()
            <-- am.englet.reflect.SimplePropertyTest.testSet()
            <-- am.englet.reflect.SimplePropertyTest.testSimpleProperty()
            <-- am.englet.try1$try2.clone()
            <-- am.englet.try1$try2.try1$try2(am.englet.try1)
            <-- am.englet.try1.clone()
            <-- am.englet.try1.main(java.lang.String[])
            <-- am.englet.try1.try1()
            <-- am.englet.try2$A.p()
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            <-- t.main(java.lang.String[])
            <-- t1.main(java.lang.String[])
    Thread *
        sleep(long) *
            <-- am.englet.Utils.pump(java.io.InputStream, java.io.OutputStream)
    Throwable *
        <-- am.englet.ConditionalValueConverter.convert(java.lang.Object)
        <-- am.englet.Englet.run()
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.EngletBasedChecker.check(java.lang.Object)
        <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.Immediate.run(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.InvokableBasedValueConverter.convert(java.lang.Object)
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.run(am.englet.DataStack, am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.Management.start(am.englet.Englet)
        <-- am.englet.Management.startlet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.String, java.lang.Throwable)
        <-- am.englet.MethodsStorage$CommandNotFoundException.MethodsStorage$CommandNotFoundException(java.lang.Throwable)
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.TestUtils0$10.TestUtils0$10(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool, am.englet.link.Link, am.englet.link.Link)
        <-- am.englet.TestUtils0$10.tryNextContent()
        <-- am.englet.TestUtils0.minus(am.englet.link.Link, am.englet.link.Link, am.englet.cast.ClassPool, am.englet.MethodsStorage, am.englet.DataStack)
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.cast.CastException.CastException(java.lang.String, java.lang.Throwable)
        <-- am.englet.cast.CastException.CastException(java.lang.Throwable)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.cast(java.lang.Object)
        <-- am.englet.link.FinalLink$Serializable.readResolve()
        getMessage() *
            <-- am.beans.reflect.ClassMap.forName(java.lang.String)
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Destringer.static {}
            <-- am.englet.$$5.$$5()
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.$.check(java.lang.reflect.Constructor)
            <-- am.englet.$.check(java.lang.reflect.Field)
            <-- am.englet.$.check(java.lang.reflect.Method)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.$.static {}
            <-- am.englet.CastingContextImpl1.CastingContextImpl1()
            <-- am.englet.DataStack.mustNotHave(java.lang.Object)
            <-- am.englet.DataStack.putRes(java.lang.Class[], int, java.lang.Object)
            <-- am.englet.Englet.Englet()
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Englet.getCastingContext()
            <-- am.englet.Englet.getMethods()
            <-- am.englet.Englet.getParserFactory()
            <-- am.englet.Englet.getRstack()
            <-- am.englet.Englet.getStack()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Englet.parse(java.lang.String)
            <-- am.englet.Englet.run()
            <-- am.englet.Englet.setCastingContext(am.englet.CastingContext)
            <-- am.englet.Englet.static {}
            <-- am.englet.Invokable$1.returnType()
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.Lookup$8.base()
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.lookUpProxy(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.static {}
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.LoopTest.test1()
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
            <-- am.englet.Management.runner(am.englet.DataStack)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodsStorage$Cast.MethodsStorage$Cast(java.lang.Object, java.lang.Class, boolean)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
            <-- am.englet.SimpleCastingContext.canCast(java.lang.Class, java.lang.Class)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SingletonPool$util.getAssigneeClass(java.lang.String)
            <-- am.englet.SingletonPool$util.sImpls()
            <-- am.englet.TestUtils0$FS1.tryNext()
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.TestUtils0.times(am.englet.link.Link, am.englet.Invokable)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.isCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.static {}
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.MethodInvokable.targetType()
            <-- am.englet.bsh.MethodInvokableMetadata.targetType()
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
            <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.cast.ClassPool.getResource(java.lang.String)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StringToClassCaster.source()
            <-- am.englet.cast.StringToClassCaster.target()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.test1()
            <-- am.englet.cast.ToStringCaster.source()
            <-- am.englet.cast.ToStringCaster.target()
            <-- am.englet.inputtokenizers.ReaderToTokenizerAdapter.static {}
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
            <-- am.englet.link.backadapters.IteratorAdapter.static {}
            <-- am.englet.link.backadapters.LineReaderAdapter.static {}
            <-- am.englet.link.backadapters.slider.LinkSliderAdapter.static {}
            <-- am.englet.reflect.SimplePropertyTest.setUp()
            <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.static {}
            <-- am.englet.wiring.PoolsBuilder.wire()
        printStackTrace() *
            <-- am.englet.EngletBasedChecker.check(java.lang.Object)
            <-- am.englet.EngletBasedValueConverter.convert(java.lang.Object)
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
            <-- am.englet.TestUtils0$10.tryNextContent()
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object)
            <-- am.englet.Utils.debug(java.io.PrintStream, java.lang.Throwable, java.lang.Object, java.lang.Object, java.lang.Object)
        printStackTrace(java.io.PrintStream) *
            <-- am.englet.MethodsStorage$MethodRecord.reportFail(java.lang.Object, java.lang.Object[], am.englet.Invokable, java.lang.Throwable)
    UnsupportedOperationException *
        UnsupportedOperationException() *
            <-- am.englet.link.TrivialBaseBackAdapterImpl.current()
            <-- am.englet.link.TrivialBaseBackAdapterImpl.getNext()
            <-- am.englet.link.TrivialBaseBackAdapterImpl.hasNext()
            <-- am.englet.link.TrivialBaseBackAdapterImpl.tryNext()
    Void *
        TYPE *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.static {}
            <-- am.englet.FieldSetInvokable.returnType(java.lang.reflect.Member)
            <-- am.englet.Lookup.lookUpMethod1(am.englet.MethodsStorage, java.lang.String, java.lang.Class[])
            <-- am.englet.MethodInvokable.arrayClass(java.lang.Class, java.lang.Class[])
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.reflect.SimpleProperty.valueType()
java.lang.reflect *
    AccessibleObject *
        <-- am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
        setAccessible(boolean) *
            <-- am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
    Array *
        get(java.lang.Object, int) *
            <-- am.beans.reflect.FieldGetter.get(java.lang.Object, int)
            <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
            <-- am.englet.Processing$2.get(int)
            <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        getLength(java.lang.Object) *
            <-- am.englet.Processing$2.size()
            <-- am.englet.Utils.print(java.io.PrintStream, java.lang.Object)
        newInstance(java.lang.Class, int) *
            <-- am.englet.MethodInvokable.arrayClass(java.lang.Class)
            <-- am.englet.Utils.copy(java.lang.Object[])
        set(java.lang.Object, int, java.lang.Object) *
            <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
            <-- am.englet.Processing$2.set(int, java.lang.Object)
    Constructor *
        <-- am.beans.reflect.ConstructorCaller.ConstructorCaller(java.lang.reflect.Constructor)
        <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.ConstructorCaller.con()
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.Destringer$SimpleConstructorDestringer(java.lang.reflect.Constructor)
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.constructor
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.englet.$$2.declaredMembers(java.lang.Class)
        <-- am.englet.$$2.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.members(java.lang.Class)
        <-- am.englet.$$2.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$.check(java.lang.reflect.Constructor)
        <-- am.englet.$.each(java.lang.reflect.Constructor)
        <-- am.englet.$.each(java.lang.reflect.Constructor, java.lang.Object)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$Base.constructor()
        <-- am.englet.$Base.constructor(int, int)
        <-- am.englet.$Base.constructor(int, int, java.lang.Class[])
        <-- am.englet.$Base.constructor(java.lang.Class[])
        <-- am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.ConstructorInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.Main.getSettings(java.lang.String[])
        <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Utils.lookUpConstructor(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCaster.ConstructorBasedCaster(java.lang.reflect.Constructor)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.ConstructorBasedCaster.getCon()
        <-- am.englet.cast.ConstructorBasedCaster.sourceClass()
        <-- am.englet.cast.ConstructorBasedCaster.targetClass()
        <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        equals(java.lang.Object) *
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        getDeclaringClass() *
            <-- am.englet.ConstructorInvokable.returnType(java.lang.reflect.Member)
            <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
            <-- am.englet.cast.ConstructorBasedCaster.targetClass()
        getParameterTypes() *
            <-- am.englet.$$2.paramTypes(java.lang.reflect.Member)
            <-- am.englet.ConstructorInvokable.parameterTypes(java.lang.reflect.Member)
            <-- am.englet.cast.ConstructorBasedCaster.sourceClass()
            <-- am.englet.cast.ConstructorBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        newInstance(java.lang.Object[]) *
            <-- am.beans.reflect.ConstructorCaller.call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.Destringer$SimpleConstructorDestringer.forString(java.lang.String)
            <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
            <-- am.englet.Main.getSettings(java.lang.String[])
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl$1.instance(java.lang.Class, java.lang.Object[])
        toString() *
            <-- am.englet.Management$4.check(java.lang.reflect.Constructor)
    Field *
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.FieldGetter.FieldGetter(java.lang.reflect.Field)
        <-- am.beans.reflect.FieldGetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldGetter.f()
        <-- am.beans.reflect.FieldGetter.get(java.lang.Object)
        <-- am.beans.reflect.FieldSetter.FieldSetter(java.lang.reflect.Field)
        <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.FieldSetter.f()
        <-- am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
        <-- am.beans.reflect.FieldSetter.set(java.lang.Object, int, java.lang.Object)
        <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        <-- am.englet.$$1.declaredMembers(java.lang.Class)
        <-- am.englet.$$1.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$1.members(java.lang.Class)
        <-- am.englet.$$1.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$.check(java.lang.reflect.Field)
        <-- am.englet.$.each(java.lang.reflect.Field)
        <-- am.englet.$.each(java.lang.reflect.Field, java.lang.Object)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$Base.field()
        <-- am.englet.$Base.field(int, int)
        <-- am.englet.$Base.field(int, int, java.lang.Class)
        <-- am.englet.$Base.field(int, int, java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(int, int, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.Class)
        <-- am.englet.$Base.field(java.lang.Class, java.lang.String[])
        <-- am.englet.$Base.field(java.lang.String[])
        <-- am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldGetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup.adaptFieldGetter(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Field)
        <-- am.englet.Lookup.lookUpField(am.englet.MethodsStorage, java.lang.String, java.lang.String, java.lang.Class)
        <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpStaticField(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String)
        <-- am.englet.LoopTest$1.each(java.lang.reflect.Field)
        <-- am.englet.Management$5.check(java.lang.reflect.Field)
        <-- am.englet.Management$6.check(java.lang.reflect.Field)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.reflect.Utils$5.check(java.lang.reflect.Field)
        <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        <-- am.englet.reflect.Utils.tryFieldProperty(java.lang.Class, java.lang.String)
        <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
        <-- am.englet.wiring.FieldBuilder.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$2.value(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        get(java.lang.Object) *
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            <-- am.beans.reflect.FieldGetter.call(java.lang.Object, java.lang.Object[])
            <-- am.beans.reflect.FieldGetter.get(java.lang.Object)
            <-- am.beans.reflect.FieldSetter.get(java.lang.Object, java.lang.reflect.Field)
            <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        getDeclaringClass() *
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
        getName() *
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
            <-- am.englet.FieldGetInvokable.name(java.lang.reflect.Member)
            <-- am.englet.FieldSetInvokable.name(java.lang.reflect.Member)
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        getType() *
            <-- am.englet.$$1.paramTypes(java.lang.reflect.Member)
            <-- am.englet.FieldGetInvokable.returnType(java.lang.reflect.Member)
            <-- am.englet.FieldSetInvokable.parameterTypes(java.lang.reflect.Member)
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.wiring.FieldBuilderImpl.targetClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.FieldBuilderImpl.value(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$2.byType(java.lang.reflect.Field)
        set(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.FieldSetter.call(java.lang.Object, java.lang.Object[])
            <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            <-- am.englet.wiring.BuilderImpl$1.each(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder$3.each(java.lang.reflect.Field)
        setAccessible(boolean) *
            <-- am.englet.reflect.Utils.lookUpField(java.lang.Class, java.lang.String, boolean, boolean, boolean)
        toString() *
            <-- am.englet.Management$5.check(java.lang.reflect.Field)
            <-- am.englet.Management$6.check(java.lang.reflect.Field)
    InvocationHandler *
        <-- am.englet.Utils$6
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
    InvocationTargetException *
        <-- am.englet.CompoundInvokable$ArgumentSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable$InvokableWrapperArgSource.getData(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.CompoundInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.ConditionalValueConverter.invoke(java.lang.Object, am.englet.Invokable, boolean)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.Immediate.perform(am.englet.VariablesStorage, am.englet.MethodsStorage, java.lang.Object, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool)
        <-- am.englet.Invokable$1.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Invokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Management.call(am.englet.Invokable, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.CommandSource)
        <-- am.englet.Management.describe(am.englet.Invokable, am.englet.ArgumentProvider)
        <-- am.englet.Management.same(am.englet.ArgumentProvider)
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage$MethodRecord.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable)
        <-- am.englet.MethodsStorage.invoke(am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.Invokable, am.englet.MethodsStorage$Training)
        <-- am.englet.MethodsStorage.invoke(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.VariablesStorage, am.englet.cast.ClassPool)
        <-- am.englet.MethodsStorage.invokeString(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.cast.ClassPool, boolean)
        <-- am.englet.Utils$3.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils$4.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.Utils.tryConstructor(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryInvocationalCasting(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ConstructorBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.PerfomerBasedAbstractCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.SimpleGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableGetter.DO(java.lang.Object)
        <-- am.englet.reflect.SimpleInvokableSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.get(java.lang.Object)
        <-- am.englet.reflect.SimpleProperty.set(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.SimplePropertyTest.testGet()
        <-- am.englet.reflect.SimplePropertyTest.testSet()
        <-- am.englet.reflect.SimpleSetter.DO(java.lang.Object, java.lang.Object)
        <-- am.englet.reflect.Utils$1.DO(java.lang.Object)
        InvocationTargetException(java.lang.Throwable, java.lang.String) *
            <-- am.englet.bsh.MethodInvokable.invoke(java.lang.Object, java.lang.Object[])
        getTargetException() *
            <-- am.englet.Englet.runCore(am.englet.CommandSource, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.MethodsStorage, am.englet.VariablesStorage, am.englet.cast.ClassPool)
            <-- am.englet.MethodsStorage.handleString(java.lang.Object, am.englet.ResultHandler, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        printStackTrace() *
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.invoke(am.englet.Invokable)
    Member *
        <-- am.beans.reflect.ConstructorCaller.ConstructorCaller(java.lang.reflect.Constructor)
        <-- am.beans.reflect.ConstructorCaller.con()
        <-- am.beans.reflect.FieldGetter.FieldGetter(java.lang.reflect.Field)
        <-- am.beans.reflect.FieldGetter.f()
        <-- am.beans.reflect.FieldSetter.FieldSetter(java.lang.reflect.Field)
        <-- am.beans.reflect.FieldSetter.f()
        <-- am.beans.reflect.MemberCaller.MemberCaller(java.lang.reflect.Member)
        <-- am.beans.reflect.MemberCaller.m
        <-- am.beans.reflect.MethodCaller.MethodCaller(java.lang.reflect.Method)
        <-- am.beans.reflect.MethodCaller.m()
        <-- am.englet.$$$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$1.declaredMembers(java.lang.Class)
        <-- am.englet.$$1.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$1.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$1.members(java.lang.Class)
        <-- am.englet.$$1.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$2.declaredMembers(java.lang.Class)
        <-- am.englet.$$2.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$2.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$2.members(java.lang.Class)
        <-- am.englet.$$2.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$3.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$4.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Declared.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$First$Performer.$(am.englet.$, java.lang.Object, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$MethodPerformer.declaredMembers(java.lang.Class)
        <-- am.englet.$$MethodPerformer.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.members(java.lang.Class)
        <-- am.englet.$$MethodPerformer.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$Performer.declaredMembers(java.lang.Class)
        <-- am.englet.$$Performer.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$Performer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$Performer.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$Performer.first(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.loop(am.englet.$, java.lang.reflect.Member[], int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$$Performer.members(java.lang.Class)
        <-- am.englet.$$Performer.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
        <-- am.englet.$$Performer.summary(am.englet.$, java.lang.reflect.Member[], java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.$(java.lang.Object, int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$.access$4(am.englet.$)
        <-- am.englet.$.declaredMembers()
        <-- am.englet.$.members()
        <-- am.englet.ConstructorInvokable.ConstructorInvokable(java.lang.reflect.Constructor)
        <-- am.englet.ConstructorInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.ConstructorInvokable.name(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.ConstructorInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.FieldGetInvokable(java.lang.reflect.Field)
        <-- am.englet.FieldGetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldGetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.FieldGetInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.FieldSetInvokable(java.lang.reflect.Field)
        <-- am.englet.FieldSetInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.FieldSetInvokable.name(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.FieldSetInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.InvokableSerializer$3.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$5.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$MemberProvider.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
        <-- am.englet.Management.check(am.englet.Invokable, java.lang.String)
        <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodInvokable.name(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.Utils.isStatic(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.MemberInvokable(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.declaringType()
        <-- am.englet.reflect.MemberInvokable.getMember()
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.reflect.MemberInvokable.member
        <-- am.englet.reflect.MemberInvokable.name()
        <-- am.englet.reflect.MemberInvokable.name(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.parameterTypes()
        <-- am.englet.reflect.MemberInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.returnType()
        <-- am.englet.reflect.MemberInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.targetType()
        <-- am.englet.reflect.MemberInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.reflect.MemberInvokable.toString()
        getDeclaringClass() *
            <-- am.englet.FieldGetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.FieldSetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.Management.adapt_invokable(am.englet.MethodsStorage, am.englet.Invokable, java.lang.String)
            <-- am.englet.reflect.MemberInvokable.declaringType()
        getModifiers() *
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
            <-- am.englet.FieldGetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.FieldSetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.Utils.isStatic(java.lang.reflect.Member)
        getName() *
            <-- am.englet.$$Performer.precheck(am.englet.$, int, int, java.lang.Class[], java.lang.reflect.Member, java.lang.String[])
    Method *
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.Destringer$SimpleMethodDestringer(java.lang.reflect.Method)
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.description()
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
        <-- am.beans.reflect.Destringer$SimpleMethodDestringer.method
        <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
        <-- am.beans.reflect.MethodCaller.MethodCaller(java.lang.reflect.Method)
        <-- am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
        <-- am.beans.reflect.MethodCaller.m()
        <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
        <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
        <-- am.englet.$$6.check(java.lang.reflect.Method)
        <-- am.englet.$$MethodPerformer.declaredMembers(java.lang.Class)
        <-- am.englet.$$MethodPerformer.doCheck(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.Object, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.doEach(am.englet.$, java.lang.reflect.Member)
        <-- am.englet.$$MethodPerformer.members(java.lang.Class)
        <-- am.englet.$$MethodPerformer.paramTypes(java.lang.reflect.Member)
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.check(java.lang.reflect.Method)
        <-- am.englet.$.each(java.lang.reflect.Method)
        <-- am.englet.$.each(java.lang.reflect.Method, java.lang.Object)
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$Base.method()
        <-- am.englet.$Base.method(int, int)
        <-- am.englet.$Base.method(int, int, java.lang.Class[])
        <-- am.englet.$Base.method(int, int, java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(int, int, java.lang.String[])
        <-- am.englet.$Base.method(java.lang.Class[])
        <-- am.englet.$Base.method(java.lang.Class[], java.lang.String[])
        <-- am.englet.$Base.method(java.lang.String[])
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.InvokableSerializer$4.member(java.lang.Class, java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
        <-- am.englet.Lookup$4.provide()
        <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
        <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
        <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
        <-- am.englet.Lookup.doFinalAdaptMethod(am.englet.MethodsStorage, java.lang.String, java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
        <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.lookUpCollectionsMethod(am.englet.MethodsStorage, java.lang.String, java.lang.Class[], java.lang.String, int)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpGetterInvokable(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
        <-- am.englet.Lookup.lookUpSetOrAdd(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool)
        <-- am.englet.Lookup.lookUpTyped(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, int)
        <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
        <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
        <-- am.englet.Lookup.tryToAdapt2(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class)
        <-- am.englet.LoopTest$2.check(java.lang.reflect.Method)
        <-- am.englet.LoopTest$3.check(java.lang.reflect.Method)
        <-- am.englet.Management$1.check(java.lang.reflect.Method)
        <-- am.englet.Management$2.each(java.lang.reflect.Method)
        <-- am.englet.Management$7.check(java.lang.reflect.Method)
        <-- am.englet.Management.access$0(int, java.lang.reflect.Method)
        <-- am.englet.Management.access$2(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adaptMethod(am.englet.MethodsStorage, int, java.lang.reflect.Method, java.lang.String)
        <-- am.englet.Management.adapt_management(java.lang.String, java.lang.String, am.englet.MethodsStorage)
        <-- am.englet.Management.adapt_method(am.englet.MethodsStorage, java.lang.Class, java.lang.String, java.lang.String)
        <-- am.englet.Management.invokable(java.lang.String, java.lang.String, java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Management.runner(am.englet.DataStack)
        <-- am.englet.Management.toAdapt(int, java.lang.reflect.Method)
        <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method)
        <-- am.englet.MethodInvokable.MethodInvokable(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
        <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
        <-- am.englet.MethodInvokable.name(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.parameterTypes(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.returnType(java.lang.reflect.Member)
        <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
        <-- am.englet.MethodInvokableMetadata.MethodInvokableMetadata(java.lang.reflect.Method)
        <-- am.englet.MethodInvokableMetadata.invokable()
        <-- am.englet.MethodInvokableMetadata.isStatic()
        <-- am.englet.MethodInvokableMetadata.method
        <-- am.englet.MethodInvokableMetadata.targetType()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.SingletonPool$Derivation.SingletonPool$Derivation(java.lang.Class, java.lang.reflect.Method)
        <-- am.englet.SingletonPool$Derivation.method
        <-- am.englet.SingletonPool$Derivation.toString()
        <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
        <-- am.englet.Utils$2.check(java.lang.reflect.Method)
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils$6.equalsMethod
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.hashCodeMethod
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.toStringMethod
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.findFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.findStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.method(java.lang.Class, java.lang.String)
        <-- am.englet.Utils.method(java.lang.String, am.englet.cast.ClassPool)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.InstanceMethodBasedCaster.InstanceMethodBasedCaster(java.lang.reflect.Method)
        <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.InstanceMethodBasedCaster.sourceClass()
        <-- am.englet.cast.MethodBasedCaster.method()
        <-- am.englet.cast.MethodBasedCaster.targetClass()
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.StaticFactoryMethodBasedCaster(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        <-- am.englet.cast.StaticFactoryMethodBasedCaster.sourceClass()
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.check(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
        <-- am.englet.reflect.Utils$2.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils$3.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpGetterMethod(java.lang.Class, java.lang.String)
        <-- am.englet.reflect.Utils.lookUpSetterMethod(java.lang.Class, java.lang.String, java.lang.Class)
        <-- am.englet.reflect.Utils.lookUpSetterMethod0(java.lang.Class, java.lang.Class, java.lang.String)
        <-- am.englet.try2$A.p()
        equals(java.lang.Object) *
            <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        getDeclaringClass() *
            <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.findMethod(java.lang.String[], java.lang.Class[], java.lang.Class)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.Lookup.searchMethod(java.lang.Class, java.lang.String[], java.lang.Class[])
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.MethodInvokableMetadata.targetType()
            <-- am.englet.cast.InstanceMethodBasedCaster.sourceClass()
        getModifiers() *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.MethodInvokableMetadata.isStatic()
            <-- am.englet.MethodInvokableMetadata.targetType()
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        getName() *
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.checkMethod(java.lang.reflect.Method, int, java.lang.Class[], boolean, java.lang.String)
            <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.lookUpMethodOfClass(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.String, java.lang.Class[], int, int, java.lang.Class, boolean)
            <-- am.englet.LoopTest$2.check(java.lang.reflect.Method)
            <-- am.englet.LoopTest$3.check(java.lang.reflect.Method)
            <-- am.englet.Management$1.check(java.lang.reflect.Method)
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokable.name(java.lang.reflect.Member)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        getParameterTypes() *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Utils.isIndexedGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isIndexedSetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleGetterCandidate(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isSimpleSetterCandidate(java.lang.reflect.Method)
            <-- am.englet.$$MethodPerformer.paramTypes(java.lang.reflect.Member)
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Lookup$10.check(java.lang.reflect.Method)
            <-- am.englet.Lookup$6.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.correctMethod(java.lang.reflect.Method)
            <-- am.englet.Lookup.paramTypesFit(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.Lookup.stringClassMethodParamTypesEqual(java.lang.Class[], java.lang.reflect.Method)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCaster.sourceClass()
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$1.check(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
        getReturnType() *
            <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            <-- am.englet.$$6.check(java.lang.reflect.Method)
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.Lookup$11.check(java.lang.reflect.Method)
            <-- am.englet.Lookup.extracted(int, java.lang.Class[], java.lang.Class, boolean, java.lang.String, java.lang.Class, boolean)
            <-- am.englet.MethodInvokable.bpt(java.lang.reflect.Method, java.lang.Class)
            <-- am.englet.MethodInvokable.returnType(java.lang.reflect.Member)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            <-- am.englet.cast.MethodBasedCaster.targetClass()
            <-- am.englet.reflect.Utils.getSimpleProperty(java.lang.Class, java.lang.String)
        invoke(java.lang.Object, java.lang.Object[]) *
            <-- am.beans.reflect.Destringer$SimpleMethodDestringer.forString(java.lang.String)
            <-- am.beans.reflect.MethodCaller.call(java.lang.Object, java.lang.Object[])
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.MethodInvokable.invoke(java.lang.reflect.Member, java.lang.Object, java.lang.Object[])
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils.tryFactory(java.lang.Object, java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.tryStaticFactory(java.lang.Object[], java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
            <-- am.englet.cast.InstanceMethodBasedCaster.doCast(java.lang.Object)
            <-- am.englet.cast.StaticFactoryMethodBasedCaster.doCast(java.lang.Object)
        isAccessible() *
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        setAccessible(boolean) *
            <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        toString() *
            <-- am.englet.Management$7.check(java.lang.reflect.Method)
            <-- am.englet.Utils$2.check(java.lang.reflect.Method)
    Modifier *
        isAbstract(int) *
            <-- am.englet.Lookup.tryToAdaptInstantiator(am.englet.MethodsStorage, java.lang.String, java.lang.Class, java.lang.Class[])
        isPublic(int) *
            <-- am.englet.Utils.isPublic(java.lang.Class)
        isStatic(int) *
            <-- am.beans.reflect.Destringer.forClass0(java.lang.Class)
            <-- am.beans.reflect.Utils.isInstanceReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceSelfReturning(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.isInstanceVoid(java.lang.reflect.Method)
            <-- am.englet.FieldGetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.FieldSetInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.MethodInvokable.targetType(java.lang.reflect.Member)
            <-- am.englet.MethodInvokableMetadata.isStatic()
            <-- am.englet.MethodInvokableMetadata.targetType()
            <-- am.englet.TestUtils0.unString(java.lang.String, java.lang.String)
            <-- am.englet.Utils.isStatic(java.lang.reflect.Member)
            <-- am.englet.Utils.lookUpFactoryInstanceMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.Utils.lookUpStaticFactoryMethod(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.wrapToImplementor(java.lang.Object)
            <-- am.englet.reflect.Utils$4.check(java.lang.reflect.Method)
    Proxy *
        newProxyInstance(java.lang.ClassLoader, java.lang.Class[], java.lang.reflect.InvocationHandler) *
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
java.math *
    BigDecimal *
        <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
        <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        <-- am.englet.TestUtils0.div(java.math.BigDecimal, java.math.BigDecimal)
        <-- am.englet.TestUtils0.equals(java.math.BigDecimal, java.math.BigDecimal)
        <-- am.englet.TestUtils0.gt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.lt(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.minus(java.lang.Number, java.lang.Number)
        <-- am.englet.TestUtils0.minus(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        <-- am.englet.TestUtils0.times(java.math.BigDecimal, java.math.BigDecimal)
        <-- am.englet.Utils.MAX_INT_BD
        <-- am.englet.Utils.MIN_INT_BD
        <-- am.englet.Utils.correctValue(java.lang.Object)
        <-- am.englet.Utils.static {}
        BigDecimal(double) *
            <-- am.englet.SimpleCastingContext$8.cast(java.lang.Number)
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        BigDecimal(java.lang.String) *
            <-- am.englet.Immediate.bigdec(am.englet.DataStack, am.englet.CommandSource, am.englet.MethodsStorage)
            <-- am.englet.SimpleCastingContext.toBigDecimal(java.lang.Object)
            <-- am.englet.TestUtils0.bigdec(java.lang.Object)
        add(java.math.BigDecimal) *
            <-- am.englet.TestUtils0.plus(java.lang.Object, java.lang.Object)
        compareTo(java.math.BigDecimal) *
            <-- am.englet.TestUtils0.equals(java.math.BigDecimal, java.math.BigDecimal)
            <-- am.englet.TestUtils0.gt(java.lang.Number, java.lang.Number)
            <-- am.englet.TestUtils0.lt(java.lang.Number, java.lang.Number)
            <-- am.englet.Utils.correctValue(java.lang.Object)
        divide(java.math.BigDecimal, int) *
            <-- am.englet.TestUtils0.div(java.math.BigDecimal, java.math.BigDecimal)
        intValue() *
            <-- am.englet.Utils.correctValue(java.lang.Object)
        multiply(java.math.BigDecimal) *
            <-- am.englet.TestUtils0.times(java.math.BigDecimal, java.math.BigDecimal)
        scale() *
            <-- am.englet.Utils.correctValue(java.lang.Object)
        subtract(java.math.BigDecimal) *
            <-- am.englet.TestUtils0.minus(java.lang.Number, java.lang.Number)
            <-- am.englet.TestUtils0.minus(java.lang.String, java.lang.String)
        valueOf(long) *
            <-- am.englet.Utils.static {}
    BigInteger *
        <-- am.englet.SimpleCastingContext$7.cast(java.lang.Number)
        <-- am.englet.TestUtils0.equals(java.math.BigInteger, java.math.BigInteger)
        <-- am.englet.Utils.MAX_INT
        <-- am.englet.Utils.MIN_INT
        <-- am.englet.Utils.correctValue(java.lang.Object)
        <-- am.englet.Utils.static {}
        compareTo(java.math.BigInteger) *
            <-- am.englet.TestUtils0.equals(java.math.BigInteger, java.math.BigInteger)
            <-- am.englet.Utils.correctValue(java.lang.Object)
        intValue() *
            <-- am.englet.Utils.correctValue(java.lang.Object)
        valueOf(long) *
            <-- am.englet.SimpleCastingContext$7.cast(java.lang.Number)
            <-- am.englet.Utils.static {}
java.net *
    URL *
        <-- am.englet.Management.add_url(java.net.URL, am.englet.cast.ClassPool)
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SimpleStringArrayEngletSettings.propsURLInput()
        <-- am.englet.Utils.tryToGetResource(java.lang.String, java.lang.Class[], am.englet.cast.ClassPool$classLoader)
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[])
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader)
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
        <-- am.englet.cast.ClassPool$classLoader.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        <-- am.englet.cast.ClassPool.getResource(java.lang.String)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.wiring.FieldBuilderImpl.classByName(java.lang.String, java.lang.ClassLoader)
        URL(java.lang.String) *
            <-- am.englet.Processing.fromUrl(java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.propsURLInput()
        openStream() *
            <-- am.englet.Processing.fromUrl(java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
    URLClassLoader *
        <-- am.englet.cast.ClassPool$classLoader
        <-- am.englet.cast.ClassPool.addURL(java.net.URL)
        URLClassLoader(java.net.URL[]) *
            <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[])
        URLClassLoader(java.net.URL[], java.lang.ClassLoader) *
            <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader)
        URLClassLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory) *
            <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
        addURL(java.net.URL) *
            <-- am.englet.cast.ClassPool$classLoader.addURL(java.net.URL)
    URLStreamHandlerFactory *
        <-- am.englet.cast.ClassPool$classLoader.ClassPool$classLoader(java.net.URL[], java.lang.ClassLoader, java.net.URLStreamHandlerFactory)
java.sql *
    ResultSet *
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.base
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.tryNext()
        getMetaData() *
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
        getObject(int) *
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        next() *
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.tryNext()
    ResultSetMetaData *
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.base
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        getColumnCount() *
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
        getColumnName(int) *
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        getColumnTypeName(int) *
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        getPrecision(int) *
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        getScale(int) *
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
    SQLException *
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
        <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.tryNext()
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
        <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
        printStackTrace() *
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider$RecordSlider.content()
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.BaseSimpleResultSetSlider(java.sql.ResultSet)
            <-- am.englet.link.backadapters.slider.db.BaseSimpleResultSetSlider.tryNext()
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.SimpleResultSetMetaDataSlider(java.sql.ResultSetMetaData)
            <-- am.englet.link.backadapters.slider.db.SimpleResultSetMetaDataSlider.content()
java.util *
    AbstractList *
        <-- am.englet.Processing$2
        <-- am.englet.link.Storage$Nothing
        <-- am.englet.util.AbstractListSingleton
        AbstractList() *
            <-- am.englet.Processing$2.Processing$2(java.lang.Object)
            <-- am.englet.link.Storage$Nothing.Storage$Nothing()
            <-- am.englet.util.AbstractListSingleton.AbstractListSingleton(java.lang.Object)
    ArrayList *
        <-- am.englet.DataStack.DataStack()
        <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.last
        <-- am.englet.DataStack.last(int)
        <-- am.englet.DataStack.popReg(java.lang.Object)
        <-- am.englet.DataStack.popResetSelf()
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.MethodsStorage$Training.MethodsStorage$Training()
        <-- am.englet.MethodsStorage$Training.data
        <-- am.englet.MethodsStorage$Training.data()
        <-- am.englet.MethodsStorage$Training.direct(java.lang.Object)
        <-- am.englet.MethodsStorage$Training.retain()
        <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        ArrayList() *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.LoopTest.test1()
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.MethodsStorage$Training.MethodsStorage$Training()
            <-- am.englet.Processing.as_list(am.englet.link.Link)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.stateengine.Act.s(java.lang.String)
            <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
        ArrayList(java.util.Collection) *
            <-- am.englet.DataStack.enlist()
            <-- am.englet.Management.array(am.englet.DataStack)
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        add(java.lang.Object) *
            <-- am.englet.DataStack.popReg(java.lang.Object)
            <-- am.englet.MethodsStorage$Training.direct(java.lang.Object)
            <-- am.englet.MethodsStorage$Training.retain()
            <-- am.englet.MethodsStorage$Training.step(java.lang.Object, am.englet.ArgumentProvider$ArgumentsAndTarget, am.englet.Invokable)
            <-- am.englet.Processing.as_list(am.englet.link.Link)
            <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        clear() *
            <-- am.englet.DataStack.popResetSelf()
        get(int) *
            <-- am.englet.DataStack.last(int)
        iterator() *
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        toArray(java.lang.Object[]) *
            <-- am.englet.MethodsStorage$Training.data()
    Arrays *
        asList(java.lang.Object[]) *
            <-- am.englet.CompoundInvokable$2.result()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.Englet$1.toString()
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.Lookup$1.result()
            <-- am.englet.Lookup$7.result()
            <-- am.englet.Lookup$9.result()
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodInvokable.extraToString()
            <-- am.englet.MethodsStorage$Dispatcher.toString()
            <-- am.englet.Processing.slide(java.lang.Object[])
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
            <-- am.englet.dispatch.Utils$1.result()
            <-- am.englet.dispatch.Utils$2.result()
            <-- am.englet.dispatch.Utils$3.result()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
            <-- am.englet.try2$A.p()
            <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        fill(java.lang.Object[], int, int, java.lang.Object) *
            <-- am.englet.inputtokenizers.EngletParserReaderToTokenizerAdapter.static {}
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
        fill(java.lang.Object[], java.lang.Object) *
            <-- am.englet.inputtokenizers.custom.ArrayBasedCharToEventConverterImpl.set(char, char, java.lang.String)
        sort(java.lang.Object[], java.util.Comparator) *
            <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
    Collection *
        <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
        <-- am.englet.$.static {}
        <-- am.englet.DataStack.doDeframe(int)
        <-- am.englet.DataStack.enlist()
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Management.array(am.englet.DataStack)
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Processing.slide(java.lang.Object[])
        <-- am.englet.Processing.slide(java.util.Collection)
        <-- am.englet.Processing.slide(java.util.Map)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.Collection)
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stop(java.util.Collection)
        <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        add(java.lang.Object) *
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.Collection)
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
        iterator() *
            <-- am.englet.Processing.slide(java.util.Collection)
        removeAll(java.util.Collection) *
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        toArray(java.lang.Object[]) *
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpByTarget(java.lang.Class)
    Collections *
        EMPTY_LIST *
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        EMPTY_MAP *
            <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
            <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
            <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.wire()
        list(java.util.Enumeration) *
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        singletonMap(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        unmodifiableList(java.util.List) *
            <-- am.englet.DataStack.enlist()
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        unmodifiableMap(java.util.Map) *
            <-- am.englet.$.static {}
            <-- am.englet.InvokableSerializer.static {}
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.SingletonPool$util.static {}
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            <-- am.englet.Utils.static {}
        unmodifiableSet(java.util.Set) *
            <-- am.englet.$.static {}
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
    Comparator *
        <-- am.englet.$$7
        <-- am.englet.$.classComparator()
        <-- am.englet.MethodsStorage$1
        <-- am.englet.MethodsStorage$Dispatcher.put(am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$1
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$2
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.END_COMPARATOR
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.START_COMPARATOR
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl$Range.static {}
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
    Date *
        Date(long) *
            <-- am.englet.Trace.timeString(long)
        getDate() *
            <-- am.englet.Trace.timeString(long)
        getHours() *
            <-- am.englet.Trace.timeString(long)
        getMinutes() *
            <-- am.englet.Trace.timeString(long)
        getMonth() *
            <-- am.englet.Trace.timeString(long)
        getSeconds() *
            <-- am.englet.Trace.timeString(long)
        getYear() *
            <-- am.englet.Trace.timeString(long)
    EmptyStackException *
        EmptyStackException() *
            <-- am.englet.DataStack.pop()
    Enumeration *
        <-- am.englet.Lookup$12
        <-- am.englet.Lookup$5.provide()
        <-- am.englet.Lookup.dataProvidersEnumeration(am.englet.Lookup$DataProvider[])
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        hasMoreElements() *
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
        nextElement() *
            <-- am.englet.Lookup$5.provide()
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
    HashMap *
        <-- am.beans.reflect.ClassMap
        <-- am.beans.reflect.Destringer.FOUND
        <-- am.beans.reflect.Destringer.dump()
        <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
        <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
        <-- am.beans.reflect.Destringer.static {}
        <-- am.englet.$$5
        <-- am.englet.DataStack$StackFrame
        <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.getArgument(java.lang.Class)
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.getSingleton(java.lang.Class)
        <-- am.englet.Englet.putSingleton(java.lang.Object)
        <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
        <-- am.englet.Englet.singletons
        <-- am.englet.InvokableSerializer$1
        <-- am.englet.InvokableSerializer$2
        <-- am.englet.Management$2.Management$2(java.lang.Class, int, java.util.HashMap, am.englet.MethodsStorage)
        <-- am.englet.Management$2.each(java.lang.reflect.Method)
        <-- am.englet.Management$2.val$replacements
        <-- am.englet.Management.access$1(java.util.HashMap, java.lang.String)
        <-- am.englet.Management.adaptClass(java.lang.String, am.englet.MethodsStorage, int, am.englet.cast.ClassPool)
        <-- am.englet.Management.getReplacementsMap(java.lang.Class)
        <-- am.englet.Management.replacement(java.util.HashMap, java.lang.String)
        <-- am.englet.MethodsStorage.MethodsStorage()
        <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
        <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
        <-- am.englet.MethodsStorage.methods
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.MethodsStorage.toString()
        <-- am.englet.SingletonPool$1
        <-- am.englet.SingletonPool$2
        <-- am.englet.link.BackAdapterFactory.BackAdapterFactory()
        <-- am.englet.link.BackAdapterFactory.adapterClasses
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.getAdapterClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        <-- am.englet.link.BackAdapterFactory.getUsageStrategy(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.strategies
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        HashMap() *
            <-- am.beans.reflect.ClassMap.ClassMap()
            <-- am.beans.reflect.Destringer.static {}
            <-- am.englet.$$5.$$5()
            <-- am.englet.$.static {}
            <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
            <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack$StackFrame.sub0(int)
            <-- am.englet.Englet.Englet(am.englet.DataStack, am.englet.MethodsStorage, am.englet.cast.ClassPool)
            <-- am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
            <-- am.englet.InvokableSerializer$1.InvokableSerializer$1()
            <-- am.englet.InvokableSerializer$2.InvokableSerializer$2()
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.MethodsStorage.MethodsStorage()
            <-- am.englet.SimpleCastingContext.static {}
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            <-- am.englet.Utils.static {}
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.link.BackAdapterFactory.BackAdapterFactory()
            <-- am.englet.stateengine.Engine.Engine()
            <-- am.englet.wiring.BeanPool.BeanPool()
            <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
            <-- am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        entrySet() *
            <-- am.englet.Englet.findImplementation(java.lang.Class)
        get(java.lang.Object) *
            <-- am.beans.reflect.ClassMap.get(java.lang.String)
            <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.getArgument(java.lang.Class)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Management.replacement(java.util.HashMap, java.lang.String)
            <-- am.englet.MethodsStorage.get(java.lang.String, java.lang.Class[], am.englet.CastingContext)
            <-- am.englet.MethodsStorage.getMethodRecord(java.lang.String, am.englet.ArgumentProvider, boolean)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        put(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.Destringer.forClass(java.lang.Class)
            <-- am.beans.reflect.Destringer.processTYPE(java.lang.Class)
            <-- am.englet.$.static {}
            <-- am.englet.Englet.putSingleton(java.lang.Object)
            <-- am.englet.Englet.putSingleton(java.lang.Object, java.lang.Class)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.methodsNames(java.lang.Class)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        toString() *
            <-- am.beans.reflect.Destringer.dump()
            <-- am.englet.DataStack$StackFrame.toString()
    HashSet *
        <-- am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        HashSet() *
            <-- am.englet.Lookup.static {}
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.ConstructorBasedCasterProvider.lookUpCollectionByTarget(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
            <-- am.englet.link.backadapters.slider.UniqunessChecker.UniqunessChecker()
        HashSet(java.util.Collection) *
            <-- am.englet.$.static {}
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
            <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        add(java.lang.Object) *
            <-- am.englet.link.BackAdapterFactory.fillAssignableClasses(java.lang.Class, java.util.HashSet)
        addAll(java.util.Collection) *
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        toArray(java.lang.Object[]) *
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
    Iterator *
        <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
        <-- am.englet.EngletParserReaderTokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.Lookup$8
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.iter1(java.lang.Class)
        <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
        <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Processing.slide(java.util.Collection)
        <-- am.englet.TokenizerFactory.forObject(java.lang.Object)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        <-- am.englet.cast.ClassPool$1
        <-- am.englet.cast.ClassPool$1.ClassPool$1(am.englet.cast.ClassPool, java.util.Iterator, java.lang.String)
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool$1.val$iterator
        <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.findClass(java.lang.String)
        <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.inputtokenizers.BackAdapterBasedIterator
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        <-- am.englet.link.backadapters.IteratorAdapter.IteratorAdapter(java.util.Iterator)
        <-- am.englet.link.backadapters.IteratorAdapter.getBack()
        <-- am.englet.link.backadapters.IteratorAdapter.getNext()
        <-- am.englet.link.backadapters.IteratorAdapter.hasNext()
        <-- am.englet.link.backadapters.IteratorAdapter.metadata()
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        hasNext() *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Processing.slide(java.util.Collection)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            <-- am.englet.link.backadapters.IteratorAdapter.hasNext()
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        next() *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.Englet.parse(java.lang.String, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Lookup.lookUpCollectionsMethod(java.lang.String, java.lang.Class[])
            <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            <-- am.englet.Lookup.lookUpInstantiator(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, am.englet.cast.ClassPool, java.lang.String, java.lang.String)
            <-- am.englet.Lookup.tryToAdaptPossibleClassNames(am.englet.MethodsStorage, java.lang.String, am.englet.cast.ClassPool, java.lang.String, java.lang.Class[], int)
            <-- am.englet.Main.main(java.lang.String[])
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
            <-- am.englet.cast.ClassPool.findClass(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            <-- am.englet.link.backadapters.IteratorAdapter.getNext()
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
    LinkedList *
        <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
        <-- am.englet.DataStack$StackFrame.shadow
        <-- am.englet.DataStack$StackFrame.shadow(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.shadow1reset()
        <-- am.englet.DataStack.doDeframe(int)
        LinkedList() *
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        add(int, java.lang.Object) *
            <-- am.englet.DataStack$StackFrame.shadow(java.lang.Object)
        listIterator() *
            <-- am.englet.DataStack$StackFrame.shadow1reset()
    List *
        <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
        <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
        <-- am.englet.CompoundInvokable$2.result()
        <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
        <-- am.englet.CompoundInvokable$CreationContext.argClasses
        <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
        <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
        <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
        <-- am.englet.DataStack.at(int)
        <-- am.englet.DataStack.at(int, int)
        <-- am.englet.DataStack.doDeframe(int)
        <-- am.englet.DataStack.enlist()
        <-- am.englet.DataStack.frame(java.util.List)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.peekResultList()
        <-- am.englet.DataStack.peekResultList(int)
        <-- am.englet.Englet$1.toString()
        <-- am.englet.Englet.isManagementMethod(java.lang.Object)
        <-- am.englet.Immediate.chain(am.englet.DataStack)
        <-- am.englet.Lookup$1.result()
        <-- am.englet.Lookup$7.result()
        <-- am.englet.Lookup$9.result()
        <-- am.englet.LoopTest$1.LoopTest$1(am.englet.LoopTest, java.lang.Class, java.util.List)
        <-- am.englet.LoopTest$1.each(java.lang.reflect.Field)
        <-- am.englet.LoopTest$1.val$l
        <-- am.englet.LoopTest.test1()
        <-- am.englet.Management.array(am.englet.DataStack)
        <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
        <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
        <-- am.englet.Management.parse(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, java.lang.String)
        <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
        <-- am.englet.MethodInvokable.extraToString()
        <-- am.englet.MethodsStorage$Dispatcher.toString()
        <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
        <-- am.englet.Processing.as_list(am.englet.link.Link)
        <-- am.englet.Processing.as_list(byte[])
        <-- am.englet.Processing.as_list(char[])
        <-- am.englet.Processing.slide(java.lang.Object[])
        <-- am.englet.Processing.wrap(java.lang.Object)
        <-- am.englet.ResultList.ResultList(java.util.List)
        <-- am.englet.ResultList.ResultList(java.util.List, int)
        <-- am.englet.ResultList.appendTo(java.util.List)
        <-- am.englet.TestUtils0.dp(java.lang.Object, int, java.util.List)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
        <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
        <-- am.englet.Utils.atStack(java.util.List, int)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
        <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
        <-- am.englet.Utils.stackIndex(java.util.List, int)
        <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.cast.CastUtils.addBySource(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CastUtils.addByTarget(am.englet.cast.CasterBank, java.lang.Class, am.englet.cast.CasterProvider, java.lang.Class[])
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.StaticFactoryMethodBasedCasterProvider$2(am.englet.cast.StaticFactoryMethodBasedCasterProvider, java.lang.Class, java.lang.Class, java.util.List)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.val$res
        <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.print(java.lang.Class[])
        <-- am.englet.dispatch.Utils$1.result()
        <-- am.englet.dispatch.Utils$2.result()
        <-- am.englet.dispatch.Utils$3.result()
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.isList(java.lang.Object)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
        <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
        <-- am.englet.link.Storage.NOTHING
        <-- am.englet.link.Storage.static {}
        <-- am.englet.link.StorageImpl.StorageImpl()
        <-- am.englet.link.StorageImpl.restore()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.AppendableBackHoldingLinkSlider(am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.slided
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.toString()
        <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.AppendableSliderImpl(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.first()
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.sliders
        <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
        <-- am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
        <-- am.englet.stateengine.Act.s(java.lang.String)
        <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
        <-- am.englet.try2$A.p()
        <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
        <-- am.englet.util.MapPath.from(java.lang.Object)
        <-- am.englet.util.MapPath.listFrom(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.createdObjects
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.instance(java.lang.Class, java.lang.Class[], java.lang.Object[])
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        add(int, java.lang.Object) *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        add(java.lang.Object) *
            <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
            <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
            <-- am.englet.LoopTest$1.each(java.lang.reflect.Field)
            <-- am.englet.MethodInvokable.dump(java.lang.reflect.Member, java.lang.Object[])
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.Processing.as_linked_list(am.englet.link.Link)
            <-- am.englet.ResultList.appendTo(java.util.List)
            <-- am.englet.Utils.add(java.lang.String, java.util.List, java.lang.String)
            <-- am.englet.Utils.addClassNames(java.lang.String, java.util.List)
            <-- am.englet.Utils.names(java.lang.String, java.lang.Class)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider$2.each(java.lang.reflect.Method)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.content()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.stateengine.Act.s(java.lang.Object, java.lang.String[], java.lang.Object, java.util.List)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        addAll(java.util.Collection) *
            <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
        clear() *
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.go(am.englet.link.backadapters.slider.Slider)
        get(int) *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.Utils.atStack(java.util.List, int)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.first()
            <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        isEmpty() *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        iterator() *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, int, java.lang.Class, java.util.List)
            <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        listIterator(int) *
            <-- am.englet.DataStack.frame(java.util.List)
        remove(int) *
            <-- am.englet.link.backadapters.slider.AppendableBackHoldingLinkSlider.tryNext()
            <-- am.englet.link.backadapters.slider.AppendableSliderImpl.tryNext()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        set(int, java.lang.Object) *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.TestUtils0.dp(java.lang.Object, int, java.util.List)
        size() *
            <-- am.englet.CompoundInvokable$CreationContext.forClass(java.lang.Class)
            <-- am.englet.DataStack.frame(java.util.List)
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.ResultList.ResultList(java.util.List, int)
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.Utils.find(am.englet.VariablesStorage, java.lang.Class, java.lang.String, int)
            <-- am.englet.Utils.stackIndex(java.util.List, int)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.link.LinkUtils.ListAsFinalLinkChain(java.util.List)
            <-- am.englet.util.AbstractListSingleton.equals(java.lang.Object)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        subList(int, int) *
            <-- am.englet.ResultList.ResultList(java.util.List, int)
        toArray() *
            <-- am.englet.ResultList.ResultList(java.util.List)
            <-- am.englet.ResultList.ResultList(java.util.List, int)
        toArray(java.lang.Object[]) *
            <-- am.englet.CompoundInvokable.create(am.englet.InvokableDescription, int, am.englet.CastingContext)
            <-- am.englet.MethodsStorage$MethodRecord.MethodsStorage$MethodRecord(am.englet.Invokable, int)
            <-- am.englet.cast.StaticFactoryMethodBasedCasterProvider.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder.findClassCastChain(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.inputtokenizers.ReaderTokenizerEngine.rule(java.util.List)
            <-- am.englet.stateengine.Act.s(java.lang.String)
            <-- am.englet.stateengine.Act.s(java.lang.String, java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.doImports()
    ListIterator *
        <-- am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.shadow1reset()
        <-- am.englet.DataStack$StackFrame.shitr
        <-- am.englet.DataStack.frame(java.util.List)
        add(java.lang.Object) *
            <-- am.englet.DataStack$StackFrame.shadow1(java.lang.Object)
        hasPrevious() *
            <-- am.englet.DataStack.frame(java.util.List)
        previous() *
            <-- am.englet.DataStack.frame(java.util.List)
    Map *
        <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
        <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
        <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
        <-- am.beans.reflect.Utils.getGetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getSetterCandidateMap(java.lang.reflect.Method)
        <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
        <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
        <-- am.englet.$.$(java.lang.Class)
        <-- am.englet.$.$(java.lang.Class, java.lang.Class)
        <-- am.englet.$.DEPRIMITIIVISATORS
        <-- am.englet.$.PERFORMERS
        <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
        <-- am.englet.$.static {}
        <-- am.englet.CompoundInvokable$CreationContext.CompoundInvokable$CreationContext()
        <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
        <-- am.englet.CompoundInvokable$CreationContext.visited
        <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
        <-- am.englet.CompoundInvokable$InvocationData.CompoundInvokable$InvocationData(java.lang.Object[])
        <-- am.englet.CompoundInvokable$InvocationData.worked
        <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
        <-- am.englet.DataStack$StackFrame.sub0(int)
        <-- am.englet.DataStack.frame(java.util.Map)
        <-- am.englet.DataStack.sub(int)
        <-- am.englet.Englet.getServiceObject(java.lang.Class)
        <-- am.englet.Englet.getSingleton(java.lang.Class)
        <-- am.englet.InvokableDescription$PreparationContext.InvokableDescription$PreparationContext()
        <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
        <-- am.englet.InvokableDescription$PreparationContext.found
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
        <-- am.englet.InvokableSerializer.access$0()
        <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
        <-- am.englet.InvokableSerializer.creators
        <-- am.englet.InvokableSerializer.provs
        <-- am.englet.InvokableSerializer.static {}
        <-- am.englet.Management.excl(java.util.Map, am.englet.DataStack)
        <-- am.englet.Management.frame(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Management.sub(am.englet.DataStack, int)
        <-- am.englet.MethodsStorage.put(java.lang.String, am.englet.MethodsStorage$MethodRecord)
        <-- am.englet.Processing.gotted(am.englet.link.Link, am.englet.DataStack)
        <-- am.englet.Processing.gotted(am.englet.link.Link, java.util.Map)
        <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
        <-- am.englet.Processing.revNP(am.englet.link.Link, java.util.Map, am.englet.link.Link)
        <-- am.englet.Processing.slide(java.util.Map)
        <-- am.englet.SimpleCastingContext.NUMBER_CASTERS
        <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
        <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
        <-- am.englet.SimpleCastingContext.static {}
        <-- am.englet.SingletonPool$util.derivationMap
        <-- am.englet.SingletonPool$util.implMap
        <-- am.englet.SingletonPool$util.static {}
        <-- am.englet.SingletonPool.derivationMap
        <-- am.englet.SingletonPool.implMap
        <-- am.englet.SingletonPool.static {}
        <-- am.englet.TestUtils0.div(am.englet.link.Link, java.util.Map)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.lang.String, java.util.Map)
        <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
        <-- am.englet.Utils$6.Utils$6(java.lang.Class, java.util.Map)
        <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[])
        <-- am.englet.Utils$6.val$m
        <-- am.englet.Utils$9.Utils$9(java.util.Map)
        <-- am.englet.Utils$9.convert(java.lang.Object)
        <-- am.englet.Utils$9.val$m
        <-- am.englet.Utils.NUMBER_CAST_RATES
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.constantProxyInvokable(am.englet.VariablesStorage, java.lang.Class, am.englet.CastingContext)
        <-- am.englet.Utils.curryLink(am.englet.link.Link, java.util.Map)
        <-- am.englet.Utils.defaultedIfEmpty(java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.deprimitivized(java.lang.Class)
        <-- am.englet.Utils.getEnsuredValueByClassKey(java.util.Map, java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
        <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
        <-- am.englet.Utils.methodsNames(java.lang.Class)
        <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
        <-- am.englet.Utils.static {}
        <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        <-- am.englet.YAMLBasedEngletSettings.processInvokables(am.englet.Englet, java.lang.Object, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.cast.CasterBankCasterProviderImpl.CasterBankCasterProviderImpl()
        <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
        <-- am.englet.cast.CasterBankCasterProviderImpl.backIndex
        <-- am.englet.cast.CasterBankCasterProviderImpl.casterTargets
        <-- am.englet.cast.CasterBankCasterProviderImpl.ensuredCastersTo(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ClassPool$1.nextValue()
        <-- am.englet.cast.ClassPool.ClassPool()
        <-- am.englet.cast.ClassPool.access$0(am.englet.cast.ClassPool)
        <-- am.englet.cast.ClassPool.classes
        <-- am.englet.cast.ClassPool.forName(java.lang.String)
        <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
        <-- am.englet.cast.ClassPool.getImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.impls
        <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
        <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
        <-- am.englet.cast.ClassPool.importedPackages
        <-- am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isFailed()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.result
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        <-- am.englet.inputtokenizers.ReaderTokenizerEngine.toString()
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
        <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
        <-- am.englet.stateengine.Engine.Engine()
        <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
        <-- am.englet.stateengine.Engine.add(am.englet.stateengine.Action)
        <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
        <-- am.englet.stateengine.Engine.putDefault(java.util.Map, java.lang.Object)
        <-- am.englet.stateengine.Engine.rules
        <-- am.englet.util.MapPath.from(java.lang.Object)
        <-- am.englet.util.MapPath.mapFrom(java.lang.Object)
        <-- am.englet.wiring.BeanPool.BeanPool()
        <-- am.englet.wiring.BeanPool.get(java.lang.String)
        <-- am.englet.wiring.BeanPool.has(java.lang.String)
        <-- am.englet.wiring.BeanPool.map
        <-- am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
        <-- am.englet.wiring.FactoryPoolImpl.FactoryPoolImpl()
        <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
        <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
        <-- am.englet.wiring.FactoryPoolImpl.factories
        <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
        <-- am.englet.wiring.FactoryPoolImpl.singletons
        <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
        <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
        <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.PoolsBuilder$CreatedObjectRecord(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder$CreatedObjectRecord.settings
        <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
        <-- am.englet.wiring.PoolsBuilder.access$1(am.englet.wiring.PoolsBuilder)
        <-- am.englet.wiring.PoolsBuilder.beans
        <-- am.englet.wiring.PoolsBuilder.build
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.fillBuild(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
        <-- am.englet.wiring.PoolsBuilder.settings
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.wire()
        clear() *
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        containsKey(java.lang.Object) *
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
            <-- am.englet.Utils$9.convert(java.lang.Object)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isSuccessfull()
            <-- am.englet.wiring.BeanPool.has(java.lang.String)
        entrySet() *
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Processing.slide(java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        get(java.lang.Object) *
            <-- am.beans.reflect.Utils.addKeyed(java.util.Map, java.lang.Object, java.util.List)
            <-- am.englet.$.$(java.lang.Class)
            <-- am.englet.$.$(java.lang.Class, java.lang.Class)
            <-- am.englet.$.instantiator(java.lang.Class, java.lang.Class[])
            <-- am.englet.CompoundInvokable$CreationContext.visited(am.englet.InvokableDescription)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.Englet.getServiceObject(java.lang.Class)
            <-- am.englet.Englet.getSingleton(java.lang.Class)
            <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            <-- am.englet.InvokableSerializer$SerializeInvokableDescription.readResolve()
            <-- am.englet.InvokableSerializer.create(java.lang.reflect.Member, java.lang.String)
            <-- am.englet.Processing.prcess(java.lang.Object, java.util.Map)
            <-- am.englet.SimpleCastingContext.doCast(java.lang.Class, java.lang.Object)
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.Utils$6.getReturnValue(java.util.Map, java.lang.reflect.Method, java.lang.Object[])
            <-- am.englet.Utils$9.convert(java.lang.Object)
            <-- am.englet.Utils.deprimitivized(java.lang.Class)
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.isUpCastable(java.lang.Class, java.lang.Class)
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.cast.CasterBankCasterProviderImpl.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.ClassPool$1.nextValue()
            <-- am.englet.cast.ClassPool.forName(java.lang.String)
            <-- am.englet.cast.ClassPool.getImpl(java.lang.Class)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.getChain(java.lang.Class)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.lang.Object, java.util.Map)
            <-- am.englet.link.InvokableTargetBackAdapterImpl.InvokableTargetBackAdapterImpl(java.util.Map)
            <-- am.englet.stateengine.Engine.act0(java.lang.Object, java.lang.Object)
            <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
            <-- am.englet.util.MapPath.from(java.lang.Object)
            <-- am.englet.wiring.BeanPool.get(java.lang.String)
            <-- am.englet.wiring.FactoryPoolImpl.factory(java.lang.Class)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameAndClass(java.lang.reflect.Field, java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder$2.byNameOrNameAndType(java.lang.reflect.Field)
            <-- am.englet.wiring.PoolsBuilder.PoolsBuilder(java.util.Map, am.englet.cast.ClassPool, am.englet.wiring.BeanPool, am.englet.SingletonPool)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.instantiateBean(java.lang.String)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.wire()
        keySet() *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        put(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.CompoundInvokable$CreationContext.visit(am.englet.InvokableDescription, am.englet.CompoundInvokable$ArgumentSource)
            <-- am.englet.CompoundInvokable$InvokableWrapper.invoke(am.englet.CompoundInvokable$InvocationData)
            <-- am.englet.InvokableDescription$PreparationContext.add(am.englet.InvokableDescription)
            <-- am.englet.SimpleCastingContext.put(java.util.Map, java.lang.Class, am.englet.SimpleCastingContext$NumberCaster)
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.lang.String, java.util.Map)
            <-- am.englet.TestUtils0.dp(java.lang.Object, java.util.List, java.util.Map)
            <-- am.englet.Utils.getEnsuredValueByKey(java.util.Map, java.lang.Object, java.lang.Class)
            <-- am.englet.Utils.put(java.util.Map, java.lang.Class, int)
            <-- am.englet.cast.CasterBankCasterProviderImpl.add(am.englet.cast.Caster)
            <-- am.englet.cast.ClassPool.ClassPool()
            <-- am.englet.cast.ClassPool.importAlias(java.lang.String, java.lang.String)
            <-- am.englet.cast.ClassPool.importPackage(java.lang.String)
            <-- am.englet.cast.ClassPool.setImpl(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.ClassPool.tryResource(java.lang.String, java.lang.String, java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
            <-- am.englet.stateengine.Engine.container(java.lang.Object, java.util.Map, java.lang.Class)
            <-- am.englet.wiring.BeanPool.put(java.lang.String, java.lang.Object)
            <-- am.englet.wiring.FactoryPoolImpl.add(am.englet.wiring.SpecialFactory)
            <-- am.englet.wiring.FactoryPoolImpl.add(java.lang.Class, am.englet.wiring.Factory)
            <-- am.englet.wiring.FactoryPoolImpl.instance(java.lang.Class)
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        putAll(java.util.Map) *
            <-- am.englet.DataStack$StackFrame.sub0(int)
        size() *
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.isFailed()
        values() *
            <-- am.englet.$.static {}
    Map$Entry *
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.wiring.PoolsBuilder.doImports()
        <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.lang.Object)
        <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        getKey() *
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        getValue() *
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.wiring.PoolsBuilder.doImports()
            <-- am.englet.wiring.PoolsBuilder.doWith(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.getObject(java.util.Map$Entry)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
    Properties *
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings()
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[])
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.lang.String[], java.util.Properties)
        <-- am.englet.SimpleStringArrayEngletSettings.SimpleStringArrayEngletSettings(java.util.Properties)
        <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
        <-- am.englet.SimpleStringArrayEngletSettings.getPre()
        <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
        <-- am.englet.SimpleStringArrayEngletSettings.props
        <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
        <-- am.englet.SingletonPool$1.SingletonPool$1()
        <-- am.englet.SingletonPool$2.SingletonPool$2()
        <-- am.englet.SingletonPool$util.access$0()
        <-- am.englet.SingletonPool$util.sImpls()
        <-- am.englet.wiring.BuilderImpl.setNameResolverProperties(java.util.Properties)
        <-- am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver()
        <-- am.englet.wiring.PropertiesBasedNameResolver.PropertiesBasedNameResolver(java.util.Properties)
        <-- am.englet.wiring.PropertiesBasedNameResolver.getProperties()
        <-- am.englet.wiring.PropertiesBasedNameResolver.properties
        <-- am.englet.wiring.PropertiesBasedNameResolver.resolve(java.lang.String)
        <-- am.englet.wiring.PropertiesBasedNameResolver.setProperties(java.util.Properties)
        Properties() *
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.SingletonPool$util.sImpls()
        Properties(java.util.Properties) *
            <-- am.englet.SimpleStringArrayEngletSettings.getProperties()
            <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
        getProperty(java.lang.String) *
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
            <-- am.englet.wiring.PropertiesBasedNameResolver.resolve(java.lang.String)
        getProperty(java.lang.String, java.lang.String) *
            <-- am.englet.SimpleStringArrayEngletSettings.apply(am.englet.Englet)
            <-- am.englet.SimpleStringArrayEngletSettings.getPre()
        load(java.io.InputStream) *
            <-- am.englet.Management.props(am.englet.DataStack, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.props(java.io.InputStream)
            <-- am.englet.SingletonPool$util.sImpls()
        propertyNames() *
            <-- am.englet.SingletonPool$1.SingletonPool$1()
            <-- am.englet.SingletonPool$2.SingletonPool$2()
        setProperty(java.lang.String, java.lang.String) *
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        store(java.io.OutputStream, java.lang.String) *
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
    Set *
        <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
        <-- am.englet.$.WRAPPERS
        <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
        <-- am.englet.$.static {}
        <-- am.englet.Englet.findImplementation(java.lang.Class)
        <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
        <-- am.englet.Lookup.importStatic(java.lang.Class)
        <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
        <-- am.englet.Lookup.static {}
        <-- am.englet.Lookup.staticClasses
        <-- am.englet.Management.parse_top(am.englet.DataStack, am.englet.ArgumentProvider, am.englet.ResultHandler, am.englet.TokenizerFactory, am.englet.MethodsStorage, am.englet.CommandSource)
        <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
        <-- am.englet.Processing.slide(java.util.Map)
        <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
        <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
        <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
        <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
        <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
        <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
        <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.TargetToSourseClassCastChainFinder$SearchStep(java.lang.Class, java.lang.Class, am.englet.cast.CasterProvider)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stop(java.util.Collection)
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stopClasses
        <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        <-- am.englet.link.AdapterMetadata.AdapterMetadata(java.lang.Class, java.lang.Class[])
        <-- am.englet.link.AdapterMetadata.preferredStrategies
        <-- am.englet.link.BackAdapterFactory.addClass(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.assignableClasses(java.lang.Class)
        <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
        <-- am.englet.link.backadapters.slider.UniqunessChecker.UniqunessChecker()
        <-- am.englet.link.backadapters.slider.UniqunessChecker.check(java.lang.Object)
        <-- am.englet.link.backadapters.slider.UniqunessChecker.set
        <-- am.englet.wiring.PoolsBuilder.fillAssignables()
        <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
        <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
        <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
        <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        add(java.lang.Object) *
            <-- am.englet.Lookup.importStatic(java.lang.Class)
            <-- am.englet.Lookup.static {}
            <-- am.englet.Utils.process(java.lang.Class, java.util.Set)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.link.backadapters.slider.UniqunessChecker.check(java.lang.Object)
        addAll(java.util.Collection) *
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.stop(java.util.Collection)
        contains(java.lang.Object) *
            <-- am.englet.$.isMoreGeneralThan(java.lang.Class, java.lang.Class)
            <-- am.englet.Englet.isManagementMethod(java.lang.Object)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.tossClass(java.lang.Class, am.englet.link.FinalLink, java.util.Map)
        iterator() *
            <-- am.beans.reflect.Utils.merge(java.util.Map, java.util.Map)
            <-- am.englet.Englet.findImplementation(java.lang.Class)
            <-- am.englet.InvokableDescription$PreparationContext.setMultiKeys()
            <-- am.englet.Lookup.lookUpImportedStatic0(am.englet.MethodsStorage, java.lang.String, am.englet.ArgumentProvider, java.lang.String)
            <-- am.englet.Management.props(am.englet.DataStack, java.util.Map)
            <-- am.englet.Utils.constantProxy(am.englet.VariablesStorage, java.lang.Class, java.util.Map)
            <-- am.englet.YAMLBasedEngletSettings.processInvMap(am.englet.Englet, java.util.Map, am.englet.YAMLBasedEngletSettings$Performer)
            <-- am.englet.bsh.Management.adapt_bsh_script(java.lang.String, am.englet.MethodsStorage, am.englet.SingletonPool)
            <-- am.englet.cast.ClassPool.addImpl(java.lang.Class)
            <-- am.englet.cast.ClassPool.foundClassesIterator(java.lang.String)
            <-- am.englet.cast.TargetToSourseClassCastChainFinder$SearchStep.step()
            <-- am.englet.link.BackAdapterFactory.getByAssignableClasses(java.lang.Class, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillAssignables()
            <-- am.englet.wiring.PoolsBuilder.fillBeanPool()
            <-- am.englet.wiring.PoolsBuilder.fillByClassAndName(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.fillByNameBlock(java.util.Map, java.util.HashMap)
            <-- am.englet.wiring.PoolsBuilder.instance(java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.setupBean(java.lang.Object, java.util.Map)
            <-- am.englet.wiring.PoolsBuilder.toSingleEntry(java.lang.Object)
        remove(java.lang.Object) *
            <-- am.englet.Utils.assignTargetsSet(java.lang.Class)
        toArray(java.lang.Object[]) *
            <-- am.englet.cast.CasterBankCasterProviderImpl.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.SameObjectCasterProvider.lookUpBySource(java.lang.Class)
    SortedMap *
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
    Stack *
        <-- am.englet.CallStackSliderImpl.CallStackSliderImpl()
        <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
        <-- am.englet.CallStackSliderImpl.at(int)
        <-- am.englet.CallStackSliderImpl.drop(int)
        <-- am.englet.CallStackSliderImpl.ensureStarted()
        <-- am.englet.CallStackSliderImpl.getStack()
        <-- am.englet.CallStackSliderImpl.peek()
        <-- am.englet.CallStackSliderImpl.realIndex(int)
        <-- am.englet.CallStackSliderImpl.stack
        <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
        <-- am.englet.CallStackSliderImpl.tryNext()
        <-- am.englet.CommandSource.toString()
        <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
        <-- am.englet.DataStack$StackFrame.peek()
        <-- am.englet.DataStack$StackFrame.pop()
        <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
        <-- am.englet.DataStack$StackFrame.st
        <-- am.englet.DataStack$StackFrame.toString()
        <-- am.englet.DataStack.DataStack()
        <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.at(int)
        <-- am.englet.DataStack.at(int, int)
        <-- am.englet.DataStack.clear()
        <-- am.englet.DataStack.deframe()
        <-- am.englet.DataStack.deframeTo(int)
        <-- am.englet.DataStack.doDeframe(int)
        <-- am.englet.DataStack.enlist()
        <-- am.englet.DataStack.frame()
        <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
        <-- am.englet.DataStack.frame(java.util.List)
        <-- am.englet.DataStack.main
        <-- am.englet.DataStack.map(int)
        <-- am.englet.DataStack.nTopArgumentTypes(int)
        <-- am.englet.DataStack.pSt()
        <-- am.englet.DataStack.param()
        <-- am.englet.DataStack.param(int)
        <-- am.englet.DataStack.peekResultList()
        <-- am.englet.DataStack.peekResultList(int)
        <-- am.englet.DataStack.pop()
        <-- am.englet.DataStack.popResetSelf()
        <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
        <-- am.englet.DataStack.size()
        <-- am.englet.DataStack.st2()
        <-- am.englet.DataStack.stack()
        <-- am.englet.DataStack.toString()
        <-- am.englet.DataStack.top()
        <-- am.englet.Links$8.Links$8(java.util.Stack, int)
        <-- am.englet.Links$8.tryNextContent()
        <-- am.englet.Links$8.val$st
        <-- am.englet.Links.flat(am.englet.link.Link, int)
        <-- am.englet.Main.main(java.lang.String[])
        <-- am.englet.Management.array(am.englet.DataStack)
        <-- am.englet.Management.dropAll(am.englet.DataStack)
        <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
        <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
        <-- am.englet.Management.param(am.englet.DataStack)
        <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
        <-- am.englet.Management.top(am.englet.DataStack)
        <-- am.englet.Utils$8.convert(java.lang.Object)
        <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        <-- am.englet.link.backadapters.slider.ChainLink.ChainLink()
        <-- am.englet.link.backadapters.slider.ChainLink.at(int)
        <-- am.englet.link.backadapters.slider.ChainLink.drop(int)
        <-- am.englet.link.backadapters.slider.ChainLink.links
        <-- am.englet.link.backadapters.slider.ChainLink.next()
        <-- am.englet.link.backadapters.slider.ChainLink.peek()
        <-- am.englet.link.backadapters.slider.ChainLink.push(am.englet.link.SliderLink)
        Stack() *
            <-- am.englet.CallStackSliderImpl.CallStackSliderImpl()
            <-- am.englet.DataStack$StackFrame.DataStack$StackFrame(am.englet.DataStack)
            <-- am.englet.DataStack.DataStack()
            <-- am.englet.DataStack.DataStack(am.englet.DataStack$StackFrame)
            <-- am.englet.Links.flat(am.englet.link.Link, int)
            <-- am.englet.link.backadapters.slider.ChainLink.ChainLink()
        addAll(java.util.Collection) *
            <-- am.englet.DataStack.doDeframe(int)
        clear() *
            <-- am.englet.DataStack.clear()
        elementAt(int) *
            <-- am.englet.Links$8.tryNextContent()
        empty() *
            <-- am.englet.Utils.run(am.englet.Englet, java.lang.Object, am.englet.link.Link)
        get(int) *
            <-- am.englet.CallStackSliderImpl.append(am.englet.link.backadapters.slider.Slider)
            <-- am.englet.CallStackSliderImpl.at(int)
            <-- am.englet.DataStack.map(int)
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
            <-- am.englet.DataStack.st2()
            <-- am.englet.Links$8.tryNextContent()
            <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
            <-- am.englet.Utils$8.convert(java.lang.Object)
            <-- am.englet.link.backadapters.slider.ChainLink.at(int)
        insertElementAt(java.lang.Object, int) *
            <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
        iterator() *
            <-- am.englet.Main.main(java.lang.String[])
        peek() *
            <-- am.englet.CallStackSliderImpl.peek()
            <-- am.englet.DataStack$StackFrame.peek()
            <-- am.englet.DataStack.stack()
            <-- am.englet.DataStack.top()
            <-- am.englet.link.backadapters.slider.ChainLink.peek()
        pop() *
            <-- am.englet.CallStackSliderImpl.tryNext()
            <-- am.englet.DataStack$StackFrame.pop()
            <-- am.englet.DataStack.param()
            <-- am.englet.Management.nAtIn(int, am.englet.DataStack)
            <-- am.englet.link.backadapters.slider.ChainLink.next()
        push(java.lang.Object) *
            <-- am.englet.CallStackSliderImpl.start(am.englet.link.Link)
            <-- am.englet.DataStack$StackFrame.push(java.lang.Object)
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.frame(am.englet.DataStack$StackFrame)
            <-- am.englet.DataStack.frame(java.util.List)
            <-- am.englet.DataStack.param(int)
            <-- am.englet.Links$8.tryNextContent()
            <-- am.englet.Links.flat(am.englet.link.Link, int)
            <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
            <-- am.englet.link.backadapters.slider.ChainLink.push(am.englet.link.SliderLink)
        remove(int) *
            <-- am.englet.Management.nAtOut(int, am.englet.DataStack)
        removeElementAt(int) *
            <-- am.englet.Links$8.tryNextContent()
        set(int, java.lang.Object) *
            <-- am.englet.Links$8.tryNextContent()
        setSize(int) *
            <-- am.englet.CallStackSliderImpl.drop(int)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.enlist()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.Management.array(am.englet.DataStack)
            <-- am.englet.Management.dropAll(am.englet.DataStack)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.link.backadapters.slider.ChainLink.drop(int)
        size() *
            <-- am.englet.CallStackSliderImpl.ensureStarted()
            <-- am.englet.CallStackSliderImpl.realIndex(int)
            <-- am.englet.CallStackSliderImpl.tryNext()
            <-- am.englet.DataStack.deframe()
            <-- am.englet.DataStack.deframeTo(int)
            <-- am.englet.DataStack.doDeframe(int)
            <-- am.englet.DataStack.frame()
            <-- am.englet.DataStack.nTopArgumentTypes(int)
            <-- am.englet.DataStack.param()
            <-- am.englet.DataStack.param(int)
            <-- am.englet.DataStack.pop()
            <-- am.englet.DataStack.popResetSelf()
            <-- am.englet.DataStack.putRes(java.util.Stack, java.lang.Class[], int)
            <-- am.englet.DataStack.size()
            <-- am.englet.DataStack.st2()
            <-- am.englet.Links$8.tryNextContent()
            <-- am.englet.Management.param(am.englet.DataStack)
            <-- am.englet.Management.pure(am.englet.Invokable, am.englet.DataStack)
            <-- am.englet.Management.top(am.englet.DataStack)
            <-- am.englet.link.backadapters.slider.ChainLink.at(int)
            <-- am.englet.link.backadapters.slider.ChainLink.drop(int)
            <-- am.englet.link.backadapters.slider.ChainLink.next()
        subList(int, int) *
            <-- am.englet.DataStack.doDeframe(int)
    StringTokenizer *
        StringTokenizer(java.lang.String) *
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            <-- am.englet.Management.getReplacementsMap(java.lang.Class)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.bsh.Management.putProbablyReplaced(am.englet.MethodsStorage, bsh.BshMethod[], java.lang.String)
        StringTokenizer(java.lang.String, java.lang.String) *
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        hasMoreElements() *
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
        hasMoreTokens() *
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
        nextToken() *
            <-- am.englet.Management$2.each(java.lang.reflect.Method)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptClasses(am.englet.Englet, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethod(am.englet.Englet, java.lang.String, java.lang.String)
            <-- am.englet.SimpleStringArrayEngletSettings.adaptMethods(am.englet.Englet, java.lang.String)
            <-- am.englet.YAMLBasedEngletSettings.processInvValue(am.englet.Englet, java.lang.String, java.lang.Object)
    TreeMap *
        <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
        <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.endMap
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
        <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.startMap
        TreeMap() *
            <-- am.beans.reflect.Utils.classFieldGetters(java.lang.Class)
            <-- am.beans.reflect.Utils.classMethodGettersRaw(java.lang.Class)
            <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
        TreeMap(java.util.Comparator) *
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.RangesBasedCharToEventConverterImpl()
        headMap(java.lang.Object) *
            <-- am.englet.inputtokenizers.custom.RangesBasedCharToEventConverterImpl.event(char)
        put(java.lang.Object, java.lang.Object) *
            <-- am.beans.reflect.Utils.getterOrSettersMap(java.lang.String[], java.lang.String, java.lang.Object)
            <-- am.beans.reflect.Utils.tryToAddGetterOrSetter(java.lang.String, java.lang.String, java.lang.Object, java.util.TreeMap)
    Vector *
        <-- am.englet.cast.CasterProvidersPool.CasterProvidersPool()
        <-- am.englet.cast.CasterProvidersPool.add(am.englet.cast.CasterProvider)
        <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
        <-- am.englet.cast.CasterProvidersPool.providers
        <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
        Vector() *
            <-- am.englet.cast.CasterProvidersPool.CasterProvidersPool()
        insertElementAt(java.lang.Object, int) *
            <-- am.englet.cast.CasterProvidersPool.add(am.englet.cast.CasterProvider)
        iterator() *
            <-- am.englet.cast.CasterProvidersPool.getImplementor(java.lang.Class, java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpBySource(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.lookUpByTarget(java.lang.Class)
            <-- am.englet.cast.CasterProvidersPool.wrapToImplementor(java.lang.Object)
java.util.regex *
    Matcher *
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.TestUtils0$11.TestUtils0$11(java.util.regex.Matcher)
        <-- am.englet.TestUtils0$11.tryNextContent()
        <-- am.englet.TestUtils0$11.val$matcher
        <-- am.englet.TestUtils0$12.TestUtils0$12(java.util.regex.Matcher, java.lang.String)
        <-- am.englet.TestUtils0$12.step()
        <-- am.englet.TestUtils0$12.val$matcher
        <-- am.englet.TestUtils0.access$0(java.util.regex.Matcher)
        <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        end() *
            <-- am.englet.TestUtils0$12.step()
        find() *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.TestUtils0$11.tryNextContent()
            <-- am.englet.TestUtils0$12.step()
        group(int) *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
        groupCount() *
            <-- am.englet.TestUtils0.extracted3(java.util.regex.Matcher)
        matches() *
            <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        start() *
            <-- am.englet.TestUtils0$12.step()
    Pattern *
        <-- am.englet.Lookup.PART_PATTERN
        <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
        <-- am.englet.Lookup.static {}
        <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
        <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        compile(java.lang.String) *
            <-- am.englet.Lookup.static {}
            <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
        compile(java.lang.String, int) *
            <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
        matcher(java.lang.CharSequence) *
            <-- am.englet.Lookup.getPossibleClassNameStarts(java.lang.Class[], int)
            <-- am.englet.TestUtils0.rxlink(java.lang.String, java.lang.String)
            <-- am.englet.TestUtils0.rxsplit(java.lang.String, java.lang.String)
            <-- am.englet.Utils.getFirstMatching(java.lang.Object[], java.lang.String)
junit.framework *
    TestCase *
        <-- am.englet.LoopTest
        <-- am.englet.cast.TargetToSourseClassCastChainFinderTest
        <-- am.englet.reflect.SimplePropertyTest
        TestCase() *
            <-- am.englet.LoopTest.LoopTest()
            <-- am.englet.cast.TargetToSourseClassCastChainFinderTest.TargetToSourseClassCastChainFinderTest()
            <-- am.englet.reflect.SimplePropertyTest.SimplePropertyTest()
        setUp() *
            <-- am.englet.reflect.SimplePropertyTest.setUp()
net.sourceforge.yamlbeans *
    YamlReader *
        YamlReader(java.io.Reader) *
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
        read() *
            <-- am.englet.YAMLBasedEngletSettings.apply(am.englet.Englet)
